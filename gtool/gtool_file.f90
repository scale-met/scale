!-------------------------------------------------------------------------------
!> module GTOOL_FILE
!!
!! @par Description
!!          unified hundring of various kinds of files
!!
!! @author Team SCALE
!!
!! @par History
!! @li      2012-06-12 (S.Nishizawa) [new] Imported from SCALE-LES
!!
!<
!-------------------------------------------------------------------------------
! Warning: This file was generated from gtool_file.f90.erb.
!          Do not edit this file.
!-------------------------------------------------------------------------------
module gtool_file
  !-----------------------------------------------------------------------------
  !
  !++ Used modules
  !
  use gtool_file_h
  use dc_log, only: &
       Log, &
       LOG_LMSG
  use dc_types, only: &
       DP, &
       SP
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedures
  !
  public :: FileOpen
  public :: FileCreate
  public :: FileSetOption
  public :: FileDefAxis
  public :: FilePutAxis
  public :: FileWriteAxis
  public :: FileDefAssociatedCoordinates
  public :: FilePutAssociatedCoordinates
  public :: FileWriteAssociatedCoordinates
  public :: FileAddVariable
  public :: FileDefineVariable
  public :: FileSetTAttr
  public :: FileGetShape
  public :: FileGetDatainfo
  public :: FileGetAllDatainfo
  public :: FileRead
  public :: FileWrite
  public :: FileGetGlobalAttribute
  public :: FileSetGlobalAttribute
  public :: FileEndDef
  public :: FileFlush
  public :: FileClose
  public :: FileCloseAll
  public :: FileMakeFname
  public :: FileAttachBuffer
  public :: FileDetachBuffer

  interface FileGetDatainfo
     module procedure FileGetDatainfoFId
     module procedure FileGetDatainfoFName
  end interface FileGetDatainfo
  interface FileGetAllDatainfo
     module procedure FileGetAllDatainfoFId
     module procedure FileGetAllDatainfoFName
  end interface FileGetAllDatainfo

  interface FilePutAxis
     module procedure FilePutAxisRealSP
     module procedure FilePutAxisRealDP
  end interface FilePutAxis
  interface FileWriteAxis
     module procedure FileWriteAxisRealSP
     module procedure FileWriteAxisRealDP
  end interface FileWriteAxis
  interface FilePutAssociatedCoordinates
    module procedure FilePut1DAssociatedCoordinatesRealSP
    module procedure FilePut1DAssociatedCoordinatesRealDP
    module procedure FilePut2DAssociatedCoordinatesRealSP
    module procedure FilePut2DAssociatedCoordinatesRealDP
    module procedure FilePut3DAssociatedCoordinatesRealSP
    module procedure FilePut3DAssociatedCoordinatesRealDP
    module procedure FilePut4DAssociatedCoordinatesRealSP
    module procedure FilePut4DAssociatedCoordinatesRealDP
  end interface FilePutAssociatedCoordinates
  interface FileWriteAssociatedCoordinates
    module procedure FileWrite1DAssociatedCoordinatesRealSP
    module procedure FileWrite1DAssociatedCoordinatesRealDP
    module procedure FileWrite2DAssociatedCoordinatesRealSP
    module procedure FileWrite2DAssociatedCoordinatesRealDP
    module procedure FileWrite3DAssociatedCoordinatesRealSP
    module procedure FileWrite3DAssociatedCoordinatesRealDP
    module procedure FileWrite4DAssociatedCoordinatesRealSP
    module procedure FileWrite4DAssociatedCoordinatesRealDP
  end interface FileWriteAssociatedCoordinates
  interface FileAddVariable
     module procedure FileAddVariableNoT
     module procedure FileAddVariableRealSP
     module procedure FileAddVariableRealDP
  end interface FileAddVariable
  interface FileRead
    module procedure FileRead1DRealSP
    module procedure FileRead1DRealDP
    module procedure FileRead2DRealSP
    module procedure FileRead2DRealDP
    module procedure FileRead3DRealSP
    module procedure FileRead3DRealDP
    module procedure FileRead4DRealSP
    module procedure FileRead4DRealDP
    module procedure FileReadVar1DRealSP
    module procedure FileReadVar1DRealDP
    module procedure FileReadVar2DRealSP
    module procedure FileReadVar2DRealDP
    module procedure FileReadVar3DRealSP
    module procedure FileReadVar3DRealDP
    module procedure FileReadVar4DRealSP
    module procedure FileReadVar4DRealDP
  end interface FileRead
  interface FileWrite
    module procedure FileWrite1DRealSP
    module procedure FileWrite1DRealDP
    module procedure FileWrite2DRealSP
    module procedure FileWrite2DRealDP
    module procedure FileWrite3DRealSP
    module procedure FileWrite3DRealDP
    module procedure FileWrite4DRealSP
    module procedure FileWrite4DRealDP
  end interface FileWrite
  interface FileGetGlobalAttribute
     module procedure FileGetGlobalAttributeText
     module procedure FileGetGlobalAttributeInt
     module procedure FileGetGlobalAttributeFloat
     module procedure FileGetGlobalAttributeDouble
  end interface FileGetGlobalAttribute
  interface FileSetGlobalAttribute
     module procedure FileSetGlobalAttributeText
     module procedure FileSetGlobalAttributeInt
     module procedure FileSetGlobalAttributeFloat
     module procedure FileSetGlobalAttributeDouble
  end interface FileSetGlobalAttribute

  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  real(DP), parameter, public :: RMISS = -9.9999e+30
  !-----------------------------------------------------------------------------
  !
  !++ Private procedures
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private parameters & variables
  !
  integer,                   private, parameter :: File_nfile_max = 512   ! number limit of file
                                                 ! Keep consistency with "FILE_MAX" in gtool_netcdf.c
  integer,                   private, parameter :: File_nvar_max  = 40960 ! number limit of variables
                                                 ! Keep consistency with "VAR_MAX" in gtool_netcdf.c

  character(len=File_HLONG), private,      save :: File_fname_list(File_nfile_max)
  integer,                   private,      save :: File_fid_list  (File_nfile_max)
  integer,                   private,      save :: File_fid_count = 1
  character(len=File_HLONG), private,      save :: File_vname_list  (File_nvar_max)
  integer,                   private,      save :: File_vid_fid_list(File_nvar_max)
  integer,                   private,      save :: File_vid_list    (File_nvar_max)
  integer,                   private,      save :: File_vid_count = 1
  integer,                   private,      save :: mpi_myrank

  character(len=LOG_LMSG),   private            :: message

contains
  !-----------------------------------------------------------------------------
  subroutine FileCreate( &
       fid,         & ! (out)
       existed,     & ! (out)
       basename,    & ! (in)
       title,       & ! (in)
       source,      & ! (in)
       institution, & ! (in)
       master,      & ! (in)
       myrank,      & ! (in)
       rankidx,     & ! (in)
       single,      & ! (in) optional
       time_units,  & ! (in) optional
       append,      & ! (in) optional
       comm         ) ! (in) optional
    use MPI, only : MPI_COMM_NULL
    implicit none

    integer,          intent(out)           :: fid
    logical,          intent(out)           :: existed
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: title
    character(len=*), intent( in)           :: source
    character(len=*), intent( in)           :: institution
    integer,          intent( in)           :: master
    integer,          intent( in)           :: myrank
    integer,          intent( in)           :: rankidx(:)
    character(len=*), intent( in), optional :: time_units
    logical,          intent( in), optional :: single
    logical,          intent( in), optional :: append
    integer,          intent( in), optional :: comm ! MPI communicator

    character(len=File_HMID) :: time_units_
    logical :: single_
    integer :: mode
    integer :: error

    intrinsic size

    if ( present(time_units) ) then
       time_units_ = time_units
    else
       time_units_ = 'seconds'
    end if

    mpi_myrank = myrank

    if ( present(single) ) then
       if ( single .and. (myrank .ne. master) ) return
       single_ = single
    else
       single_ = .false.
    endif

    mode = File_FWRITE
    if ( present(append) ) then
       if ( append ) mode = File_FAPPEND
    end if

    call FileGetfid( &
         fid,        & ! (out)
         existed,    & ! (out)
         basename,   & ! (in)
         mode,       & ! (in)
         single_,    & ! (in)
         comm        & ! (in)
         )

    if ( existed ) return

    !--- append package header to the file
    call FileSetGlobalAttribute( fid, & ! (in)
         "title", title               ) ! (in)
    call FileSetGlobalAttribute( fid, & ! (in)
         "source", source             ) ! (in)
    call FileSetGlobalAttribute( fid, & ! (in)
         "institution", institution   ) ! (in)

    if ( .NOT. present(comm) .OR. comm == MPI_COMM_NULL ) then
       ! for shared-file parallel I/O, skip attributes related to MPI processes
       call FileSetGlobalAttribute( fid, & ! (in)
            "myrank", (/myrank/)         ) ! (in)
       call FileSetGlobalAttribute( fid, & ! (in)
            "rankidx", rankidx           ) ! (in)
    end if

    call file_set_tunits( fid, & ! (in)
         time_units_,          & ! (in)
         error                 ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set time units')
    end if

    return
  end subroutine FileCreate

  !-----------------------------------------------------------------------------
  subroutine FileGetGlobalAttributeText( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (out)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    character(len=*), intent(out) :: val

    integer error

    intrinsic size

    call file_get_global_attribute_text( & ! (in)
         fid, key,                       & ! (in)
         val, error                      ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get text global attribute: '//trim(key))
    end if

    return
  end subroutine FileGetGlobalAttributeText

  !-----------------------------------------------------------------------------
  subroutine FileGetGlobalAttributeInt( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (out)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    integer,          intent(out) :: val(:)

    integer error

    intrinsic size

    call file_get_global_attribute_int( & ! (in)
         fid, key, size(val),           & ! (in)
         val, error                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get integer global attribute: '//trim(key))
    end if

    return
  end subroutine FileGetGlobalAttributeInt

  !-----------------------------------------------------------------------------
  subroutine FileGetGlobalAttributeFloat( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (out)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    real(SP),    intent(out) :: val(:)

    integer error

    intrinsic size

    call file_get_global_attribute_float( & ! (in)
         fid, key, size(val),                          & ! (in)
         val, error                                    ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get float global attribute: '//trim(key))
    end if

    return
  end subroutine FileGetGlobalAttributeFloat

  !-----------------------------------------------------------------------------
  subroutine FileGetGlobalAttributeDouble( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (out)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    real(DP),    intent(out) :: val(:)

    integer error

    intrinsic size

    call file_get_global_attribute_double( & ! (in)
         fid, key, size(val),                          & ! (in)
         val, error                                    ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get double global attribute: '//trim(key))
    end if

    return
  end subroutine FileGetGlobalAttributeDouble


  !-----------------------------------------------------------------------------
  subroutine FileSetGlobalAttributeText( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer error

    call file_set_global_attribute_text( fid, & ! (in)
         key, val,                            & ! (in)
         error                                ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set text global attribute: '//trim(key))
    end if

    return
  end subroutine FileSetGlobalAttributeText

  !-----------------------------------------------------------------------------
  subroutine FileSetGlobalAttributeInt( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    integer,          intent(in) :: val(:)

    integer error

    intrinsic size

    call file_set_global_attribute_int( fid, & ! (in)
         key, val, size(val),                & ! (in)
         error                               ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set integer global attribute: '//trim(key))
    end if

    return
  end subroutine FileSetGlobalAttributeInt

  !-----------------------------------------------------------------------------
  subroutine FileSetGlobalAttributeFloat( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    real(SP),    intent(in) :: val(:)

    integer error

    intrinsic size

    call file_set_global_attribute_float( fid, & ! (in)
         key, val, size(val),                               & ! (in)
         error                                              ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set float global attribute: '//trim(key))
    end if

    return
  end subroutine FileSetGlobalAttributeFloat

  !-----------------------------------------------------------------------------
  subroutine FileSetGlobalAttributeDouble( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: key
    real(DP),    intent(in) :: val(:)

    integer error

    intrinsic size

    call file_set_global_attribute_double( fid, & ! (in)
         key, val, size(val),                               & ! (in)
         error                                              ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set double global attribute: '//trim(key))
    end if

    return
  end subroutine FileSetGlobalAttributeDouble

  !-----------------------------------------------------------------------------
  subroutine FileSetOption( &
       fid,      & ! (in)
       filetype, & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: filetype
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer error

    call file_set_option( fid, filetype, key, val, & ! (in)
                          error                    ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set option')
    end if

    return
  end subroutine FileSetOption

  !-----------------------------------------------------------------------------
  subroutine FileOpen( &
      fid,       & ! (out)
      basename,  & ! (in)
      mode,      & ! (in)
      single,    & ! (in) optional
      comm,      & ! (in) optional
      myrank     & ! (in) optional
      )
    implicit none

    integer,          intent(out) :: fid
    character(len=*), intent( in) :: basename
    integer,          intent( in) :: mode
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: comm
    integer,          intent( in), optional :: myrank

    logical :: existed
    logical :: single_

    single_ = .false.

    if ( present(single) ) single_ = single
    if ( present(myrank) ) mpi_myrank = myrank

    call FileGetfid( fid, existed,     & ! (out)
         basename, mode, single_, comm ) ! (in)

    return
  end subroutine FileOpen

  !-----------------------------------------------------------------------------
  ! interface FilePutAxis
  !-----------------------------------------------------------------------------
  subroutine FilePutAxisRealSP( &
       fid,      & ! (in)
       name,     & ! (in)
       desc,     & ! (in)
       units,    & ! (in)
       dim_name, & ! (in)
       dtype,    & ! (in)
       val       ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_name
    integer,          intent(in) :: dtype
    real(SP),    intent(in) :: val(:)

    integer error
    intrinsic size

    call file_put_axis( fid, name, desc, units, dim_name, dtype, val, size(val), SP, & ! (in)
         error                                                                            ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put axis')
    end if

    return
  end subroutine FilePutAxisRealSP
  subroutine FilePutAxisRealDP( &
       fid,      & ! (in)
       name,     & ! (in)
       desc,     & ! (in)
       units,    & ! (in)
       dim_name, & ! (in)
       dtype,    & ! (in)
       val       ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_name
    integer,          intent(in) :: dtype
    real(DP),    intent(in) :: val(:)

    integer error
    intrinsic size

    call file_put_axis( fid, name, desc, units, dim_name, dtype, val, size(val), DP, & ! (in)
         error                                                                            ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put axis')
    end if

    return
  end subroutine FilePutAxisRealDP

  subroutine FileDefAxis( &
       fid,      & ! (in)
       name,     & ! (in)
       desc,     & ! (in)
       units,    & ! (in)
       dim_name, & ! (in)
       dtype,    & ! (in)
       dim_size  ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_name
    integer,          intent(in) :: dtype
    integer,          intent(in) :: dim_size

    integer error
    intrinsic size

    call file_def_axis( fid, name, desc, units, dim_name, dtype, dim_size, & ! (in)
         error                                                             ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to define axis')
    end if

    return
  end subroutine FileDefAxis

  !-----------------------------------------------------------------------------
  ! interface FileWriteAxis
  !-----------------------------------------------------------------------------
  subroutine FileWriteAxisRealSP( &
       fid,      & ! (in)
       name,     & ! (in)
       val,      & ! (in)
       start     ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(SP),    intent(in)           :: val(:)
    integer,          intent(in), optional :: start(:)

    integer error
    intrinsic shape

    if ( present(start) ) then
       call file_write_axis( fid, name, val, SP, start, shape(val), & ! (in)
            error                                                        ) ! (out)
    else
       call file_write_axis( fid, name, val, SP, (/1/), shape(val), & ! (in)
            error                                                        ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to write axis')
    end if

    return
  end subroutine FileWriteAxisRealSP
  subroutine FileWriteAxisRealDP( &
       fid,      & ! (in)
       name,     & ! (in)
       val,      & ! (in)
       start     ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(DP),    intent(in)           :: val(:)
    integer,          intent(in), optional :: start(:)

    integer error
    intrinsic shape

    if ( present(start) ) then
       call file_write_axis( fid, name, val, DP, start, shape(val), & ! (in)
            error                                                        ) ! (out)
    else
       call file_write_axis( fid, name, val, DP, (/1/), shape(val), & ! (in)
            error                                                        ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to write axis')
    end if

    return
  end subroutine FileWriteAxisRealDP

  !-----------------------------------------------------------------------------
  ! interface FilePutAssociatedCoordinates
  !-----------------------------------------------------------------------------
  subroutine FilePut1DAssociatedCoordinatesRealSP( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(SP),    intent(in) :: val(:)

    integer error
    intrinsic size

    call file_put_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, SP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FilePut1DAssociatedCoordinatesRealSP
  subroutine FilePut1DAssociatedCoordinatesRealDP( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(DP),    intent(in) :: val(:)

    integer error
    intrinsic size

    call file_put_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, DP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FilePut1DAssociatedCoordinatesRealDP
  subroutine FilePut2DAssociatedCoordinatesRealSP( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(SP),    intent(in) :: val(:,:)

    integer error
    intrinsic size

    call file_put_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, SP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FilePut2DAssociatedCoordinatesRealSP
  subroutine FilePut2DAssociatedCoordinatesRealDP( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(DP),    intent(in) :: val(:,:)

    integer error
    intrinsic size

    call file_put_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, DP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FilePut2DAssociatedCoordinatesRealDP
  subroutine FilePut3DAssociatedCoordinatesRealSP( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(SP),    intent(in) :: val(:,:,:)

    integer error
    intrinsic size

    call file_put_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, SP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FilePut3DAssociatedCoordinatesRealSP
  subroutine FilePut3DAssociatedCoordinatesRealDP( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(DP),    intent(in) :: val(:,:,:)

    integer error
    intrinsic size

    call file_put_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, DP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FilePut3DAssociatedCoordinatesRealDP
  subroutine FilePut4DAssociatedCoordinatesRealSP( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(SP),    intent(in) :: val(:,:,:,:)

    integer error
    intrinsic size

    call file_put_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, SP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FilePut4DAssociatedCoordinatesRealSP
  subroutine FilePut4DAssociatedCoordinatesRealDP( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(DP),    intent(in) :: val(:,:,:,:)

    integer error
    intrinsic size

    call file_put_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, DP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FilePut4DAssociatedCoordinatesRealDP

  subroutine FileDefAssociatedCoordinates( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype      ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype

    integer error
    intrinsic size

    call file_def_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FileDefAssociatedCoordinates

  !-----------------------------------------------------------------------------
  ! interface FileWriteAssociatedCoordinates
  !-----------------------------------------------------------------------------
  subroutine FileWrite1DAssociatedCoordinatesRealSP( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(SP),    intent(in)           :: val(:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer error
    intrinsic size, shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associated_coordinates( fid, name, val, SP, & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associated_coordinates( fid, name, val, SP, & ! (in)
            1, start, shape(val),                                  & ! (in)
            error                                                       ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associated_coordinates( fid, name, val, SP, & ! (in)
            1, (/1/), shape(val),             & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates: '//trim(name))
    end if

    return
  end subroutine FileWrite1DAssociatedCoordinatesRealSP
  subroutine FileWrite1DAssociatedCoordinatesRealDP( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(DP),    intent(in)           :: val(:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer error
    intrinsic size, shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associated_coordinates( fid, name, val, DP, & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associated_coordinates( fid, name, val, DP, & ! (in)
            1, start, shape(val),                                  & ! (in)
            error                                                       ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associated_coordinates( fid, name, val, DP, & ! (in)
            1, (/1/), shape(val),             & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates: '//trim(name))
    end if

    return
  end subroutine FileWrite1DAssociatedCoordinatesRealDP
  subroutine FileWrite2DAssociatedCoordinatesRealSP( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(SP),    intent(in)           :: val(:,:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer error
    intrinsic size, shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associated_coordinates( fid, name, val, SP, & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associated_coordinates( fid, name, val, SP, & ! (in)
            2, start, shape(val),                                  & ! (in)
            error                                                       ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associated_coordinates( fid, name, val, SP, & ! (in)
            2, (/1,1/), shape(val),             & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates: '//trim(name))
    end if

    return
  end subroutine FileWrite2DAssociatedCoordinatesRealSP
  subroutine FileWrite2DAssociatedCoordinatesRealDP( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(DP),    intent(in)           :: val(:,:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer error
    intrinsic size, shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associated_coordinates( fid, name, val, DP, & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associated_coordinates( fid, name, val, DP, & ! (in)
            2, start, shape(val),                                  & ! (in)
            error                                                       ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associated_coordinates( fid, name, val, DP, & ! (in)
            2, (/1,1/), shape(val),             & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates: '//trim(name))
    end if

    return
  end subroutine FileWrite2DAssociatedCoordinatesRealDP
  subroutine FileWrite3DAssociatedCoordinatesRealSP( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(SP),    intent(in)           :: val(:,:,:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer error
    intrinsic size, shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associated_coordinates( fid, name, val, SP, & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associated_coordinates( fid, name, val, SP, & ! (in)
            3, start, shape(val),                                  & ! (in)
            error                                                       ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associated_coordinates( fid, name, val, SP, & ! (in)
            3, (/1,1,1/), shape(val),             & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates: '//trim(name))
    end if

    return
  end subroutine FileWrite3DAssociatedCoordinatesRealSP
  subroutine FileWrite3DAssociatedCoordinatesRealDP( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(DP),    intent(in)           :: val(:,:,:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer error
    intrinsic size, shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associated_coordinates( fid, name, val, DP, & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associated_coordinates( fid, name, val, DP, & ! (in)
            3, start, shape(val),                                  & ! (in)
            error                                                       ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associated_coordinates( fid, name, val, DP, & ! (in)
            3, (/1,1,1/), shape(val),             & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates: '//trim(name))
    end if

    return
  end subroutine FileWrite3DAssociatedCoordinatesRealDP
  subroutine FileWrite4DAssociatedCoordinatesRealSP( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(SP),    intent(in)           :: val(:,:,:,:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer error
    intrinsic size, shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associated_coordinates( fid, name, val, SP, & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associated_coordinates( fid, name, val, SP, & ! (in)
            4, start, shape(val),                                  & ! (in)
            error                                                       ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associated_coordinates( fid, name, val, SP, & ! (in)
            4, (/1,1,1,1/), shape(val),             & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates: '//trim(name))
    end if

    return
  end subroutine FileWrite4DAssociatedCoordinatesRealSP
  subroutine FileWrite4DAssociatedCoordinatesRealDP( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(DP),    intent(in)           :: val(:,:,:,:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer error
    intrinsic size, shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associated_coordinates( fid, name, val, DP, & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associated_coordinates( fid, name, val, DP, & ! (in)
            4, start, shape(val),                                  & ! (in)
            error                                                       ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associated_coordinates( fid, name, val, DP, & ! (in)
            4, (/1,1,1,1/), shape(val),             & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates: '//trim(name))
    end if

    return
  end subroutine FileWrite4DAssociatedCoordinatesRealDP

  !-----------------------------------------------------------------------------
  ! interface FileAddVariable
  !-----------------------------------------------------------------------------
  subroutine FileAddVariableNoT( &
       vid,     & ! (out)
       fid,     & ! (in)
       varname, & ! (in)
       desc,    & ! (in)
       units,   & ! (in)
       dims,    & ! (in)
       dtype,   & ! (in)
       tavg     & ! (in) optional
       )
    integer,          intent(out) :: vid
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    logical,          intent( in), optional :: tavg

    call FileAddVariableRealDP(vid, fid, varname, desc, units, dims, dtype, &
         -1.0_DP, tavg )

    return
  end subroutine FileAddVariableNoT
  subroutine FileAddVariableRealSP( &
       vid,     & ! (out)
       fid,     & ! (in)
       varname, & ! (in)
       desc,    & ! (in)
       units,   & ! (in)
       dims,    & ! (in)
       dtype,   & ! (in)
       tint,    & ! (in)
       tavg     & ! (in) optional
       )
    integer,          intent(out) :: vid
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    real(SP),    intent( in) :: tint
    logical,          intent( in), optional :: tavg

    real(DP) :: tint8
    integer  :: itavg
    integer  :: error
    integer  :: n

    intrinsic size
    !---------------------------------------------------------------------------

    vid = -1
    do n = 1, File_vid_count
       if ( File_vid_fid_list(n) == fid .and. &
            varname == File_vname_list(n) ) then
          vid = File_vid_list(n)
       end if
    enddo

    if ( vid < 0 ) then ! variable registration
       !--- register new variable
       write(message,'(2A)') '###### Variable registration : name = ', trim(varname)
       call Log("I",message)

       tint8 = real(tint,DP)

       if ( present(tavg) ) then
          if ( tavg ) then
             itavg = 1
          else
             itavg = 0
          end if
       else
          itavg = 0
       end if

       call file_add_variable( vid,                             & ! (out)
            fid, varname, desc, units, dims, size(dims), dtype, & ! (in)
            tint8, itavg,                                       & ! (in)
            error                                               ) ! (out)
       if ( error /= SUCCESS_CODE ) then
          call Log('E', 'xxx failed to add variable: '//trim(varname))
       end if

       File_vname_list  (File_vid_count) = trim(varname)
       File_vid_list    (File_vid_count) = vid
       File_vid_fid_list(File_vid_count) = fid
       File_vid_count                    = File_vid_count + 1
    endif

    return
  end subroutine FileAddVariableRealSP
  subroutine FileAddVariableRealDP( &
       vid,     & ! (out)
       fid,     & ! (in)
       varname, & ! (in)
       desc,    & ! (in)
       units,   & ! (in)
       dims,    & ! (in)
       dtype,   & ! (in)
       tint,    & ! (in)
       tavg     & ! (in) optional
       )
    integer,          intent(out) :: vid
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    real(DP),    intent( in) :: tint
    logical,          intent( in), optional :: tavg

    real(DP) :: tint8
    integer  :: itavg
    integer  :: error
    integer  :: n

    intrinsic size
    !---------------------------------------------------------------------------

    vid = -1
    do n = 1, File_vid_count
       if ( File_vid_fid_list(n) == fid .and. &
            varname == File_vname_list(n) ) then
          vid = File_vid_list(n)
       end if
    enddo

    if ( vid < 0 ) then ! variable registration
       !--- register new variable
       write(message,'(2A)') '###### Variable registration : name = ', trim(varname)
       call Log("I",message)

       tint8 = real(tint,DP)

       if ( present(tavg) ) then
          if ( tavg ) then
             itavg = 1
          else
             itavg = 0
          end if
       else
          itavg = 0
       end if

       call file_add_variable( vid,                             & ! (out)
            fid, varname, desc, units, dims, size(dims), dtype, & ! (in)
            tint8, itavg,                                       & ! (in)
            error                                               ) ! (out)
       if ( error /= SUCCESS_CODE ) then
          call Log('E', 'xxx failed to add variable: '//trim(varname))
       end if

       File_vname_list  (File_vid_count) = trim(varname)
       File_vid_list    (File_vid_count) = vid
       File_vid_fid_list(File_vid_count) = fid
       File_vid_count                    = File_vid_count + 1
    endif

    return
  end subroutine FileAddVariableRealDP

  subroutine FileDefineVariable( &
       fid,     & ! (in)
       vid,     & ! (out)
       varname, & ! (in)
       desc,    & ! (in)
       units,   & ! (in)
       ndims,   & ! (in)
       dims,    & ! (in)
       dtype,   & ! (in)
       tint,    & ! (in) optional
       tavg     & ! (in) optional
       )
    integer,          intent(out) :: vid
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    integer,          intent( in) :: ndims
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    real(DP),         intent( in), optional :: tint
    logical,          intent( in), optional :: tavg

    real(DP) :: tint_
    integer  :: itavg
    integer  :: error
    integer  :: n

    intrinsic size
    !---------------------------------------------------------------------------

    vid = -1
    do n = 1, File_vid_count
       if ( File_vid_fid_list(n) == fid .and. &
            varname == File_vname_list(n) ) then
          vid = File_vid_list(n)
       end if
    enddo

    if ( vid < 0 ) then ! variable registration
       !--- register new variable
       write(message,'(2A)') '###### Variable registration : name = ', trim(varname)
       call Log("I",message)

       if ( present(tint) ) then
          tint_ = tint
       else
          tint_ = -1.0_DP
       endif

       if ( present(tavg) ) then
          if ( tavg ) then
             itavg = 1
          else
             itavg = 0
          end if
       else
          itavg = 0
       end if

       call file_add_variable( vid,                        & ! (out)
            fid, varname, desc, units, dims, ndims, dtype, & ! (in)
            tint_, itavg,                                  & ! (in)
            error                                          ) ! (out)
       if ( error /= SUCCESS_CODE ) then
          call Log('E', 'xxx failed to add variable: '//trim(varname))
       end if

       File_vname_list  (File_vid_count) = trim(varname)
       File_vid_list    (File_vid_count) = vid
       File_vid_fid_list(File_vid_count) = fid
       File_vid_count                    = File_vid_count + 1
    endif

    return
  end subroutine FileDefineVariable

  !-----------------------------------------------------------------------------
  ! FileSetTAttr
  !-----------------------------------------------------------------------------
  subroutine FileSetTAttr( &
     fid,   & ! (in)
     vname, & ! (in)
     key,   & ! (in)
     val    & ! (in)
     )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer :: error

    call file_set_tattr( &
         fid, vname, & ! (in)
         key, val,   & ! (in)
         error       ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to set attr for axis')
    end if

    return
  end subroutine FileSetTAttr

  !-----------------------------------------------------------------------------
  ! FileGetShape
  !-----------------------------------------------------------------------------
  subroutine FileGetShape( &
      dims,          & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      myrank,        & ! (in)
      single,        & ! (in) optional
      error          ) ! (out) optional
    implicit none

    integer,          intent(out)           :: dims(:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: single
    logical,          intent(out), optional :: error

    integer :: fid
    type(datainfo) :: dinfo
    integer :: ierror
    integer :: n

    logical :: single_
    logical :: suppress

    intrinsic size
    intrinsic shape
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) then
       single_ = single
    else
       single_ = .false.
    end if

    if ( present(error) ) then
       suppress = .true.
    else
       suppress = .false.
    end if

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,  & ! (out)
         fid, varname, 1, suppress, & ! (in)
         ierror                     ) ! (out)

    !--- verify
    if ( ierror /= SUCCESS_CODE ) then
       if ( present(error) ) then
          error = .true.
          return
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= size(dims) ) then
       write(message,*) 'xxx rank is different, ', size(dims), dinfo%rank
       call Log('E', message)
    end if
    do n = 1, size(dims)
       dims(n) = dinfo%dim_size(n)
    end do

    if ( present(error) ) error = .false.

    return
  end subroutine FileGetShape

  !-----------------------------------------------------------------------------
  ! FileGetData
  !-----------------------------------------------------------------------------
  subroutine FileGetDatainfoFName( &
      basename,    &
      varname,     &
      myrank,      &
      istep,       &
      single,      &
      description, &
      units,       &
      datatype,    &
      dim_rank,    &
      dim_name,    &
      dim_size,    &
      time_start,  &
      time_end,    &
      time_units   )
    implicit none
    character(len=*),           intent(in)  :: basename
    character(len=*),           intent(in)  :: varname
    integer,                    intent(in)  :: myrank
    integer,                    intent(in)  :: istep
    logical,                    intent(in), optional :: single

    character(len=File_HMID),   intent(out), optional :: description
    character(len=File_HSHORT), intent(out), optional :: units
    integer,                    intent(out), optional :: datatype
    integer,                    intent(out), optional :: dim_rank
    character(len=File_HSHORT), intent(out), optional :: dim_name(:)
    integer,                    intent(out), optional :: dim_size(:)
    real(DP),                   intent(out), optional :: time_start
    real(DP),                   intent(out), optional :: time_end
    character(len=File_HMID),   intent(out), optional :: time_units

    logical :: single_
    integer :: fid

    if ( present(single) ) then
       single_ = single
    else
       single_ = .false.
    end if

    mpi_myrank = myrank

    !--- search/register file
    call FileOpen( fid,        & ! [OUT]
                   basename,   & ! [IN]
                   File_FREAD, & ! [IN]
                   single_     ) ! [IN]

    call FileGetDatainfoFId( &
         fid,         &
         varname,     &
         istep,       &
         description, &
         units,       &
         datatype,    &
         dim_rank,    &
         dim_name,    &
         dim_size,    &
         time_start,  &
         time_end,    &
         time_units   )

    return
  end subroutine FileGetDatainfoFName
  subroutine FileGetDatainfoFId( &
      fid,         &
      varname,     &
      istep,       &
      description, &
      units,       &
      datatype,    &
      dim_rank,    &
      dim_name,    &
      dim_size,    &
      time_start,  &
      time_end,    &
      time_units   )
    implicit none
    integer,                    intent(in)  :: fid
    character(len=*),           intent(in)  :: varname
    integer,                    intent(in)  :: istep

    character(len=File_HMID),   intent(out), optional :: description
    character(len=File_HSHORT), intent(out), optional :: units
    integer,                    intent(out), optional :: datatype
    integer,                    intent(out), optional :: dim_rank
    character(len=File_HSHORT), intent(out), optional :: dim_name(:)
    integer,                    intent(out), optional :: dim_size(:)
    real(DP),                   intent(out), optional :: time_start
    real(DP),                   intent(out), optional :: time_end
    character(len=File_HMID),   intent(out), optional :: time_units

    type(datainfo) :: dinfo

    integer :: ndim, idim
    real(DP):: time(1)

    integer :: error

    intrinsic size
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo( dinfo,   & ! [OUT]
                            fid,     & ! [IN]
                            varname, & ! [IN]
                            istep,   & ! [IN]
                            .false., & ! [IN]
                            error    ) ! [OUT]

    !--- verify and exit
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx data info not found')
    endif

    if ( present(description) ) description = dinfo%description
    if ( present(units)       ) units       = dinfo%units
    if ( present(datatype)    ) datatype    = dinfo%datatype
    if ( present(dim_rank)    ) dim_rank    = dinfo%rank

    if ( present(dim_name) ) then
       ndim = min( dinfo%rank, size(dim_name) ) ! limit dimension rank
       do idim = 1, ndim
          dim_name(idim) = dinfo%dim_name(idim)
       enddo
    end if
    if ( present(dim_size) ) then
       ndim = min( dinfo%rank, size(dim_size) ) ! limit dimension rank
       do idim = 1, ndim
          dim_size(idim) = dinfo%dim_size(idim)
       enddo
    end if

    if ( present(time_units)  ) then
       if ( dinfo%time_units == "" ) then
          call FileGetGlobalAttribute( fid, "time_units", time_units )
       else
          time_units  = dinfo%time_units
       end if
    end if
    if ( present(time_start)  ) then
       if ( dinfo%time_units == "" ) then
          call FileGetGlobalAttribute( fid, "time", time )
          time_start = time(1)
       else
          time_start  = dinfo%time_start
       end if
    end if
    if ( present(time_end)  ) then
       if ( dinfo%time_units == "" ) then
          call FileGetGlobalAttribute( fid, "time", time )
          time_end = time(1)
       else
          time_end  = dinfo%time_end
       end if
    end if

    return
  end subroutine FileGetDatainfoFId

  !-----------------------------------------------------------------------------
  ! FileGetData
  !-----------------------------------------------------------------------------
  subroutine FileGetAllDatainfoFName( &
      step_limit,  &
      dim_limit,   &
      basename,    &
      varname,     &
      myrank,      &
      step_nmax,   &
      description, &
      units,       &
      datatype,    &
      dim_rank,    &
      dim_name,    &
      dim_size,    &
      time_start,  &
      time_end,    &
      time_units,  &
      single       )
    implicit none

    integer,                    intent(in)  :: step_limit
    integer,                    intent(in)  :: dim_limit
    character(len=*),           intent(in)  :: basename
    character(len=*),           intent(in)  :: varname
    integer,                    intent(in)  :: myrank
    integer,                    intent(out) :: step_nmax
    character(len=File_HMID),   intent(out) :: description
    character(len=File_HSHORT), intent(out) :: units
    integer,                    intent(out) :: datatype
    integer,                    intent(out) :: dim_rank
    character(len=File_HSHORT), intent(out) :: dim_name  (dim_limit)
    integer,                    intent(out) :: dim_size  (dim_limit)
    real(DP),                   intent(out) :: time_start(step_limit)
    real(DP),                   intent(out) :: time_end  (step_limit)
    character(len=File_HMID),   intent(out) :: time_units

    logical,                    intent(in), optional :: single


    integer :: fid
    logical :: single_

    mpi_myrank = myrank

    if ( present(single) ) then
       single_ = single
    else
       single_ = .false.
    end if

    !--- search/register file
    call FileOpen( fid,        & ! [OUT]
                   basename,   & ! [IN]
                   File_FREAD, & ! [IN]
                   single_     ) ! [IN]

    call FileGetAllDatainfoFId( &
      step_limit,  &
      dim_limit,   &
      fid,         &
      varname,     &
      step_nmax,   &
      description, &
      units,       &
      datatype,    &
      dim_rank,    &
      dim_name,    &
      dim_size,    &
      time_start,  &
      time_end,    &
      time_units   )

    return
  end subroutine FileGetAllDatainfoFName
  subroutine FileGetAllDatainfoFId( &
      step_limit,  &
      dim_limit,   &
      fid,         &
      varname,     &
      step_nmax,   &
      description, &
      units,       &
      datatype,    &
      dim_rank,    &
      dim_name,    &
      dim_size,    &
      time_start,  &
      time_end,    &
      time_units   )
    implicit none

    integer,                    intent(in)  :: step_limit
    integer,                    intent(in)  :: dim_limit
    integer,                    intent(in)  :: fid
    character(len=*),           intent(in)  :: varname
    integer,                    intent(out) :: step_nmax
    character(len=File_HMID),   intent(out) :: description
    character(len=File_HSHORT), intent(out) :: units
    integer,                    intent(out) :: datatype
    integer,                    intent(out) :: dim_rank
    character(len=File_HSHORT), intent(out) :: dim_name  (dim_limit)
    integer,                    intent(out) :: dim_size  (dim_limit)
    real(DP),                   intent(out) :: time_start(step_limit)
    real(DP),                   intent(out) :: time_end  (step_limit)
    character(len=File_HMID),   intent(out) :: time_units

    type(datainfo) :: dinfo

    integer :: ndim
    integer :: istep, idim

    integer :: error
    !---------------------------------------------------------------------------

    ! initialize
    description   = ""
    units         = ""
    datatype      = -1
    dim_rank      = -1
    dim_name  (:) = ""
    dim_size  (:) = -1
    time_start(:) = RMISS
    time_end  (:) = RMISS

    do istep = 1, step_limit
       !--- get data information
       call file_get_datainfo( dinfo,   & ! [OUT]
                               fid,     & ! [IN]
                               varname, & ! [IN]
                               istep,   & ! [IN]
                               .true.,  & ! [IN]
                               error    ) ! [OUT]

       !--- verify and exit
       if ( error /= SUCCESS_CODE ) then
          step_nmax = istep - 1
          exit
       endif

       if ( istep == 1 ) then
          description = dinfo%description
          units       = dinfo%units
          datatype    = dinfo%datatype
          dim_rank    = dinfo%rank

          ndim = min( dinfo%rank, dim_limit ) ! limit dimension rank
          do idim = 1, ndim
             dim_name(idim) = dinfo%dim_name(idim)
             dim_size(idim) = dinfo%dim_size(idim)
          enddo

          time_units = dinfo%time_units
       endif

       time_start(istep) = dinfo%time_start
       time_end  (istep) = dinfo%time_end
    enddo

    return
  end subroutine FileGetAllDatainfoFId

  !-----------------------------------------------------------------------------
  ! interface File_read
  !-----------------------------------------------------------------------------
  subroutine FileRead1DRealSP( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(SP),    intent(out)           :: var(:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(1)
    integer :: error
    integer :: n

    logical :: single_

    intrinsic shape
    !---------------------------------------------------------------------------

    single_ = .false.

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 1 ) then
       write(message,*) 'xxx rank is not 1', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 1
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data( var(:), & ! (out)
         dinfo, SP,                & ! (in)
         error                          ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileRead1DRealSP
  subroutine FileRead1DRealDP( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(DP),    intent(out)           :: var(:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(1)
    integer :: error
    integer :: n

    logical :: single_

    intrinsic shape
    !---------------------------------------------------------------------------

    single_ = .false.

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 1 ) then
       write(message,*) 'xxx rank is not 1', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 1
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data( var(:), & ! (out)
         dinfo, DP,                & ! (in)
         error                          ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileRead1DRealDP
  subroutine FileRead2DRealSP( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(SP),    intent(out)           :: var(:,:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(2)
    integer :: error
    integer :: n

    logical :: single_

    intrinsic shape
    !---------------------------------------------------------------------------

    single_ = .false.

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:,:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 2 ) then
       write(message,*) 'xxx rank is not 2', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 2
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data( var(:,:), & ! (out)
         dinfo, SP,                & ! (in)
         error                          ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileRead2DRealSP
  subroutine FileRead2DRealDP( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(DP),    intent(out)           :: var(:,:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(2)
    integer :: error
    integer :: n

    logical :: single_

    intrinsic shape
    !---------------------------------------------------------------------------

    single_ = .false.

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:,:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 2 ) then
       write(message,*) 'xxx rank is not 2', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 2
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data( var(:,:), & ! (out)
         dinfo, DP,                & ! (in)
         error                          ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileRead2DRealDP
  subroutine FileRead3DRealSP( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(SP),    intent(out)           :: var(:,:,:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(3)
    integer :: error
    integer :: n

    logical :: single_

    intrinsic shape
    !---------------------------------------------------------------------------

    single_ = .false.

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:,:,:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 3 ) then
       write(message,*) 'xxx rank is not 3', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 3
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data( var(:,:,:), & ! (out)
         dinfo, SP,                & ! (in)
         error                          ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileRead3DRealSP
  subroutine FileRead3DRealDP( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(DP),    intent(out)           :: var(:,:,:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(3)
    integer :: error
    integer :: n

    logical :: single_

    intrinsic shape
    !---------------------------------------------------------------------------

    single_ = .false.

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:,:,:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 3 ) then
       write(message,*) 'xxx rank is not 3', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 3
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data( var(:,:,:), & ! (out)
         dinfo, DP,                & ! (in)
         error                          ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileRead3DRealDP
  subroutine FileRead4DRealSP( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(SP),    intent(out)           :: var(:,:,:,:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(4)
    integer :: error
    integer :: n

    logical :: single_

    intrinsic shape
    !---------------------------------------------------------------------------

    single_ = .false.

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:,:,:,:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 4 ) then
       write(message,*) 'xxx rank is not 4', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 4
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data( var(:,:,:,:), & ! (out)
         dinfo, SP,                & ! (in)
         error                          ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileRead4DRealSP
  subroutine FileRead4DRealDP( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(DP),    intent(out)           :: var(:,:,:,:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(4)
    integer :: error
    integer :: n

    logical :: single_

    intrinsic shape
    !---------------------------------------------------------------------------

    single_ = .false.

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:,:,:,:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 4 ) then
       write(message,*) 'xxx rank is not 4', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 4
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data( var(:,:,:,:), & ! (out)
         dinfo, DP,                & ! (in)
         error                          ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileRead4DRealDP

  subroutine FileReadVar1DRealSP( &
      var,           & ! (out)
      fid,           & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      allow_missing, & ! (in) optional
      single,        & ! (in) optional
      ntypes,        & ! (in)
      dtype,         & ! (in)
      start,         & ! (in)
      count          & ! (in)
      )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(SP),    intent(out)           :: var(:)
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: error

    intrinsic size, shape
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 1 ) then
       write(message,*) 'xxx rank is not 1', dinfo%rank
       call Log('E', message)
    end if

    if (present(ntypes) ) then
       call file_read_data_par( var(:),                    & ! (out)
            dinfo, size(shape(var)), ntypes, dtype, start, count, & ! (in)
            error                                                 ) ! (out)
    else
       call file_read_data( var(:), & ! (out)
            dinfo, SP,                & ! (in)
            error                          ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileReadVar1DRealSP
  subroutine FileReadVar1DRealDP( &
      var,           & ! (out)
      fid,           & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      allow_missing, & ! (in) optional
      single,        & ! (in) optional
      ntypes,        & ! (in)
      dtype,         & ! (in)
      start,         & ! (in)
      count          & ! (in)
      )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(DP),    intent(out)           :: var(:)
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: error

    intrinsic size, shape
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 1 ) then
       write(message,*) 'xxx rank is not 1', dinfo%rank
       call Log('E', message)
    end if

    if (present(ntypes) ) then
       call file_read_data_par( var(:),                    & ! (out)
            dinfo, size(shape(var)), ntypes, dtype, start, count, & ! (in)
            error                                                 ) ! (out)
    else
       call file_read_data( var(:), & ! (out)
            dinfo, DP,                & ! (in)
            error                          ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileReadVar1DRealDP
  subroutine FileReadVar2DRealSP( &
      var,           & ! (out)
      fid,           & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      allow_missing, & ! (in) optional
      single,        & ! (in) optional
      ntypes,        & ! (in)
      dtype,         & ! (in)
      start,         & ! (in)
      count          & ! (in)
      )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(SP),    intent(out)           :: var(:,:)
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: error

    intrinsic size, shape
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:,:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 2 ) then
       write(message,*) 'xxx rank is not 2', dinfo%rank
       call Log('E', message)
    end if

    if (present(ntypes) ) then
       call file_read_data_par( var(:,:),                    & ! (out)
            dinfo, size(shape(var)), ntypes, dtype, start, count, & ! (in)
            error                                                 ) ! (out)
    else
       call file_read_data( var(:,:), & ! (out)
            dinfo, SP,                & ! (in)
            error                          ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileReadVar2DRealSP
  subroutine FileReadVar2DRealDP( &
      var,           & ! (out)
      fid,           & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      allow_missing, & ! (in) optional
      single,        & ! (in) optional
      ntypes,        & ! (in)
      dtype,         & ! (in)
      start,         & ! (in)
      count          & ! (in)
      )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(DP),    intent(out)           :: var(:,:)
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: error

    intrinsic size, shape
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:,:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 2 ) then
       write(message,*) 'xxx rank is not 2', dinfo%rank
       call Log('E', message)
    end if

    if (present(ntypes) ) then
       call file_read_data_par( var(:,:),                    & ! (out)
            dinfo, size(shape(var)), ntypes, dtype, start, count, & ! (in)
            error                                                 ) ! (out)
    else
       call file_read_data( var(:,:), & ! (out)
            dinfo, DP,                & ! (in)
            error                          ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileReadVar2DRealDP
  subroutine FileReadVar3DRealSP( &
      var,           & ! (out)
      fid,           & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      allow_missing, & ! (in) optional
      single,        & ! (in) optional
      ntypes,        & ! (in)
      dtype,         & ! (in)
      start,         & ! (in)
      count          & ! (in)
      )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(SP),    intent(out)           :: var(:,:,:)
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: error

    intrinsic size, shape
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:,:,:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 3 ) then
       write(message,*) 'xxx rank is not 3', dinfo%rank
       call Log('E', message)
    end if

    if (present(ntypes) ) then
       call file_read_data_par( var(:,:,:),                    & ! (out)
            dinfo, size(shape(var)), ntypes, dtype, start, count, & ! (in)
            error                                                 ) ! (out)
    else
       call file_read_data( var(:,:,:), & ! (out)
            dinfo, SP,                & ! (in)
            error                          ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileReadVar3DRealSP
  subroutine FileReadVar3DRealDP( &
      var,           & ! (out)
      fid,           & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      allow_missing, & ! (in) optional
      single,        & ! (in) optional
      ntypes,        & ! (in)
      dtype,         & ! (in)
      start,         & ! (in)
      count          & ! (in)
      )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(DP),    intent(out)           :: var(:,:,:)
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: error

    intrinsic size, shape
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:,:,:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 3 ) then
       write(message,*) 'xxx rank is not 3', dinfo%rank
       call Log('E', message)
    end if

    if (present(ntypes) ) then
       call file_read_data_par( var(:,:,:),                    & ! (out)
            dinfo, size(shape(var)), ntypes, dtype, start, count, & ! (in)
            error                                                 ) ! (out)
    else
       call file_read_data( var(:,:,:), & ! (out)
            dinfo, DP,                & ! (in)
            error                          ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileReadVar3DRealDP
  subroutine FileReadVar4DRealSP( &
      var,           & ! (out)
      fid,           & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      allow_missing, & ! (in) optional
      single,        & ! (in) optional
      ntypes,        & ! (in)
      dtype,         & ! (in)
      start,         & ! (in)
      count          & ! (in)
      )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(SP),    intent(out)           :: var(:,:,:,:)
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: error

    intrinsic size, shape
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:,:,:,:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 4 ) then
       write(message,*) 'xxx rank is not 4', dinfo%rank
       call Log('E', message)
    end if

    if (present(ntypes) ) then
       call file_read_data_par( var(:,:,:,:),                    & ! (out)
            dinfo, size(shape(var)), ntypes, dtype, start, count, & ! (in)
            error                                                 ) ! (out)
    else
       call file_read_data( var(:,:,:,:), & ! (out)
            dinfo, SP,                & ! (in)
            error                          ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileReadVar4DRealSP
  subroutine FileReadVar4DRealDP( &
      var,           & ! (out)
      fid,           & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      allow_missing, & ! (in) optional
      single,        & ! (in) optional
      ntypes,        & ! (in)
      dtype,         & ! (in)
      start,         & ! (in)
      count          & ! (in)
      )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(DP),    intent(out)           :: var(:,:,:,:)
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: error

    intrinsic size, shape
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:,:,:,:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 4 ) then
       write(message,*) 'xxx rank is not 4', dinfo%rank
       call Log('E', message)
    end if

    if (present(ntypes) ) then
       call file_read_data_par( var(:,:,:,:),                    & ! (out)
            dinfo, size(shape(var)), ntypes, dtype, start, count, & ! (in)
            error                                                 ) ! (out)
    else
       call file_read_data( var(:,:,:,:), & ! (out)
            dinfo, DP,                & ! (in)
            error                          ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileReadVar4DRealDP

  !-----------------------------------------------------------------------------
  ! interface FileWrite
  !-----------------------------------------------------------------------------
  subroutine FileWrite1DRealSP( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
      start,   & ! (in)
      count,   & ! (in)
      ndims    & ! (in)
      )
    implicit none

    real(SP), intent(in) :: var(:)
    integer,  intent(in)           :: fid
    integer,  intent(in)           :: vid
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    integer,  intent(in), optional :: count(:) ! when var has been reshaped to 1D
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D

    real(DP) :: ts, te

    integer :: start_(1)

    integer :: error, n
    character(len=100) :: str

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          call Log('E', 'start argument is neccessary when ndims is specified')
       end if
       if ( .not. present(count) ) then
          call Log('E', 'count argument is neccessary when ndims is specified')
       end if

       call file_write_data( fid, vid, var(:), ts, te, SP, & ! (in)
            ndims, start, count,                                       & ! (in)
            error                                                      ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data( fid, vid, var(:), ts, te, SP, & ! (in)
            1, start_, shape(var),                                & ! (in)
            error                                                      ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWrite1DRealSP
  subroutine FileWrite1DRealDP( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
      start,   & ! (in)
      count,   & ! (in)
      ndims    & ! (in)
      )
    implicit none

    real(DP), intent(in) :: var(:)
    integer,  intent(in)           :: fid
    integer,  intent(in)           :: vid
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    integer,  intent(in), optional :: count(:) ! when var has been reshaped to 1D
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D

    real(DP) :: ts, te

    integer :: start_(1)

    integer :: error, n
    character(len=100) :: str

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          call Log('E', 'start argument is neccessary when ndims is specified')
       end if
       if ( .not. present(count) ) then
          call Log('E', 'count argument is neccessary when ndims is specified')
       end if

       call file_write_data( fid, vid, var(:), ts, te, DP, & ! (in)
            ndims, start, count,                                       & ! (in)
            error                                                      ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data( fid, vid, var(:), ts, te, DP, & ! (in)
            1, start_, shape(var),                                & ! (in)
            error                                                      ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWrite1DRealDP
  subroutine FileWrite2DRealSP( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
      start,   & ! (in)
      count,   & ! (in)
      ndims    & ! (in)
      )
    implicit none

    real(SP), intent(in) :: var(:,:)
    integer,  intent(in)           :: fid
    integer,  intent(in)           :: vid
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    integer,  intent(in), optional :: count(:) ! when var has been reshaped to 1D
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D

    real(DP) :: ts, te

    integer :: start_(2)

    integer :: error, n
    character(len=100) :: str

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          call Log('E', 'start argument is neccessary when ndims is specified')
       end if
       if ( .not. present(count) ) then
          call Log('E', 'count argument is neccessary when ndims is specified')
       end if

       call file_write_data( fid, vid, var(:,:), ts, te, SP, & ! (in)
            ndims, start, count,                                       & ! (in)
            error                                                      ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data( fid, vid, var(:,:), ts, te, SP, & ! (in)
            2, start_, shape(var),                                & ! (in)
            error                                                      ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWrite2DRealSP
  subroutine FileWrite2DRealDP( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
      start,   & ! (in)
      count,   & ! (in)
      ndims    & ! (in)
      )
    implicit none

    real(DP), intent(in) :: var(:,:)
    integer,  intent(in)           :: fid
    integer,  intent(in)           :: vid
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    integer,  intent(in), optional :: count(:) ! when var has been reshaped to 1D
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D

    real(DP) :: ts, te

    integer :: start_(2)

    integer :: error, n
    character(len=100) :: str

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          call Log('E', 'start argument is neccessary when ndims is specified')
       end if
       if ( .not. present(count) ) then
          call Log('E', 'count argument is neccessary when ndims is specified')
       end if

       call file_write_data( fid, vid, var(:,:), ts, te, DP, & ! (in)
            ndims, start, count,                                       & ! (in)
            error                                                      ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data( fid, vid, var(:,:), ts, te, DP, & ! (in)
            2, start_, shape(var),                                & ! (in)
            error                                                      ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWrite2DRealDP
  subroutine FileWrite3DRealSP( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
      start,   & ! (in)
      count,   & ! (in)
      ndims    & ! (in)
      )
    implicit none

    real(SP), intent(in) :: var(:,:,:)
    integer,  intent(in)           :: fid
    integer,  intent(in)           :: vid
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    integer,  intent(in), optional :: count(:) ! when var has been reshaped to 1D
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D

    real(DP) :: ts, te

    integer :: start_(3)

    integer :: error, n
    character(len=100) :: str

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          call Log('E', 'start argument is neccessary when ndims is specified')
       end if
       if ( .not. present(count) ) then
          call Log('E', 'count argument is neccessary when ndims is specified')
       end if

       call file_write_data( fid, vid, var(:,:,:), ts, te, SP, & ! (in)
            ndims, start, count,                                       & ! (in)
            error                                                      ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data( fid, vid, var(:,:,:), ts, te, SP, & ! (in)
            3, start_, shape(var),                                & ! (in)
            error                                                      ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWrite3DRealSP
  subroutine FileWrite3DRealDP( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
      start,   & ! (in)
      count,   & ! (in)
      ndims    & ! (in)
      )
    implicit none

    real(DP), intent(in) :: var(:,:,:)
    integer,  intent(in)           :: fid
    integer,  intent(in)           :: vid
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    integer,  intent(in), optional :: count(:) ! when var has been reshaped to 1D
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D

    real(DP) :: ts, te

    integer :: start_(3)

    integer :: error, n
    character(len=100) :: str

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          call Log('E', 'start argument is neccessary when ndims is specified')
       end if
       if ( .not. present(count) ) then
          call Log('E', 'count argument is neccessary when ndims is specified')
       end if

       call file_write_data( fid, vid, var(:,:,:), ts, te, DP, & ! (in)
            ndims, start, count,                                       & ! (in)
            error                                                      ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data( fid, vid, var(:,:,:), ts, te, DP, & ! (in)
            3, start_, shape(var),                                & ! (in)
            error                                                      ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWrite3DRealDP
  subroutine FileWrite4DRealSP( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
      start,   & ! (in)
      count,   & ! (in)
      ndims    & ! (in)
      )
    implicit none

    real(SP), intent(in) :: var(:,:,:,:)
    integer,  intent(in)           :: fid
    integer,  intent(in)           :: vid
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    integer,  intent(in), optional :: count(:) ! when var has been reshaped to 1D
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D

    real(DP) :: ts, te

    integer :: start_(4)

    integer :: error, n
    character(len=100) :: str

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          call Log('E', 'start argument is neccessary when ndims is specified')
       end if
       if ( .not. present(count) ) then
          call Log('E', 'count argument is neccessary when ndims is specified')
       end if

       call file_write_data( fid, vid, var(:,:,:,:), ts, te, SP, & ! (in)
            ndims, start, count,                                       & ! (in)
            error                                                      ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data( fid, vid, var(:,:,:,:), ts, te, SP, & ! (in)
            4, start_, shape(var),                                & ! (in)
            error                                                      ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWrite4DRealSP
  subroutine FileWrite4DRealDP( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
      start,   & ! (in)
      count,   & ! (in)
      ndims    & ! (in)
      )
    implicit none

    real(DP), intent(in) :: var(:,:,:,:)
    integer,  intent(in)           :: fid
    integer,  intent(in)           :: vid
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    integer,  intent(in), optional :: count(:) ! when var has been reshaped to 1D
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D

    real(DP) :: ts, te

    integer :: start_(4)

    integer :: error, n
    character(len=100) :: str

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          call Log('E', 'start argument is neccessary when ndims is specified')
       end if
       if ( .not. present(count) ) then
          call Log('E', 'count argument is neccessary when ndims is specified')
       end if

       call file_write_data( fid, vid, var(:,:,:,:), ts, te, DP, & ! (in)
            ndims, start, count,                                       & ! (in)
            error                                                      ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data( fid, vid, var(:,:,:,:), ts, te, DP, & ! (in)
            4, start_, shape(var),                                & ! (in)
            error                                                      ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWrite4DRealDP

  !-----------------------------------------------------------------------------
  ! exit netCDF define mode and enter data mode
  subroutine FileEndDef( &
       fid & ! (in)
       )
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) exit
    end do
    if ( fid .NE. File_fid_list(n) ) then
       write(message,*) 'xxx in FileEndDef invalid fid' , fid
       call Log('E', message)
    end if

    call file_enddef( fid, error )

    if ( error == SUCCESS_CODE ) then

       call Log("I",'')
       write(message,'(A,I3.3,2A)') '###### File end define mode : No.', File_fid_list(n), &
                                                  ', name = ', trim(File_fname_list(n))
       call Log("I",message)
       call Log("I",'')

    else

       call Log('E', 'xxx failed to exit define mode')

    end if

    return
  end subroutine FileEndDef

  !-----------------------------------------------------------------------------
  ! This subroutine is used when PnetCDF I/O method is enabled
  subroutine FileAttachBuffer( &
       fid,       & ! (in)
       buf_amount ) ! (in)
    implicit none

    integer, intent(in) :: fid
    integer, intent(in) :: buf_amount

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) exit
    end do
    if ( fid .NE. File_fid_list(n) ) then
       write(message,*) 'xxx in FileAttachBuffer invalid fid' , fid
       call Log('E', message)
    end if

    call file_attach_buffer( fid, buf_amount, error )

    if ( error == SUCCESS_CODE ) then

       write(message,'(A,I3.3,3A,I10)') '###### File attach buffer : No.', File_fid_list(n),  &
                                                       ', name = ', trim(File_fname_list(n)), &
                                                       ', size = ', buf_amount
       call Log("I",message)

    else

       call Log('E', 'xxx failed to attach buffer in PnetCDF')

    end if

    return
  end subroutine FileAttachBuffer

  !-----------------------------------------------------------------------------
  ! This subroutine is used when PnetCDF I/O method is enabled
  subroutine FileDetachBuffer( &
       fid        ) ! (in)
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) exit
    end do
    if ( n == File_fid_count ) return  ! already closed

    if ( fid .NE. File_fid_list(n) ) then
       write(message,*) 'xxx in FileDetachBuffer invalid fid' , fid
       call Log('E', message)
    end if

    call file_detach_buffer( fid, error )

    if ( error == SUCCESS_CODE ) then

       write(message,'(A,I3.3,2A)') '###### File detach buffer : No.', File_fid_list(n), &
                                                   ', name = ', trim(File_fname_list(n))
       call Log("I",message)

    else

       call Log('E', 'xxx failed to detach buffer in PnetCDF')

    end if

    return
  end subroutine FileDetachBuffer

  !-----------------------------------------------------------------------------
  ! This subroutine is used when PnetCDF I/O method is enabled
  subroutine FileFlush( &
       fid & ! (in)
       )
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return
    if ( File_fid_count == 1 ) return

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) exit
    end do
    if ( n == File_fid_count ) return  ! already closed

    if ( fid .NE. File_fid_list(n) ) then
       write(message,*) 'xxx in FileFlush invalid fid' , fid
       call Log('E', message)
    end if

    call file_flush( fid, error )

    if ( error == SUCCESS_CODE ) then

       write(message,'(A,I3.3,2A)') '###### File flush : No.', File_fid_list(n), &
                                                  ', name = ', trim(File_fname_list(n))
       call Log("I",message)
       call Log("I",'')

    else

       call Log('E', 'xxx failed to flush PnetCDF pending requests')

    end if

    return
  end subroutine FileFlush

  !-----------------------------------------------------------------------------
  subroutine FileClose( &
       fid & ! (in)
       )
    implicit none

    integer, intent(in) :: fid

    character(len=File_HLONG) :: fname
    integer                   :: error
    integer                   :: n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) exit
    end do
    if ( n == File_fid_count ) return  ! already closed

    if ( fid /= File_fid_list(n) ) then
       write(message,*) 'xxx in FileClose invalid fid ', fid
       call Log('E', message)
    end if

    call file_close( fid, error )

    if ( error == SUCCESS_CODE ) then

       write(message,'(A,I3.3,2A)') '###### File close : No.', File_fid_list(n), &
                                                  ', name = ', trim(File_fname_list(n))
       call Log("I",message)
       call Log("I",'')

    elseif( error /= ALREADY_CLOSED_CODE ) then

       call Log('E', 'xxx failed to close file')

    end if

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) then
          File_fid_list(n) = -1
          File_fname_list(n) = ''
       end if
    end do

    return
  end subroutine FileClose
  !-----------------------------------------------------------------------------
  subroutine FileCloseAll
    implicit none

    integer n
    !---------------------------------------------------------------------------

    do n = 1, File_fid_count-1
       call FileClose( File_fid_list(n) )
    enddo

    return
  end subroutine FileCloseAll

  !-----------------------------------------------------------------------------
  ! private
  !-----------------------------------------------------------------------------
  subroutine FileMakeFname( &
       fname,    & ! (out)
       basename, & ! (in)
       prefix,   & ! (in)
       myrank,   & ! (in)
       len       ) ! (in)
    character(len=*), intent(out) :: fname
    character(len=*), intent( in) :: basename
    character(len=*), intent( in) :: prefix
    integer,          intent( in) :: myrank
    integer,          intent( in) :: len

    !                           12345678901234567
    character(len=17) :: fmt = "(A, '.', A, I*.*)"
    !---------------------------------------------------------------------------

    if ( len < 1 .or. len > 9 ) then
       call Log('E', 'xxx len is invalid')
    end if

    write(fmt(14:14),'(I1)') len
    write(fmt(16:16),'(I1)') len
    write(fname, fmt) trim(basename), trim(prefix), myrank

    return
  end subroutine FileMakeFname
  !-----------------------------------------------------------------------------
  subroutine FileGetfid( &
      fid,        &
      existed,    &
      basename,   &
      mode,       &
      single,     &
      comm        )
    use MPI, only : MPI_COMM_NULL, MPI_COMM_SELF
    implicit none

    integer,          intent(out) :: fid
    logical,          intent(out) :: existed
    character(len=*), intent( in) :: basename
    integer,          intent( in) :: mode
    logical,          intent( in) :: single
    integer,          intent( in), optional :: comm

    character(len=File_HSHORT) :: rwname(0:2)
    data rwname / 'READ','WRITE','APPEND' /

    character(len=File_HLONG) :: fname
    integer                   :: n

    integer :: error
    integer :: comm_
    !---------------------------------------------------------------------------

    !--- register new file and open
    comm_ = MPI_COMM_NULL
    if ( present(comm) ) comm_ = comm
    if ( comm_ .NE. MPI_COMM_NULL ) then
       ! parallel I/O on a single shared netCDF file
       fname = basename
       comm_ = comm
    elseif ( single ) then
       fname = trim(basename)//'.peall'
    else
       call FileMakeFname(fname,trim(basename),'pe',mpi_myrank,6)
    endif

    !--- search existing file
    fid = -1
    do n = 1, File_fid_count-1
       if ( fname==File_fname_list(n) ) fid = File_fid_list(n)
    enddo

    if ( fid >= 0 ) then
       existed = .true.
       return
    end if

    call file_open( fid,     & ! (out)
         fname, mode, comm_, & ! (in)
         error               ) ! (out)

    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to open file :'//trim(fname)//'.nc')
    end if

    call Log("I",'')
    write(message,'(3A,I3.3,2A)') '###### File registration (', &
                                  trim(rwname(mode)), ') : No.', fid, ', name = ', trim(fname)
    call Log("I",message)

    File_fname_list(File_fid_count) = trim(fname)
    File_fid_list  (File_fid_count) = fid
    File_fid_count                  = File_fid_count + 1

    existed = .false.

    return
  end subroutine FileGetfid

end module gtool_file
!-------------------------------------------------------------------------------


!--
! vi:set readonly sw=4 ts=8
!
!Local Variables:
!mode: f90
!buffer-read-only: t
!End:
!
!++
