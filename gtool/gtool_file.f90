!-------------------------------------------------------------------------------
!> module GTOOL_FILE
!!
!! @par Description
!!          unified hundring of various kinds of files
!!
!! @author Team SCALE
!!
!! @par History
!! @li      2012-06-12 (S.Nishizawa) [new] Imported from SCALE-LES
!!
!<
!-------------------------------------------------------------------------------
! Warning: This file was generated from gtool_file.f90.erb.
!          Do not edit this file.
!-------------------------------------------------------------------------------
module gtool_file
  !-----------------------------------------------------------------------------
  !
  !++ Used modules
  !
  use gtool_file_h
  use dc_log, only: &
       Log, &
       LOG_LMSG
  use dc_types, only: &
       DP, &
       SP
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedures
  !
  public :: FileOpen
  public :: FileCreate
  public :: FileSetOption
  public :: FileDefAxis
  public :: FilePutAxis
  public :: FileWriteAxis
  public :: FileDefAssociatedCoordinates
  public :: FilePutAssociatedCoordinates
  public :: FileWriteAssociatedCoordinates
  public :: FileAddVariable
  public :: FileDefineVariable
  public :: FileSetTAttr
  public :: FileGetShape
  public :: FileGetDatainfo
  public :: FileGetAllDatainfo
  public :: FileRead
  public :: FileWrite
  public :: FileWriteVar
  public :: FileGetGlobalAttribute
  public :: FileSetGlobalAttribute
  public :: FileEndDef
  public :: FileClose
  public :: FileCloseAll
  public :: FileMakeFname

  interface FilePutAxis
     module procedure FilePutAxisRealSP
     module procedure FilePutAxisRealDP
  end interface FilePutAxis
  interface FileWriteAxis
     module procedure FileWriteAxisRealSP
     module procedure FileWriteAxisRealDP
  end interface FileWriteAxis
  interface FilePutAssociatedCoordinates
    module procedure FilePut1DAssociatedCoordinatesRealSP
    module procedure FilePut1DAssociatedCoordinatesRealDP
    module procedure FilePut2DAssociatedCoordinatesRealSP
    module procedure FilePut2DAssociatedCoordinatesRealDP
    module procedure FilePut3DAssociatedCoordinatesRealSP
    module procedure FilePut3DAssociatedCoordinatesRealDP
    module procedure FilePut4DAssociatedCoordinatesRealSP
    module procedure FilePut4DAssociatedCoordinatesRealDP
  end interface FilePutAssociatedCoordinates
  interface FileWriteAssociatedCoordinates
    module procedure FileWrite1DAssociatedCoordinatesRealSP
    module procedure FileWrite1DAssociatedCoordinatesRealDP
    module procedure FileWrite2DAssociatedCoordinatesRealSP
    module procedure FileWrite2DAssociatedCoordinatesRealDP
    module procedure FileWrite3DAssociatedCoordinatesRealSP
    module procedure FileWrite3DAssociatedCoordinatesRealDP
    module procedure FileWrite4DAssociatedCoordinatesRealSP
    module procedure FileWrite4DAssociatedCoordinatesRealDP
  end interface FileWriteAssociatedCoordinates
  interface FileAddVariable
     module procedure FileAddVariableNoT
     module procedure FileAddVariableRealSP
     module procedure FileAddVariableRealDP
  end interface FileAddVariable
  interface FileRead
    module procedure FileRead1DRealSP
    module procedure FileRead1DRealDP
    module procedure FileRead2DRealSP
    module procedure FileRead2DRealDP
    module procedure FileRead3DRealSP
    module procedure FileRead3DRealDP
    module procedure FileRead4DRealSP
    module procedure FileRead4DRealDP
  end interface FileRead
  interface FileWrite
    module procedure FileWrite1DRealSP
    module procedure FileWrite1DRealDP
    module procedure FileWrite2DRealSP
    module procedure FileWrite2DRealDP
    module procedure FileWrite3DRealSP
    module procedure FileWrite3DRealDP
    module procedure FileWrite4DRealSP
    module procedure FileWrite4DRealDP
  end interface FileWrite
  interface FileWriteVar
    module procedure FileWriteVar1DRealSP
    module procedure FileWriteVar1DRealDP
    module procedure FileWriteVar2DRealSP
    module procedure FileWriteVar2DRealDP
    module procedure FileWriteVar3DRealSP
    module procedure FileWriteVar3DRealDP
    module procedure FileWriteVar4DRealSP
    module procedure FileWriteVar4DRealDP
  end interface FileWriteVar
  interface FileGetGlobalAttribute
     module procedure FileGetGlobalAttributeText
     module procedure FileGetGlobalAttributeInt
     module procedure FileGetGlobalAttributeFloat
     module procedure FileGetGlobalAttributeDouble
  end interface FileGetGlobalAttribute
  interface FileSetGlobalAttribute
     module procedure FileSetGlobalAttributeText
     module procedure FileSetGlobalAttributeInt
     module procedure FileSetGlobalAttributeFloat
     module procedure FileSetGlobalAttributeDouble
  end interface FileSetGlobalAttribute

  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  real(DP), parameter, public :: RMISS = -9.9999e+30
  !-----------------------------------------------------------------------------
  !
  !++ Private procedures
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private parameters & variables
  !
  integer,                   private, parameter :: File_nfile_max = 512   ! number limit of file
                                                 ! Keep consistency with "FILE_MAX" in gtool_netcdf.c
  integer,                   private, parameter :: File_nvar_max  = 40960 ! number limit of variables
                                                 ! Keep consistency with "VAR_MAX" in gtool_netcdf.c

  character(LEN=File_HLONG), private,      save :: File_fname_list(File_nfile_max)
  integer,                   private,      save :: File_fid_list  (File_nfile_max)
  integer,                   private,      save :: File_fid_count = 1
  character(LEN=File_HLONG), private,      save :: File_vname_list  (File_nvar_max)
  integer,                   private,      save :: File_vid_fid_list(File_nvar_max)
  integer,                   private,      save :: File_vid_list    (File_nvar_max)
  integer,                   private,      save :: File_vid_count = 1
  integer,                   private,      save :: mpi_myrank

  character(LEN=LOG_LMSG),   private            :: message

contains
  !-----------------------------------------------------------------------------
  subroutine FileCreate( &
       fid,         & ! (out)
       existed,     & ! (out)
       basename,    & ! (in)
       title,       & ! (in)
       source,      & ! (in)
       institution, & ! (in)
       master,      & ! (in)
       myrank,      & ! (in)
       rankidx,     & ! (in)
       single,      & ! (in) optional
       time_units,  & ! (in) optional
       append       ) ! (in) optional
    implicit none

    integer,          intent(out)           :: fid
    logical,          intent(out)           :: existed
    character(LEN=*), intent( in)           :: basename
    character(LEN=*), intent( in)           :: title
    character(LEN=*), intent( in)           :: source
    character(LEN=*), intent( in)           :: institution
    integer,          intent( in)           :: master
    integer,          intent( in)           :: myrank
    integer,          intent( in)           :: rankidx(:)
    character(LEN=*), intent( in), optional :: time_units
    logical,          intent( in), optional :: single
    logical,          intent( in), optional :: append

    character(len=File_HMID) :: time_units_
    logical :: single_
    integer :: mode
    integer :: error

    intrinsic size

    if ( present(time_units) ) then
       time_units_ = time_units
    else
       time_units_ = 'seconds'
    end if

    mpi_myrank = myrank

    if ( present(single) ) then
       if ( single .and. (myrank .ne. master) ) return
       single_ = single
    else
       single_ = .false.
    endif

    mode = File_FWRITE
    if ( present(append) ) then
       if ( append ) mode = File_FAPPEND
    end if

    call FileGetfid( &
         fid,        & ! (out)
         existed,    & ! (out)
         basename,   & ! (in)
         mode,       & ! (in)
         single_     & ! (in)
         )

    if ( existed ) return

    !--- append package header to the file
    call FileSetGlobalAttribute( fid, & ! (in)
         "title", title               ) ! (in)
    call FileSetGlobalAttribute( fid, & ! (in)
         "source", source             ) ! (in)
    call FileSetGlobalAttribute( fid, & ! (in)
         "institution", institution   ) ! (in)
    call FileSetGlobalAttribute( fid, & ! (in)
         "myrank", (/myrank/)         ) ! (in)
    call FileSetGlobalAttribute( fid, & ! (in)
         "rankidx", rankidx           ) ! (in)

    call file_set_tunits( fid, & ! (in)
         time_units_,          & ! (in)
         error                 ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set time units')
    end if

    return
  end subroutine FileCreate

  !-----------------------------------------------------------------------------
  subroutine FileGetGlobalAttributeText( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (out)
       )
    integer,          intent(in) :: fid
    character(LEN=*), intent(in) :: key
    character(LEN=*), intent(out) :: val

    integer error

    intrinsic size

    call file_get_global_attribute_text( & ! (in)
         fid, key,                       & ! (in)
         val, error                      ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get text global attribute: '//trim(key))
    end if

    return
  end subroutine FileGetGlobalAttributeText

  !-----------------------------------------------------------------------------
  subroutine FileGetGlobalAttributeInt( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (out)
       )
    integer,          intent(in) :: fid
    character(LEN=*), intent(in) :: key
    integer,          intent(out) :: val(:)

    integer error

    intrinsic size

    call file_get_global_attribute_int( & ! (in)
         fid, key, size(val),           & ! (in)
         val, error                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get integer global attribute: '//trim(key))
    end if

    return
  end subroutine FileGetGlobalAttributeInt

  !-----------------------------------------------------------------------------
  subroutine FileGetGlobalAttributeFloat( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (out)
       )
    integer,          intent(in) :: fid
    character(LEN=*), intent(in) :: key
    real(SP),          intent(out) :: val(:)

    integer error

    intrinsic size

    call file_get_global_attribute_float( & ! (in)
         fid, key, size(val),            & ! (in)
         val, error                      ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get float global attribute: '//trim(key))
    end if

    return
  end subroutine FileGetGlobalAttributeFloat

  !-----------------------------------------------------------------------------
  subroutine FileGetGlobalAttributeDouble( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (out)
       )
    integer,          intent(in) :: fid
    character(LEN=*), intent(in) :: key
    real(DP),          intent(out) :: val(:)

    integer error

    intrinsic size

    call file_get_global_attribute_double( & ! (in)
         fid, key, size(val),            & ! (in)
         val, error                      ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get double global attribute: '//trim(key))
    end if

    return
  end subroutine FileGetGlobalAttributeDouble


  !-----------------------------------------------------------------------------
  subroutine FileSetGlobalAttributeText( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(LEN=*), intent(in) :: key
    character(LEN=*), intent(in) :: val

    integer error

    call file_set_global_attribute_text( fid, & ! (in)
         key, val,                            & ! (in)
         error                                ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set text global attribute: '//trim(key))
    end if

    return
  end subroutine FileSetGlobalAttributeText

  !-----------------------------------------------------------------------------
  subroutine FileSetGlobalAttributeInt( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(LEN=*), intent(in) :: key
    integer,          intent(in) :: val(:)

    integer error

    intrinsic size

    call file_set_global_attribute_int( fid, & ! (in)
         key, val, size(val),                & ! (in)
         error                               ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set integer global attribute: '//trim(key))
    end if

    return
  end subroutine FileSetGlobalAttributeInt

  !-----------------------------------------------------------------------------
  subroutine FileSetGlobalAttributeFloat( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(LEN=*), intent(in) :: key
    real(SP),          intent(in) :: val(:)

    integer error

    intrinsic size

    call file_set_global_attribute_float( fid, & ! (in)
         key, val, size(val),                & ! (in)
         error                               ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set float global attribute: '//trim(key))
    end if

    return
  end subroutine FileSetGlobalAttributeFloat

  !-----------------------------------------------------------------------------
  subroutine FileSetGlobalAttributeDouble( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(LEN=*), intent(in) :: key
    real(DP),          intent(in) :: val(:)

    integer error

    intrinsic size

    call file_set_global_attribute_double( fid, & ! (in)
         key, val, size(val),                & ! (in)
         error                               ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set double global attribute: '//trim(key))
    end if

    return
  end subroutine FileSetGlobalAttributeDouble

  !-----------------------------------------------------------------------------
  subroutine FileSetOption( &
       fid,      & ! (in)
       filetype, & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(LEN=*), intent(in) :: filetype
    character(LEN=*), intent(in) :: key
    character(LEN=*), intent(in) :: val

    integer error

    call file_set_option( fid,                & ! (in)
                          filetype, key, val, & ! (in)
                          error               ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set option')
    end if

    return
  end subroutine FileSetOption

  !-----------------------------------------------------------------------------
  subroutine FileOpen( &
      fid,       & ! (out)
      basename,  & ! (in)
      mode,      & ! (in)
      single     & ! (in) optional
      )
    implicit none

    integer,          intent(out) :: fid
    character(LEN=*), intent( in) :: basename
    integer,          intent( in) :: mode
    logical,          intent( in), optional :: single

    logical :: existed
    logical :: single_ = .false.

    if ( present(single) ) single_ = single

    call FileGetfid( fid,        & ! (out)
         existed,                & ! (out)
         basename, mode, single_ ) ! (in)

    return
  end subroutine FileOpen

  !-----------------------------------------------------------------------------
  ! interface FilePutAxis
  !-----------------------------------------------------------------------------
  subroutine FilePutAxisRealSP( &
       fid,      & ! (in)
       name,     & ! (in)
       desc,     & ! (in)
       units,    & ! (in)
       dim_name, & ! (in)
       dtype,    & ! (in)
       val       ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_name
    integer,          intent(in) :: dtype
    real(SP),         intent(in) :: val(:)

    integer error
    intrinsic size

    call file_put_axis( fid,                                          & ! (in)
         name, desc, units, dim_name, dtype, val, size(val), SP, & ! (in)
         error                                                   ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put axis')
    end if

    return
  end subroutine FilePutAxisRealSP
  subroutine FilePutAxisRealDP( &
       fid,      & ! (in)
       name,     & ! (in)
       desc,     & ! (in)
       units,    & ! (in)
       dim_name, & ! (in)
       dtype,    & ! (in)
       val       ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_name
    integer,          intent(in) :: dtype
    real(DP),         intent(in) :: val(:)

    integer error
    intrinsic size

    call file_put_axis( fid,                                          & ! (in)
         name, desc, units, dim_name, dtype, val, size(val), DP, & ! (in)
         error                                                   ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put axis')
    end if

    return
  end subroutine FilePutAxisRealDP

  subroutine FileDefAxis( &
       fid,      & ! (in)
       name,     & ! (in)
       desc,     & ! (in)
       units,    & ! (in)
       dim_name, & ! (in)
       dtype,    & ! (in)
       dim_size  ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_name
    integer,          intent(in) :: dtype
    integer,          intent(in) :: dim_size

    integer error
    intrinsic size

    call file_def_axis( fid, name, desc, units, dim_name, dtype, dim_size, & ! (in)
         error                                                             ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put axis')
    end if

    return
  end subroutine FileDefAxis

  !-----------------------------------------------------------------------------
  ! interface FileWriteAxis
  !-----------------------------------------------------------------------------
  subroutine FileWriteAxisRealSP( &
       fid,      & ! (in)
       name,     & ! (in)
       val       ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    real(SP),    intent(in) :: val(:)

    integer error
    intrinsic size

    call file_write_axis( fid, name, val, SP, & ! (in)
         error                                   ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to put axis')
    end if

    return
  end subroutine FileWriteAxisRealSP
  subroutine FileWriteAxisRealDP( &
       fid,      & ! (in)
       name,     & ! (in)
       val       ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    real(DP),    intent(in) :: val(:)

    integer error
    intrinsic size

    call file_write_axis( fid, name, val, DP, & ! (in)
         error                                   ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to put axis')
    end if

    return
  end subroutine FileWriteAxisRealDP

  !-----------------------------------------------------------------------------
  ! interface FilePutAssociatedCoordinates
  !-----------------------------------------------------------------------------
  subroutine FilePut1DAssociatedCoordinatesRealSP( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(SP),         intent(in) :: val(:)

    integer error
    intrinsic size

    call file_put_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, SP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FilePut1DAssociatedCoordinatesRealSP
  subroutine FilePut1DAssociatedCoordinatesRealDP( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(DP),         intent(in) :: val(:)

    integer error
    intrinsic size

    call file_put_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, DP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FilePut1DAssociatedCoordinatesRealDP
  subroutine FilePut2DAssociatedCoordinatesRealSP( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(SP),         intent(in) :: val(:,:)

    integer error
    intrinsic size

    call file_put_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, SP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FilePut2DAssociatedCoordinatesRealSP
  subroutine FilePut2DAssociatedCoordinatesRealDP( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(DP),         intent(in) :: val(:,:)

    integer error
    intrinsic size

    call file_put_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, DP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FilePut2DAssociatedCoordinatesRealDP
  subroutine FilePut3DAssociatedCoordinatesRealSP( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(SP),         intent(in) :: val(:,:,:)

    integer error
    intrinsic size

    call file_put_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, SP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FilePut3DAssociatedCoordinatesRealSP
  subroutine FilePut3DAssociatedCoordinatesRealDP( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(DP),         intent(in) :: val(:,:,:)

    integer error
    intrinsic size

    call file_put_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, DP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FilePut3DAssociatedCoordinatesRealDP
  subroutine FilePut4DAssociatedCoordinatesRealSP( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(SP),         intent(in) :: val(:,:,:,:)

    integer error
    intrinsic size

    call file_put_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, SP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FilePut4DAssociatedCoordinatesRealSP
  subroutine FilePut4DAssociatedCoordinatesRealDP( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(DP),         intent(in) :: val(:,:,:,:)

    integer error
    intrinsic size

    call file_put_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, DP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FilePut4DAssociatedCoordinatesRealDP

  subroutine FileDefAssociatedCoordinates( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype      ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype

    integer error
    intrinsic size

    call file_def_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FileDefAssociatedCoordinates

  !-----------------------------------------------------------------------------
  ! interface FileWriteAssociatedCoordinates
  !-----------------------------------------------------------------------------
  subroutine FileWrite1DAssociatedCoordinatesRealSP( &
       fid,       & ! (in)
       name,      & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    real(SP),    intent(in) :: val(:)

    integer error
    intrinsic size

    call file_write_associated_coordinates( fid, name, val, SP, & ! (in)
         error                                                     ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FileWrite1DAssociatedCoordinatesRealSP
  subroutine FileWrite1DAssociatedCoordinatesRealDP( &
       fid,       & ! (in)
       name,      & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    real(DP),    intent(in) :: val(:)

    integer error
    intrinsic size

    call file_write_associated_coordinates( fid, name, val, DP, & ! (in)
         error                                                     ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FileWrite1DAssociatedCoordinatesRealDP
  subroutine FileWrite2DAssociatedCoordinatesRealSP( &
       fid,       & ! (in)
       name,      & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    real(SP),    intent(in) :: val(:,:)

    integer error
    intrinsic size

    call file_write_associated_coordinates( fid, name, val, SP, & ! (in)
         error                                                     ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FileWrite2DAssociatedCoordinatesRealSP
  subroutine FileWrite2DAssociatedCoordinatesRealDP( &
       fid,       & ! (in)
       name,      & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    real(DP),    intent(in) :: val(:,:)

    integer error
    intrinsic size

    call file_write_associated_coordinates( fid, name, val, DP, & ! (in)
         error                                                     ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FileWrite2DAssociatedCoordinatesRealDP
  subroutine FileWrite3DAssociatedCoordinatesRealSP( &
       fid,       & ! (in)
       name,      & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    real(SP),    intent(in) :: val(:,:,:)

    integer error
    intrinsic size

    call file_write_associated_coordinates( fid, name, val, SP, & ! (in)
         error                                                     ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FileWrite3DAssociatedCoordinatesRealSP
  subroutine FileWrite3DAssociatedCoordinatesRealDP( &
       fid,       & ! (in)
       name,      & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    real(DP),    intent(in) :: val(:,:,:)

    integer error
    intrinsic size

    call file_write_associated_coordinates( fid, name, val, DP, & ! (in)
         error                                                     ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FileWrite3DAssociatedCoordinatesRealDP
  subroutine FileWrite4DAssociatedCoordinatesRealSP( &
       fid,       & ! (in)
       name,      & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    real(SP),    intent(in) :: val(:,:,:,:)

    integer error
    intrinsic size

    call file_write_associated_coordinates( fid, name, val, SP, & ! (in)
         error                                                     ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FileWrite4DAssociatedCoordinatesRealSP
  subroutine FileWrite4DAssociatedCoordinatesRealDP( &
       fid,       & ! (in)
       name,      & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    real(DP),    intent(in) :: val(:,:,:,:)

    integer error
    intrinsic size

    call file_write_associated_coordinates( fid, name, val, DP, & ! (in)
         error                                                     ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FileWrite4DAssociatedCoordinatesRealDP

  !-----------------------------------------------------------------------------
  ! interface FileAddVariable
  !-----------------------------------------------------------------------------
  subroutine FileAddVariableNoT( &
       vid,     & ! (out)
       fid,     & ! (in)
       varname, & ! (in)
       desc,    & ! (in)
       units,   & ! (in)
       dims,    & ! (in)
       dtype,   & ! (in)
       tavg     & ! (in) optional
       )
    integer,          intent(out) :: vid
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    logical,          intent( in), optional :: tavg

    call FileAddVariableRealDP(vid, fid, varname, desc, units, dims, dtype, &
         -1.0_DP, tavg )

    return
  end subroutine FileAddVariableNoT
  subroutine FileAddVariableRealSP( &
       vid,     & ! (out)
       fid,     & ! (in)
       varname, & ! (in)
       desc,    & ! (in)
       units,   & ! (in)
       dims,    & ! (in)
       dtype,   & ! (in)
       tint,    & ! (in)
       tavg     & ! (in) optional
       )
    integer,          intent(out) :: vid
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    real(SP),         intent( in) :: tint
    logical,          intent( in), optional :: tavg

    real(DP) :: tint8
    integer  :: itavg
    integer  :: error
    integer  :: n

    intrinsic size
    !---------------------------------------------------------------------------

    vid = -1
    do n = 1, File_vid_count
       if ( File_vid_fid_list(n) == fid .and. &
            varname == File_vname_list(n) ) then
          vid = File_vid_list(n)
       end if
    enddo

    if ( vid < 0 ) then ! variable registration
       !--- register new variable
       write(message,*) '*** [File] Var registration'
       call Log("I", message)
       write(message,*) '*** variable name: ', trim(varname)
       call Log("I", message)

       tint8 = real(tint,DP)

       if ( present(tavg) ) then
          if ( tavg ) then
             itavg = 1
          else
             itavg = 0
          end if
       else
          itavg = 0
       end if

       call file_add_variable( vid,                             & ! (out)
            fid, varname, desc, units, dims, size(dims), dtype, & ! (in)
            tint8, itavg,                                       & ! (in)
            error                                               ) ! (out)
       if ( error /= SUCCESS_CODE ) then
          call Log('E', 'xxx failed to add variable: '//trim(varname))
       end if

       File_vname_list  (File_vid_count) = trim(varname)
       File_vid_list    (File_vid_count) = vid
       File_vid_fid_list(File_vid_count) = fid
       File_vid_count                    = File_vid_count + 1
    endif

    return
  end subroutine FileAddVariableRealSP
  subroutine FileAddVariableRealDP( &
       vid,     & ! (out)
       fid,     & ! (in)
       varname, & ! (in)
       desc,    & ! (in)
       units,   & ! (in)
       dims,    & ! (in)
       dtype,   & ! (in)
       tint,    & ! (in)
       tavg     & ! (in) optional
       )
    integer,          intent(out) :: vid
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    real(DP),         intent( in) :: tint
    logical,          intent( in), optional :: tavg

    real(DP) :: tint8
    integer  :: itavg
    integer  :: error
    integer  :: n

    intrinsic size
    !---------------------------------------------------------------------------

    vid = -1
    do n = 1, File_vid_count
       if ( File_vid_fid_list(n) == fid .and. &
            varname == File_vname_list(n) ) then
          vid = File_vid_list(n)
       end if
    enddo

    if ( vid < 0 ) then ! variable registration
       !--- register new variable
       write(message,*) '*** [File] Var registration'
       call Log("I", message)
       write(message,*) '*** variable name: ', trim(varname)
       call Log("I", message)

       tint8 = real(tint,DP)

       if ( present(tavg) ) then
          if ( tavg ) then
             itavg = 1
          else
             itavg = 0
          end if
       else
          itavg = 0
       end if

       call file_add_variable( vid,                             & ! (out)
            fid, varname, desc, units, dims, size(dims), dtype, & ! (in)
            tint8, itavg,                                       & ! (in)
            error                                               ) ! (out)
       if ( error /= SUCCESS_CODE ) then
          call Log('E', 'xxx failed to add variable: '//trim(varname))
       end if

       File_vname_list  (File_vid_count) = trim(varname)
       File_vid_list    (File_vid_count) = vid
       File_vid_fid_list(File_vid_count) = fid
       File_vid_count                    = File_vid_count + 1
    endif

    return
  end subroutine FileAddVariableRealDP

  subroutine FileDefineVariable( &
       fid,     & ! (in)
       vid,     & ! (out)
       varname, & ! (in)
       desc,    & ! (in)
       units,   & ! (in)
       ndims,   & ! (in)
       dims,    & ! (in)
       dtype,   & ! (in)
       tint,    & ! (in) optional
       tavg     & ! (in) optional
       )
    integer,          intent(out) :: vid
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    integer,          intent( in) :: ndims
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    real(DP),         intent( in), optional :: tint
    logical,          intent( in), optional :: tavg

    real(DP) :: tint_
    integer  :: itavg
    integer  :: error
    integer  :: n

    intrinsic size
    !---------------------------------------------------------------------------

    vid = -1
    do n = 1, File_vid_count
       if ( File_vid_fid_list(n) == fid .and. &
            varname == File_vname_list(n) ) then
          vid = File_vid_list(n)
       end if
    enddo

    if ( vid < 0 ) then ! variable registration
       !--- register new variable
       write(message,*) '*** [File] Var registration'
       call Log("I", message)
       write(message,*) '*** variable name: ', trim(varname)
       call Log("I", message)

       if ( .NOT. present(tint) ) then
          tint_ = -1.0_DP
       endif

       if ( present(tavg) ) then
          if ( tavg ) then
             itavg = 1
          else
             itavg = 0
          end if
       else
          itavg = 0
       end if

       call file_add_variable( vid,                        & ! (out)
            fid, varname, desc, units, dims, ndims, dtype, & ! (in)
            tint_, itavg,                                  & ! (in)
            error                                          ) ! (out)
       if ( error /= SUCCESS_CODE ) then
          call Log('E', 'xxx failed to add variable: '//trim(varname))
       end if

       File_vname_list  (File_vid_count) = trim(varname)
       File_vid_list    (File_vid_count) = vid
       File_vid_fid_list(File_vid_count) = fid
       File_vid_count                    = File_vid_count + 1
    endif

    return
  end subroutine FileDefineVariable

  !-----------------------------------------------------------------------------
  ! FileSetTAttr
  !-----------------------------------------------------------------------------
  subroutine FileSetTAttr( &
     fid,   & ! (in)
     vname, & ! (in)
     key,   & ! (in)
     val    & ! (in)
     )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer :: error

    call file_set_tattr( &
         fid, vname, & ! (in)
         key, val,   & ! (in)
         error       ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put axis')
    end if

    return
  end subroutine FileSetTAttr

  !-----------------------------------------------------------------------------
  ! FileGetShape
  !-----------------------------------------------------------------------------
  subroutine FileGetShape( &
      dims,          & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      myrank,        & ! (in)
      single         & ! (in) optional
      )
    implicit none

    integer,          intent(out)           :: dims(:)
    character(LEN=*), intent( in)           :: basename
    character(LEN=*), intent( in)           :: varname
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: error
    integer :: n

    logical :: single_ = .false.

    intrinsic size
    intrinsic shape
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo, & ! (out)
         fid, varname, 1, .false., & ! (in)
         error                     ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data information :'//trim(varname))
    end if

    if ( dinfo%rank /= size(dims) ) then
       write(message,*) 'xxx rank is different, ', size(dims), dinfo%rank
       call Log('E', message)
    end if
    do n = 1, size(dims)
       dims(n) = dinfo%dim_size(n)
    end do

    return
  end subroutine FileGetShape

  !-----------------------------------------------------------------------------
  ! FileGetData
  !-----------------------------------------------------------------------------
  subroutine FileGetDatainfo( &
      basename,    &
      varname,     &
      myrank,      &
      istep,       &
      single,      &
      description, &
      units,       &
      datatype,    &
      dim_rank,    &
      dim_name,    &
      dim_size,    &
      time_start,  &
      time_end,    &
      time_units   )
    implicit none
    character(len=*),           intent(in)  :: basename
    character(len=*),           intent(in)  :: varname
    integer,                    intent(in)  :: myrank
    integer,                    intent(in)  :: istep
    logical,                    intent(in), optional :: single

    character(len=File_HMID),   intent(out), optional :: description
    character(len=File_HSHORT), intent(out), optional :: units
    integer,                    intent(out), optional :: datatype
    integer,                    intent(out), optional :: dim_rank
    character(len=File_HSHORT), intent(out), optional :: dim_name(:)
    integer,                    intent(out), optional :: dim_size(:)
    real(DP),                   intent(out), optional :: time_start
    real(DP),                   intent(out), optional :: time_end
    character(len=File_HMID),   intent(out), optional :: time_units

    integer        :: fid
    type(datainfo) :: dinfo

    integer :: ndim, idim
    real(DP):: time(1)

    integer :: error
    logical :: single_ = .false.

    intrinsic size
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,        & ! [OUT]
                   basename,   & ! [IN]
                   File_FREAD, & ! [IN]
                   single_     ) ! [IN]

    !--- get data information
    call file_get_datainfo( dinfo,   & ! [OUT]
                            fid,     & ! [IN]
                            varname, & ! [IN]
                            istep,   & ! [IN]
                            .false., & ! [IN]
                            error    ) ! [OUT]

    !--- verify and exit
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx data info not found in '//trim(basename))
    endif

    if ( present(description) ) description = dinfo%description
    if ( present(units)       ) units       = dinfo%units
    if ( present(datatype)    ) datatype    = dinfo%datatype
    if ( present(dim_rank)    ) dim_rank    = dinfo%rank

    if ( present(dim_name) ) then
       ndim = min( dinfo%rank, size(dim_name) ) ! limit dimension rank
       do idim = 1, ndim
          dim_name(idim) = dinfo%dim_name(idim)
       enddo
    end if
    if ( present(dim_size) ) then
       ndim = min( dinfo%rank, size(dim_size) ) ! limit dimension rank
       do idim = 1, ndim
          dim_size(idim) = dinfo%dim_size(idim)
       enddo
    end if

    if ( present(time_units)  ) then
       if ( dinfo%time_units == "" ) then
          call FileGetGlobalAttribute( fid, "time_units", time_units )
       else
          time_units  = dinfo%time_units
       end if
    end if
    if ( present(time_start)  ) then
       if ( dinfo%time_units == "" ) then
          call FileGetGlobalAttribute( fid, "time", time )
          time_start = time(1)
       else
          time_start  = dinfo%time_start
       end if
    end if
    if ( present(time_end)  ) then
       if ( dinfo%time_units == "" ) then
          call FileGetGlobalAttribute( fid, "time", time )
          time_end = time(1)
       else
          time_end  = dinfo%time_end
       end if
    end if

    return
  end subroutine FileGetDatainfo

  !-----------------------------------------------------------------------------
  ! FileGetData
  !-----------------------------------------------------------------------------
  subroutine FileGetAllDatainfo( &
      step_limit,  &
      dim_limit,   &
      basename,    &
      varname,     &
      myrank,      &
      step_nmax,   &
      description, &
      units,       &
      datatype,    &
      dim_rank,    &
      dim_name,    &
      dim_size,    &
      time_start,  &
      time_end,    &
      time_units,  &
      single       )
    implicit none

    integer,                    intent(in)  :: step_limit
    integer,                    intent(in)  :: dim_limit
    character(len=*),           intent(in)  :: basename
    character(len=*),           intent(in)  :: varname
    integer,                    intent(in)  :: myrank
    integer,                    intent(out) :: step_nmax
    character(len=File_HMID),   intent(out) :: description
    character(len=File_HSHORT), intent(out) :: units
    integer,                    intent(out) :: datatype
    integer,                    intent(out) :: dim_rank
    character(len=File_HSHORT), intent(out) :: dim_name  (dim_limit)
    integer,                    intent(out) :: dim_size  (dim_limit)
    real(DP),                   intent(out) :: time_start(step_limit)
    real(DP),                   intent(out) :: time_end  (step_limit)
    character(len=File_HMID),   intent(out) :: time_units

    logical,                    intent(in), optional :: single

    integer        :: fid
    type(datainfo) :: dinfo

    integer :: ndim
    integer :: istep, idim
    logical :: flag_first = .true.

    integer :: error
    logical :: single_ = .false.
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,        & ! [OUT]
                   basename,   & ! [IN]
                   File_FREAD, & ! [IN]
                   single_     ) ! [IN]

    ! initialize
    description   = ""
    units         = ""
    datatype      = -1
    dim_rank      = -1
    dim_name  (:) = ""
    dim_size  (:) = -1
    time_start(:) = RMISS
    time_end  (:) = RMISS

    do istep = 1, step_limit
       !--- get data information
       call file_get_datainfo( dinfo,   & ! [OUT]
                               fid,     & ! [IN]
                               varname, & ! [IN]
                               istep,   & ! [IN]
                               .true.,  & ! [IN]
                               error    ) ! [OUT]

       !--- verify and exit
       if ( error /= SUCCESS_CODE ) then
          step_nmax = istep - 1
          exit
       endif

       if ( flag_first ) then
          flag_first = .false.

          description = dinfo%description
          units       = dinfo%units
          datatype    = dinfo%datatype
          dim_rank    = dinfo%rank

          ndim = min( dinfo%rank, dim_limit ) ! limit dimension rank
          do idim = 1, ndim
             dim_name(idim) = dinfo%dim_name(idim)
             dim_size(idim) = dinfo%dim_size(idim)
          enddo

          time_units        = dinfo%time_units
       endif

       time_start(istep) = dinfo%time_start
       time_end  (istep) = dinfo%time_end
    enddo

    return
  end subroutine FileGetAllDatainfo

  !-----------------------------------------------------------------------------
  ! interface File_read
  !-----------------------------------------------------------------------------
  subroutine FileRead1DRealSP( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(SP),         intent(out)           :: var(:)
    character(LEN=*), intent( in)           :: basename
    character(LEN=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(1)
    integer :: error
    integer :: n

    logical :: single_ = .false.

    intrinsic shape
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 1 ) then
       write(message,*) 'xxx rank is not 1', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 1
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data( var(:), & ! (out)
         dinfo, SP,                  & ! (in)
         error                       ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileRead1DRealSP
  subroutine FileRead1DRealDP( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(DP),         intent(out)           :: var(:)
    character(LEN=*), intent( in)           :: basename
    character(LEN=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(1)
    integer :: error
    integer :: n

    logical :: single_ = .false.

    intrinsic shape
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 1 ) then
       write(message,*) 'xxx rank is not 1', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 1
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data( var(:), & ! (out)
         dinfo, DP,                  & ! (in)
         error                       ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileRead1DRealDP
  subroutine FileRead2DRealSP( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(SP),         intent(out)           :: var(:,:)
    character(LEN=*), intent( in)           :: basename
    character(LEN=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(2)
    integer :: error
    integer :: n

    logical :: single_ = .false.

    intrinsic shape
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:,:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 2 ) then
       write(message,*) 'xxx rank is not 2', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 2
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data( var(:,:), & ! (out)
         dinfo, SP,                  & ! (in)
         error                       ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileRead2DRealSP
  subroutine FileRead2DRealDP( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(DP),         intent(out)           :: var(:,:)
    character(LEN=*), intent( in)           :: basename
    character(LEN=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(2)
    integer :: error
    integer :: n

    logical :: single_ = .false.

    intrinsic shape
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:,:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 2 ) then
       write(message,*) 'xxx rank is not 2', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 2
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data( var(:,:), & ! (out)
         dinfo, DP,                  & ! (in)
         error                       ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileRead2DRealDP
  subroutine FileRead3DRealSP( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(SP),         intent(out)           :: var(:,:,:)
    character(LEN=*), intent( in)           :: basename
    character(LEN=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(3)
    integer :: error
    integer :: n

    logical :: single_ = .false.

    intrinsic shape
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:,:,:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 3 ) then
       write(message,*) 'xxx rank is not 3', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 3
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data( var(:,:,:), & ! (out)
         dinfo, SP,                  & ! (in)
         error                       ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileRead3DRealSP
  subroutine FileRead3DRealDP( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(DP),         intent(out)           :: var(:,:,:)
    character(LEN=*), intent( in)           :: basename
    character(LEN=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(3)
    integer :: error
    integer :: n

    logical :: single_ = .false.

    intrinsic shape
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:,:,:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 3 ) then
       write(message,*) 'xxx rank is not 3', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 3
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data( var(:,:,:), & ! (out)
         dinfo, DP,                  & ! (in)
         error                       ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileRead3DRealDP
  subroutine FileRead4DRealSP( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(SP),         intent(out)           :: var(:,:,:,:)
    character(LEN=*), intent( in)           :: basename
    character(LEN=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(4)
    integer :: error
    integer :: n

    logical :: single_ = .false.

    intrinsic shape
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:,:,:,:) = 0.0_SP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 4 ) then
       write(message,*) 'xxx rank is not 4', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 4
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data( var(:,:,:,:), & ! (out)
         dinfo, SP,                  & ! (in)
         error                       ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileRead4DRealSP
  subroutine FileRead4DRealDP( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(DP),         intent(out)           :: var(:,:,:,:)
    character(LEN=*), intent( in)           :: basename
    character(LEN=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(4)
    integer :: error
    integer :: n

    logical :: single_ = .false.

    intrinsic shape
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(:,:,:,:) = 0.0_DP
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= 4 ) then
       write(message,*) 'xxx rank is not 4', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, 4
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data( var(:,:,:,:), & ! (out)
         dinfo, DP,                  & ! (in)
         error                       ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileRead4DRealDP

  !-----------------------------------------------------------------------------
  ! interface FileWrite
  !-----------------------------------------------------------------------------
  subroutine FileWrite1DRealSP( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end    & ! (in)
      )
    implicit none

    real(SP), intent(in) :: var(:)
    integer,  intent(in) :: fid
    integer,  intent(in) :: vid
    real(DP), intent(in) :: t_start
    real(DP), intent(in) :: t_end

    real(DP) :: ts, te

    integer :: error, n
    character(len=100) :: str
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end
    call file_write_data( fid, vid, var(:), ts, te, SP, & ! (in)
         error                                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWrite1DRealSP
  subroutine FileWrite1DRealDP( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end    & ! (in)
      )
    implicit none

    real(DP), intent(in) :: var(:)
    integer,  intent(in) :: fid
    integer,  intent(in) :: vid
    real(DP), intent(in) :: t_start
    real(DP), intent(in) :: t_end

    real(DP) :: ts, te

    integer :: error, n
    character(len=100) :: str
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end
    call file_write_data( fid, vid, var(:), ts, te, DP, & ! (in)
         error                                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWrite1DRealDP
  subroutine FileWrite2DRealSP( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end    & ! (in)
      )
    implicit none

    real(SP), intent(in) :: var(:,:)
    integer,  intent(in) :: fid
    integer,  intent(in) :: vid
    real(DP), intent(in) :: t_start
    real(DP), intent(in) :: t_end

    real(DP) :: ts, te

    integer :: error, n
    character(len=100) :: str
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end
    call file_write_data( fid, vid, var(:,:), ts, te, SP, & ! (in)
         error                                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWrite2DRealSP
  subroutine FileWrite2DRealDP( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end    & ! (in)
      )
    implicit none

    real(DP), intent(in) :: var(:,:)
    integer,  intent(in) :: fid
    integer,  intent(in) :: vid
    real(DP), intent(in) :: t_start
    real(DP), intent(in) :: t_end

    real(DP) :: ts, te

    integer :: error, n
    character(len=100) :: str
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end
    call file_write_data( fid, vid, var(:,:), ts, te, DP, & ! (in)
         error                                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWrite2DRealDP
  subroutine FileWrite3DRealSP( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end    & ! (in)
      )
    implicit none

    real(SP), intent(in) :: var(:,:,:)
    integer,  intent(in) :: fid
    integer,  intent(in) :: vid
    real(DP), intent(in) :: t_start
    real(DP), intent(in) :: t_end

    real(DP) :: ts, te

    integer :: error, n
    character(len=100) :: str
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end
    call file_write_data( fid, vid, var(:,:,:), ts, te, SP, & ! (in)
         error                                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWrite3DRealSP
  subroutine FileWrite3DRealDP( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end    & ! (in)
      )
    implicit none

    real(DP), intent(in) :: var(:,:,:)
    integer,  intent(in) :: fid
    integer,  intent(in) :: vid
    real(DP), intent(in) :: t_start
    real(DP), intent(in) :: t_end

    real(DP) :: ts, te

    integer :: error, n
    character(len=100) :: str
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end
    call file_write_data( fid, vid, var(:,:,:), ts, te, DP, & ! (in)
         error                                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWrite3DRealDP
  subroutine FileWrite4DRealSP( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end    & ! (in)
      )
    implicit none

    real(SP), intent(in) :: var(:,:,:,:)
    integer,  intent(in) :: fid
    integer,  intent(in) :: vid
    real(DP), intent(in) :: t_start
    real(DP), intent(in) :: t_end

    real(DP) :: ts, te

    integer :: error, n
    character(len=100) :: str
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end
    call file_write_data( fid, vid, var(:,:,:,:), ts, te, SP, & ! (in)
         error                                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWrite4DRealSP
  subroutine FileWrite4DRealDP( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end    & ! (in)
      )
    implicit none

    real(DP), intent(in) :: var(:,:,:,:)
    integer,  intent(in) :: fid
    integer,  intent(in) :: vid
    real(DP), intent(in) :: t_start
    real(DP), intent(in) :: t_end

    real(DP) :: ts, te

    integer :: error, n
    character(len=100) :: str
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end
    call file_write_data( fid, vid, var(:,:,:,:), ts, te, DP, & ! (in)
         error                                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWrite4DRealDP

  !-----------------------------------------------------------------------------
  ! interface FileWriteVar
  !-----------------------------------------------------------------------------
  subroutine FileWriteVar1DRealSP( &
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end    & ! (in)
      )
    implicit none

    real(SP), intent(in) :: var(:)
    integer,  intent(in) :: vid
    real(DP), intent(in) :: t_start
    real(DP), intent(in) :: t_end

    real(DP) :: ts, te

    integer :: error, n
    character(len=100) :: str
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end
    call file_write_var( vid, var(:), ts, te, SP, & ! (in)
         error                                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWriteVar1DRealSP
  subroutine FileWriteVar1DRealDP( &
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end    & ! (in)
      )
    implicit none

    real(DP), intent(in) :: var(:)
    integer,  intent(in) :: vid
    real(DP), intent(in) :: t_start
    real(DP), intent(in) :: t_end

    real(DP) :: ts, te

    integer :: error, n
    character(len=100) :: str
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end
    call file_write_var( vid, var(:), ts, te, DP, & ! (in)
         error                                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWriteVar1DRealDP
  subroutine FileWriteVar2DRealSP( &
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end    & ! (in)
      )
    implicit none

    real(SP), intent(in) :: var(:,:)
    integer,  intent(in) :: vid
    real(DP), intent(in) :: t_start
    real(DP), intent(in) :: t_end

    real(DP) :: ts, te

    integer :: error, n
    character(len=100) :: str
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end
    call file_write_var( vid, var(:,:), ts, te, SP, & ! (in)
         error                                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWriteVar2DRealSP
  subroutine FileWriteVar2DRealDP( &
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end    & ! (in)
      )
    implicit none

    real(DP), intent(in) :: var(:,:)
    integer,  intent(in) :: vid
    real(DP), intent(in) :: t_start
    real(DP), intent(in) :: t_end

    real(DP) :: ts, te

    integer :: error, n
    character(len=100) :: str
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end
    call file_write_var( vid, var(:,:), ts, te, DP, & ! (in)
         error                                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWriteVar2DRealDP
  subroutine FileWriteVar3DRealSP( &
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end    & ! (in)
      )
    implicit none

    real(SP), intent(in) :: var(:,:,:)
    integer,  intent(in) :: vid
    real(DP), intent(in) :: t_start
    real(DP), intent(in) :: t_end

    real(DP) :: ts, te

    integer :: error, n
    character(len=100) :: str
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end
    call file_write_var( vid, var(:,:,:), ts, te, SP, & ! (in)
         error                                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWriteVar3DRealSP
  subroutine FileWriteVar3DRealDP( &
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end    & ! (in)
      )
    implicit none

    real(DP), intent(in) :: var(:,:,:)
    integer,  intent(in) :: vid
    real(DP), intent(in) :: t_start
    real(DP), intent(in) :: t_end

    real(DP) :: ts, te

    integer :: error, n
    character(len=100) :: str
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end
    call file_write_var( vid, var(:,:,:), ts, te, DP, & ! (in)
         error                                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWriteVar3DRealDP
  subroutine FileWriteVar4DRealSP( &
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end    & ! (in)
      )
    implicit none

    real(SP), intent(in) :: var(:,:,:,:)
    integer,  intent(in) :: vid
    real(DP), intent(in) :: t_start
    real(DP), intent(in) :: t_end

    real(DP) :: ts, te

    integer :: error, n
    character(len=100) :: str
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end
    call file_write_var( vid, var(:,:,:,:), ts, te, SP, & ! (in)
         error                                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWriteVar4DRealSP
  subroutine FileWriteVar4DRealDP( &
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end    & ! (in)
      )
    implicit none

    real(DP), intent(in) :: var(:,:,:,:)
    integer,  intent(in) :: vid
    real(DP), intent(in) :: t_start
    real(DP), intent(in) :: t_end

    real(DP) :: ts, te

    integer :: error, n
    character(len=100) :: str
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end
    call file_write_var( vid, var(:,:,:,:), ts, te, DP, & ! (in)
         error                                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWriteVar4DRealDP

  !-----------------------------------------------------------------------------
  subroutine FileEndDef( &
       fid & ! (in)
       )
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) exit
    end do
    if ( fid .NE. File_fid_list(n) ) then
       write(message,*) 'xxx in FileEndDef invalid fid' , fid
       call Log('E', message)
    end if
    call file_enddef( fid , & ! (in)
         error             ) ! (out)
    if ( error .EQ. SUCCESS_CODE ) then
       write(message, '(1x,A,i3)') '*** [File] File enddef : NO.', n
       call Log('I', message)
       call Log('I', '*** enddef filename: ' // trim(File_fname_list(n)))
    else
       call Log('E', 'xxx failed to exit define mode')
    end if

    return
  end subroutine FileEndDef

  !-----------------------------------------------------------------------------
  subroutine FileClose( &
       fid & ! (in)
       )
    implicit none

    integer, intent(in) :: fid

    character(LEN=File_HLONG) :: fname
    integer                   :: error
    integer                   :: n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) exit
    end do
    if ( n .EQ. File_fid_count ) return  ! already closed

    if ( fid /= File_fid_list(n) ) then
       write(message,*) 'xxx in FileClose invalid fid ', fid
       call Log('E', message)
    end if
    call file_close( fid , & ! (in)
         error             ) ! (out)
    if ( error == SUCCESS_CODE ) then
       write(message, '(1x,A,i3)') '*** [File] File Close : NO.', n
       call Log('I', message)
       call Log('I', '*** closed filename: ' // trim(File_fname_list(n)))
    else if ( error /= ALREADY_CLOSED_CODE ) then
       call Log('E', 'xxx failed to close file')
    end if

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) then
          File_fid_list(n) = -1
          File_fname_list(n) = ''
       end if
    end do

    return
  end subroutine FileClose
  !-----------------------------------------------------------------------------
  subroutine FileCloseAll
    implicit none

    integer n
    !---------------------------------------------------------------------------

    do n = 1, File_fid_count-1
       call FileClose( File_fid_list(n) )
    enddo

    return
  end subroutine FileCloseAll

  !-----------------------------------------------------------------------------
  ! private
  !-----------------------------------------------------------------------------
  subroutine FileMakeFname( &
       fname,    & ! (out)
       basename, & ! (in)
       prefix,   & ! (in)
       myrank,   & ! (in)
       len       ) ! (in)
    character(len=*), intent(out) :: fname
    character(len=*), intent( in) :: basename
    character(len=*), intent( in) :: prefix
    integer,          intent( in) :: myrank
    integer,          intent( in) :: len

    !                           12345678901234567
    character(len=17) :: fmt = "(A, '.', A, I*.*)"
    !---------------------------------------------------------------------------

    if ( len < 1 .or. len > 9 ) then
       call Log('E', 'xxx len is invalid')
    end if

    write(fmt(14:14),'(I1)') len
    write(fmt(16:16),'(I1)') len
    write(fname, fmt) trim(basename), trim(prefix), myrank

    return
  end subroutine FileMakeFname
  !-----------------------------------------------------------------------------
  subroutine FileGetfid( &
      fid,        &
      existed,    &
      basename,   &
      mode,       &
      single      )
    implicit none

    integer,          intent(out) :: fid
    logical,          intent(out) :: existed
    character(LEN=*), intent( in) :: basename
    integer,          intent( in) :: mode
    logical,          intent( in) :: single


    character(LEN=File_HSHORT) :: rwname(0:2)
    data rwname / 'READ','WRITE','APPEND' /

    character(LEN=File_HLONG) :: fname
    integer                  :: n

    integer :: error
    !---------------------------------------------------------------------------

    !--- register new file and open
    if ( single ) then
       fname = trim(basename)//'.peall'
    else
       call FileMakeFname(fname,trim(basename),'pe',mpi_myrank,6)
    endif

    !--- search existing file
    fid = -1
    do n = 1, File_fid_count-1
       if ( fname==File_fname_list(n) ) fid = File_fid_list(n)
    enddo

    if ( fid >= 0 ) then
       existed = .true.
       return
    end if

    call file_open( fid, & ! (out)
         fname, mode,    & ! (in)
         error           ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to open file :'//trim(fname)//'.nc')
    end if

    write(message,*) '*** [File] File registration : ',trim(rwname(mode)),' -', fid
    call Log("I", message)
    write(message,*) '*** filename: ', trim(fname)
    call Log("I", message)

    File_fname_list(File_fid_count) = trim(fname)
    File_fid_list  (File_fid_count) = fid
    File_fid_count                  = File_fid_count + 1

    existed = .false.

    return
  end subroutine FileGetfid

end module gtool_file
!-------------------------------------------------------------------------------


!--
! vi:set readonly sw=4 ts=8
!
!Local Variables:
!mode: f90
!buffer-read-only: t
!End:
!
!++
