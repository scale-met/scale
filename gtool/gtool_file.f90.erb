% # -*- f90 -*-
% # vi: set sw=4 ts=8:
!-------------------------------------------------------------------------------
!> module GTOOL_FILE
!!
!! @par Description
!!          unified hundring of various kinds of files
!!
!! @author Team SCALE
!!
!! @par History
!! @li      2012-06-12 (S.Nishizawa) [new] Imported from SCALE-LES
!!
!<
!-------------------------------------------------------------------------------
! Warning: This file was generated from <%=__FILE__%>.
!          Do not edit this file.
!-------------------------------------------------------------------------------
module gtool_file
  !-----------------------------------------------------------------------------
  !
  !++ Used modules
  !
  use gtool_file_h
  use dc_log, only: &
       Log, &
       LOG_LMSG
  use dc_types, only: &
       DP, &
       SP
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedures
  !
  public :: FileOpen
  public :: FileCreate
  public :: FileSetOption
  public :: FileDefAxis
  public :: FilePutAxis
  public :: FileWriteAxis
  public :: FileDefAssociatedCoordinates
  public :: FilePutAssociatedCoordinates
  public :: FileWriteAssociatedCoordinates
  public :: FileAddVariable
  public :: FileDefineVariable
  public :: FileSetTAttr
  public :: FileGetShape
  public :: FileGetDatainfo
  public :: FileGetAllDatainfo
  public :: FileRead
  public :: FileWrite
  public :: FileGetGlobalAttribute
  public :: FileSetGlobalAttribute
  public :: FileEndDef
  public :: FileFlush
  public :: FileClose
  public :: FileCloseAll
  public :: FileMakeFname
  public :: FileAttachBuffer
  public :: FileDetachBuffer

  interface FilePutAxis
     module procedure FilePutAxisRealSP
     module procedure FilePutAxisRealDP
  end interface FilePutAxis
  interface FileWriteAxis
     module procedure FileWriteAxisRealSP
     module procedure FileWriteAxisRealDP
  end interface FileWriteAxis
  interface FilePutAssociatedCoordinates
% for n in 1..4
%   %w(SP DP).each do |rp|
    module procedure FilePut<%=n%>DAssociatedCoordinatesReal<%=rp%>
%   end
% end
  end interface FilePutAssociatedCoordinates
  interface FileWriteAssociatedCoordinates
% for n in 1..4
%   %w(SP DP).each do |rp|
    module procedure FileWrite<%=n%>DAssociatedCoordinatesReal<%=rp%>
%   end
% end
  end interface FileWriteAssociatedCoordinates
  interface FileAddVariable
     module procedure FileAddVariableNoT
     module procedure FileAddVariableRealSP
     module procedure FileAddVariableRealDP
  end interface FileAddVariable
  interface FileRead
% for n in 1..4
%   %w(SP DP).each do |rp|
    module procedure FileRead<%=n%>DReal<%=rp%>
%   end
% end
% for n in 1..4
%   %w(SP DP).each do |rp|
    module procedure FileReadVar<%=n%>DReal<%=rp%>
%   end
% end
  end interface FileRead
  interface FileWrite
% for n in 1..4
%   %w(SP DP).each do |rp|
    module procedure FileWrite<%=n%>DReal<%=rp%>
%   end
% end
  end interface FileWrite
  interface FileGetGlobalAttribute
     module procedure FileGetGlobalAttributeText
     module procedure FileGetGlobalAttributeInt
     module procedure FileGetGlobalAttributeFloat
     module procedure FileGetGlobalAttributeDouble
  end interface FileGetGlobalAttribute
  interface FileSetGlobalAttribute
     module procedure FileSetGlobalAttributeText
     module procedure FileSetGlobalAttributeInt
     module procedure FileSetGlobalAttributeFloat
     module procedure FileSetGlobalAttributeDouble
  end interface FileSetGlobalAttribute

  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  real(DP), parameter, public :: RMISS = -9.9999e+30
  !-----------------------------------------------------------------------------
  !
  !++ Private procedures
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private parameters & variables
  !
  integer,                   private, parameter :: File_nfile_max = 512   ! number limit of file
                                                 ! Keep consistency with "FILE_MAX" in gtool_netcdf.c
  integer,                   private, parameter :: File_nvar_max  = 40960 ! number limit of variables
                                                 ! Keep consistency with "VAR_MAX" in gtool_netcdf.c

  character(LEN=File_HLONG), private,      save :: File_fname_list(File_nfile_max)
  integer,                   private,      save :: File_fid_list  (File_nfile_max)
  integer,                   private,      save :: File_fid_count = 1
  character(LEN=File_HLONG), private,      save :: File_vname_list  (File_nvar_max)
  integer,                   private,      save :: File_vid_fid_list(File_nvar_max)
  integer,                   private,      save :: File_vid_list    (File_nvar_max)
  integer,                   private,      save :: File_vid_count = 1
  integer,                   private,      save :: mpi_myrank

  character(LEN=LOG_LMSG),   private            :: message

contains
  !-----------------------------------------------------------------------------
  subroutine FileCreate( &
       fid,         & ! (out)
       existed,     & ! (out)
       basename,    & ! (in)
       title,       & ! (in)
       source,      & ! (in)
       institution, & ! (in)
       master,      & ! (in)
       myrank,      & ! (in)
       rankidx,     & ! (in)
       single,      & ! (in) optional
       time_units,  & ! (in) optional
       append,      & ! (in) optional
       comm         ) ! (in) optional
    use MPI, only : MPI_COMM_NULL
    implicit none

    integer,          intent(out)           :: fid
    logical,          intent(out)           :: existed
    character(LEN=*), intent( in)           :: basename
    character(LEN=*), intent( in)           :: title
    character(LEN=*), intent( in)           :: source
    character(LEN=*), intent( in)           :: institution
    integer,          intent( in)           :: master
    integer,          intent( in)           :: myrank
    integer,          intent( in)           :: rankidx(:)
    character(LEN=*), intent( in), optional :: time_units
    logical,          intent( in), optional :: single
    logical,          intent( in), optional :: append
    integer,          intent( in), optional :: comm ! MPI communicator

    character(len=File_HMID) :: time_units_
    logical :: single_
    integer :: mode
    integer :: error

    intrinsic size

    if ( present(time_units) ) then
       time_units_ = time_units
    else
       time_units_ = 'seconds'
    end if

    mpi_myrank = myrank

    if ( present(single) ) then
       if ( single .and. (myrank .ne. master) ) return
       single_ = single
    else
       single_ = .false.
    endif

    mode = File_FWRITE
    if ( present(append) ) then
       if ( append ) mode = File_FAPPEND
    end if

    call FileGetfid( &
         fid,        & ! (out)
         existed,    & ! (out)
         basename,   & ! (in)
         mode,       & ! (in)
         single_,    & ! (in)
         comm        & ! (in)
         )

    if ( existed ) return

    !--- append package header to the file
    call FileSetGlobalAttribute( fid, & ! (in)
         "title", title               ) ! (in)
    call FileSetGlobalAttribute( fid, & ! (in)
         "source", source             ) ! (in)
    call FileSetGlobalAttribute( fid, & ! (in)
         "institution", institution   ) ! (in)

    if ( .NOT. present(comm) .OR. comm .EQ. MPI_COMM_NULL ) then
       ! for shared-file parallel I/O, skip attributes related to MPI processes
       call FileSetGlobalAttribute( fid, & ! (in)
            "myrank", (/myrank/)         ) ! (in)
       call FileSetGlobalAttribute( fid, & ! (in)
            "rankidx", rankidx           ) ! (in)
    end if

    call file_set_tunits( fid, & ! (in)
         time_units_,          & ! (in)
         error                 ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set time units')
    end if

    return
  end subroutine FileCreate

  !-----------------------------------------------------------------------------
  subroutine FileGetGlobalAttributeText( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (out)
       )
    integer,          intent(in) :: fid
    character(LEN=*), intent(in) :: key
    character(LEN=*), intent(out) :: val

    integer error

    intrinsic size

    call file_get_global_attribute_text( & ! (in)
         fid, key,                       & ! (in)
         val, error                      ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get text global attribute: '//trim(key))
    end if

    return
  end subroutine FileGetGlobalAttributeText

  !-----------------------------------------------------------------------------
  subroutine FileGetGlobalAttributeInt( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (out)
       )
    integer,          intent(in) :: fid
    character(LEN=*), intent(in) :: key
    integer,          intent(out) :: val(:)

    integer error

    intrinsic size

    call file_get_global_attribute_int( & ! (in)
         fid, key, size(val),           & ! (in)
         val, error                     ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get integer global attribute: '//trim(key))
    end if

    return
  end subroutine FileGetGlobalAttributeInt

% [["SP","Float"], ["DP","Double"]].each do |rp,name|
  !-----------------------------------------------------------------------------
  subroutine FileGetGlobalAttribute<%=name%>( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (out)
       )
    integer,          intent(in) :: fid
    character(LEN=*), intent(in) :: key
    real(<%=rp%>),    intent(out) :: val(:)

    integer error

    intrinsic size

    call file_get_global_attribute_<%=name.downcase%>( & ! (in)
         fid, key, size(val),                          & ! (in)
         val, error                                    ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get <%=name.downcase%> global attribute: '//trim(key))
    end if

    return
  end subroutine FileGetGlobalAttribute<%=name%>

% end

  !-----------------------------------------------------------------------------
  subroutine FileSetGlobalAttributeText( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(LEN=*), intent(in) :: key
    character(LEN=*), intent(in) :: val

    integer error

    call file_set_global_attribute_text( fid, & ! (in)
         key, val,                            & ! (in)
         error                                ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set text global attribute: '//trim(key))
    end if

    return
  end subroutine FileSetGlobalAttributeText

  !-----------------------------------------------------------------------------
  subroutine FileSetGlobalAttributeInt( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(LEN=*), intent(in) :: key
    integer,          intent(in) :: val(:)

    integer error

    intrinsic size

    call file_set_global_attribute_int( fid, & ! (in)
         key, val, size(val),                & ! (in)
         error                               ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set integer global attribute: '//trim(key))
    end if

    return
  end subroutine FileSetGlobalAttributeInt

% [["SP","Float"], ["DP","Double"]].each do |rp,name|
  !-----------------------------------------------------------------------------
  subroutine FileSetGlobalAttribute<%=name%>( &
       fid,      & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(LEN=*), intent(in) :: key
    real(<%=rp%>),    intent(in) :: val(:)

    integer error

    intrinsic size

    call file_set_global_attribute_<%=name.downcase%>( fid, & ! (in)
         key, val, size(val),                               & ! (in)
         error                                              ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set <%=name.downcase%> global attribute: '//trim(key))
    end if

    return
  end subroutine FileSetGlobalAttribute<%=name%>

% end
  !-----------------------------------------------------------------------------
  subroutine FileSetOption( &
       fid,      & ! (in)
       filetype, & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(LEN=*), intent(in) :: filetype
    character(LEN=*), intent(in) :: key
    character(LEN=*), intent(in) :: val

    integer error

    call file_set_option( fid, filetype, key, val, & ! (in)
                          error                    ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to set option')
    end if

    return
  end subroutine FileSetOption

  !-----------------------------------------------------------------------------
  subroutine FileOpen( &
      fid,       & ! (out)
      basename,  & ! (in)
      mode,      & ! (in)
      single,    & ! (in) optional
      comm,      & ! (in) optional
      myrank     & ! (in) optional
      )
    implicit none

    integer,          intent(out) :: fid
    character(LEN=*), intent( in) :: basename
    integer,          intent( in) :: mode
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: comm
    integer,          intent( in), optional :: myrank

    logical :: existed
    logical :: single_ = .false.

    if ( present(single) ) single_ = single
    if ( present(myrank) ) mpi_myrank = myrank

    call FileGetfid( fid, existed,     & ! (out)
         basename, mode, single_, comm ) ! (in)

    return
  end subroutine FileOpen

  !-----------------------------------------------------------------------------
  ! interface FilePutAxis
  !-----------------------------------------------------------------------------
% ["SP", "DP"].each do |rp|
  subroutine FilePutAxisReal<%=rp%>( &
       fid,      & ! (in)
       name,     & ! (in)
       desc,     & ! (in)
       units,    & ! (in)
       dim_name, & ! (in)
       dtype,    & ! (in)
       val       ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_name
    integer,          intent(in) :: dtype
    real(<%=rp%>),    intent(in) :: val(:)

    integer error
    intrinsic size

    call file_put_axis( fid, name, desc, units, dim_name, dtype, val, size(val), <%=rp%>, & ! (in)
         error                                                                            ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put axis')
    end if

    return
  end subroutine FilePutAxisReal<%=rp%>
%end

  subroutine FileDefAxis( &
       fid,      & ! (in)
       name,     & ! (in)
       desc,     & ! (in)
       units,    & ! (in)
       dim_name, & ! (in)
       dtype,    & ! (in)
       dim_size  ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_name
    integer,          intent(in) :: dtype
    integer,          intent(in) :: dim_size

    integer error
    intrinsic size

    call file_def_axis( fid, name, desc, units, dim_name, dtype, dim_size, & ! (in)
         error                                                             ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to define axis')
    end if

    return
  end subroutine FileDefAxis

  !-----------------------------------------------------------------------------
  ! interface FileWriteAxis
  !-----------------------------------------------------------------------------
% ["SP", "DP"].each do |rp|
  subroutine FileWriteAxisReal<%=rp%>( &
       fid,      & ! (in)
       name,     & ! (in)
       val,      & ! (in)
       start     ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(<%=rp%>),    intent(in)           :: val(:)
    integer,          intent(in), optional :: start(:)

    integer error
    intrinsic shape

    if ( present(start) ) then
       call file_write_axis( fid, name, val, <%=rp%>, start, shape(val), & ! (in)
            error                                                        ) ! (out)
    else
       call file_write_axis( fid, name, val, <%=rp%>, (/1/), shape(val), & ! (in)
            error                                                        ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to write axis')
    end if

    return
  end subroutine FileWriteAxisReal<%=rp%>
%end

  !-----------------------------------------------------------------------------
  ! interface FilePutAssociatedCoordinates
  !-----------------------------------------------------------------------------
% for n in 1..4
%   ["SP", "DP"].each do |rp|
  subroutine FilePut<%=n%>DAssociatedCoordinatesReal<%=rp%>( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(<%=rp%>),    intent(in) :: val(<%=Array.new(n){":"}.join(",")%>)

    integer error
    intrinsic size

    call file_put_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, <%=rp%>,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FilePut<%=n%>DAssociatedCoordinatesReal<%=rp%>
%  end
% end

  subroutine FileDefAssociatedCoordinates( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype      ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype

    integer error
    intrinsic size

    call file_def_associated_coordinates( fid,                 & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         error                                                 ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates')
    end if

    return
  end subroutine FileDefAssociatedCoordinates

  !-----------------------------------------------------------------------------
  ! interface FileWriteAssociatedCoordinates
  !-----------------------------------------------------------------------------
% for n in 1..4
%   ["SP", "DP"].each do |rp|
  subroutine FileWrite<%=n%>DAssociatedCoordinatesReal<%=rp%>( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(<%=rp%>),    intent(in)           :: val(<%=Array.new(n){":"}.join(",")%>)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer error
    intrinsic size, shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associated_coordinates( fid, name, val, <%=rp%>, & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associated_coordinates( fid, name, val, <%=rp%>, & ! (in)
            <%=n%>, start, shape(val),                                  & ! (in)
            error                                                       ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associated_coordinates( fid, name, val, <%=rp%>, & ! (in)
            <%=n%>, (/<%=([1]*n).join(",")%>/), shape(val),             & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to put associated coordinates: '//trim(name))
    end if

    return
  end subroutine FileWrite<%=n%>DAssociatedCoordinatesReal<%=rp%>
%  end
% end

  !-----------------------------------------------------------------------------
  ! interface FileAddVariable
  !-----------------------------------------------------------------------------
  subroutine FileAddVariableNoT( &
       vid,     & ! (out)
       fid,     & ! (in)
       varname, & ! (in)
       desc,    & ! (in)
       units,   & ! (in)
       dims,    & ! (in)
       dtype,   & ! (in)
       tavg     & ! (in) optional
       )
    integer,          intent(out) :: vid
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    logical,          intent( in), optional :: tavg

    call FileAddVariableRealDP(vid, fid, varname, desc, units, dims, dtype, &
         -1.0_DP, tavg )

    return
  end subroutine FileAddVariableNoT
% ["SP", "DP"].each do |rp|
  subroutine FileAddVariableReal<%=rp%>( &
       vid,     & ! (out)
       fid,     & ! (in)
       varname, & ! (in)
       desc,    & ! (in)
       units,   & ! (in)
       dims,    & ! (in)
       dtype,   & ! (in)
       tint,    & ! (in)
       tavg     & ! (in) optional
       )
    integer,          intent(out) :: vid
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    real(<%=rp%>),    intent( in) :: tint
    logical,          intent( in), optional :: tavg

    real(DP) :: tint8
    integer  :: itavg
    integer  :: error
    integer  :: n

    intrinsic size
    !---------------------------------------------------------------------------

    vid = -1
    do n = 1, File_vid_count
       if ( File_vid_fid_list(n) == fid .and. &
            varname == File_vname_list(n) ) then
          vid = File_vid_list(n)
       end if
    enddo

    if ( vid < 0 ) then ! variable registration
       !--- register new variable
       write(message,*) '*** [File] Var registration'
       call Log("I", message)
       write(message,*) '*** variable name: ', trim(varname)
       call Log("I", message)

       tint8 = real(tint,DP)

       if ( present(tavg) ) then
          if ( tavg ) then
             itavg = 1
          else
             itavg = 0
          end if
       else
          itavg = 0
       end if

       call file_add_variable( vid,                             & ! (out)
            fid, varname, desc, units, dims, size(dims), dtype, & ! (in)
            tint8, itavg,                                       & ! (in)
            error                                               ) ! (out)
       if ( error /= SUCCESS_CODE ) then
          call Log('E', 'xxx failed to add variable: '//trim(varname))
       end if

       File_vname_list  (File_vid_count) = trim(varname)
       File_vid_list    (File_vid_count) = vid
       File_vid_fid_list(File_vid_count) = fid
       File_vid_count                    = File_vid_count + 1
    endif

    return
  end subroutine FileAddVariableReal<%=rp%>
%end

  subroutine FileDefineVariable( &
       fid,     & ! (in)
       vid,     & ! (out)
       varname, & ! (in)
       desc,    & ! (in)
       units,   & ! (in)
       ndims,   & ! (in)
       dims,    & ! (in)
       dtype,   & ! (in)
       tint,    & ! (in) optional
       tavg     & ! (in) optional
       )
    integer,          intent(out) :: vid
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    integer,          intent( in) :: ndims
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    real(DP),         intent( in), optional :: tint
    logical,          intent( in), optional :: tavg

    real(DP) :: tint_
    integer  :: itavg
    integer  :: error
    integer  :: n

    intrinsic size
    !---------------------------------------------------------------------------

    vid = -1
    do n = 1, File_vid_count
       if ( File_vid_fid_list(n) == fid .and. &
            varname == File_vname_list(n) ) then
          vid = File_vid_list(n)
       end if
    enddo

    if ( vid < 0 ) then ! variable registration
       !--- register new variable
       write(message,*) '*** [File] Var registration'
       call Log("I", message)
       write(message,*) '*** variable name: ', trim(varname)
       call Log("I", message)

       if ( .NOT. present(tint) ) then
          tint_ = -1.0_DP
       endif

       if ( present(tavg) ) then
          if ( tavg ) then
             itavg = 1
          else
             itavg = 0
          end if
       else
          itavg = 0
       end if

       call file_add_variable( vid,                        & ! (out)
            fid, varname, desc, units, dims, ndims, dtype, & ! (in)
            tint_, itavg,                                  & ! (in)
            error                                          ) ! (out)
       if ( error /= SUCCESS_CODE ) then
          call Log('E', 'xxx failed to add variable: '//trim(varname))
       end if

       File_vname_list  (File_vid_count) = trim(varname)
       File_vid_list    (File_vid_count) = vid
       File_vid_fid_list(File_vid_count) = fid
       File_vid_count                    = File_vid_count + 1
    endif

    return
  end subroutine FileDefineVariable

  !-----------------------------------------------------------------------------
  ! FileSetTAttr
  !-----------------------------------------------------------------------------
  subroutine FileSetTAttr( &
     fid,   & ! (in)
     vname, & ! (in)
     key,   & ! (in)
     val    & ! (in)
     )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer :: error

    call file_set_tattr( &
         fid, vname, & ! (in)
         key, val,   & ! (in)
         error       ) ! (out)
    if ( error /= SUCCESS_CODE .and. error /= ALREADY_EXISTED_CODE ) then
       call Log('E', 'xxx failed to set attr for axis')
    end if

    return
  end subroutine FileSetTAttr

  !-----------------------------------------------------------------------------
  ! FileGetShape
  !-----------------------------------------------------------------------------
  subroutine FileGetShape( &
      dims,          & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      myrank,        & ! (in)
      single         & ! (in) optional
      )
    implicit none

    integer,          intent(out)           :: dims(:)
    character(LEN=*), intent( in)           :: basename
    character(LEN=*), intent( in)           :: varname
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: error
    integer :: n

    logical :: single_ = .false.

    intrinsic size
    intrinsic shape
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo, & ! (out)
         fid, varname, 1, .false., & ! (in)
         error                     ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data information :'//trim(varname))
    end if

    if ( dinfo%rank /= size(dims) ) then
       write(message,*) 'xxx rank is different, ', size(dims), dinfo%rank
       call Log('E', message)
    end if
    do n = 1, size(dims)
       dims(n) = dinfo%dim_size(n)
    end do

    return
  end subroutine FileGetShape

  !-----------------------------------------------------------------------------
  ! FileGetData
  !-----------------------------------------------------------------------------
  subroutine FileGetDatainfo( &
      basename,    &
      varname,     &
      myrank,      &
      istep,       &
      single,      &
      description, &
      units,       &
      datatype,    &
      dim_rank,    &
      dim_name,    &
      dim_size,    &
      time_start,  &
      time_end,    &
      time_units   )
    implicit none
    character(len=*),           intent(in)  :: basename
    character(len=*),           intent(in)  :: varname
    integer,                    intent(in)  :: myrank
    integer,                    intent(in)  :: istep
    logical,                    intent(in), optional :: single

    character(len=File_HMID),   intent(out), optional :: description
    character(len=File_HSHORT), intent(out), optional :: units
    integer,                    intent(out), optional :: datatype
    integer,                    intent(out), optional :: dim_rank
    character(len=File_HSHORT), intent(out), optional :: dim_name(:)
    integer,                    intent(out), optional :: dim_size(:)
    real(DP),                   intent(out), optional :: time_start
    real(DP),                   intent(out), optional :: time_end
    character(len=File_HMID),   intent(out), optional :: time_units

    integer        :: fid
    type(datainfo) :: dinfo

    integer :: ndim, idim
    real(DP):: time(1)

    integer :: error
    logical :: single_ = .false.

    intrinsic size
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,        & ! [OUT]
                   basename,   & ! [IN]
                   File_FREAD, & ! [IN]
                   single_     ) ! [IN]

    !--- get data information
    call file_get_datainfo( dinfo,   & ! [OUT]
                            fid,     & ! [IN]
                            varname, & ! [IN]
                            istep,   & ! [IN]
                            .false., & ! [IN]
                            error    ) ! [OUT]

    !--- verify and exit
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx data info not found in '//trim(basename))
    endif

    if ( present(description) ) description = dinfo%description
    if ( present(units)       ) units       = dinfo%units
    if ( present(datatype)    ) datatype    = dinfo%datatype
    if ( present(dim_rank)    ) dim_rank    = dinfo%rank

    if ( present(dim_name) ) then
       ndim = min( dinfo%rank, size(dim_name) ) ! limit dimension rank
       do idim = 1, ndim
          dim_name(idim) = dinfo%dim_name(idim)
       enddo
    end if
    if ( present(dim_size) ) then
       ndim = min( dinfo%rank, size(dim_size) ) ! limit dimension rank
       do idim = 1, ndim
          dim_size(idim) = dinfo%dim_size(idim)
       enddo
    end if

    if ( present(time_units)  ) then
       if ( dinfo%time_units == "" ) then
          call FileGetGlobalAttribute( fid, "time_units", time_units )
       else
          time_units  = dinfo%time_units
       end if
    end if
    if ( present(time_start)  ) then
       if ( dinfo%time_units == "" ) then
          call FileGetGlobalAttribute( fid, "time", time )
          time_start = time(1)
       else
          time_start  = dinfo%time_start
       end if
    end if
    if ( present(time_end)  ) then
       if ( dinfo%time_units == "" ) then
          call FileGetGlobalAttribute( fid, "time", time )
          time_end = time(1)
       else
          time_end  = dinfo%time_end
       end if
    end if

    return
  end subroutine FileGetDatainfo

  !-----------------------------------------------------------------------------
  ! FileGetData
  !-----------------------------------------------------------------------------
  subroutine FileGetAllDatainfo( &
      step_limit,  &
      dim_limit,   &
      basename,    &
      varname,     &
      myrank,      &
      step_nmax,   &
      description, &
      units,       &
      datatype,    &
      dim_rank,    &
      dim_name,    &
      dim_size,    &
      time_start,  &
      time_end,    &
      time_units,  &
      single       )
    implicit none

    integer,                    intent(in)  :: step_limit
    integer,                    intent(in)  :: dim_limit
    character(len=*),           intent(in)  :: basename
    character(len=*),           intent(in)  :: varname
    integer,                    intent(in)  :: myrank
    integer,                    intent(out) :: step_nmax
    character(len=File_HMID),   intent(out) :: description
    character(len=File_HSHORT), intent(out) :: units
    integer,                    intent(out) :: datatype
    integer,                    intent(out) :: dim_rank
    character(len=File_HSHORT), intent(out) :: dim_name  (dim_limit)
    integer,                    intent(out) :: dim_size  (dim_limit)
    real(DP),                   intent(out) :: time_start(step_limit)
    real(DP),                   intent(out) :: time_end  (step_limit)
    character(len=File_HMID),   intent(out) :: time_units

    logical,                    intent(in), optional :: single

    integer        :: fid
    type(datainfo) :: dinfo

    integer :: ndim
    integer :: istep, idim
    logical :: flag_first = .true.

    integer :: error
    logical :: single_ = .false.
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,        & ! [OUT]
                   basename,   & ! [IN]
                   File_FREAD, & ! [IN]
                   single_     ) ! [IN]

    ! initialize
    description   = ""
    units         = ""
    datatype      = -1
    dim_rank      = -1
    dim_name  (:) = ""
    dim_size  (:) = -1
    time_start(:) = RMISS
    time_end  (:) = RMISS

    do istep = 1, step_limit
       !--- get data information
       call file_get_datainfo( dinfo,   & ! [OUT]
                               fid,     & ! [IN]
                               varname, & ! [IN]
                               istep,   & ! [IN]
                               .true.,  & ! [IN]
                               error    ) ! [OUT]

       !--- verify and exit
       if ( error /= SUCCESS_CODE ) then
          step_nmax = istep - 1
          exit
       endif

       if ( flag_first ) then
          flag_first = .false.

          description = dinfo%description
          units       = dinfo%units
          datatype    = dinfo%datatype
          dim_rank    = dinfo%rank

          ndim = min( dinfo%rank, dim_limit ) ! limit dimension rank
          do idim = 1, ndim
             dim_name(idim) = dinfo%dim_name(idim)
             dim_size(idim) = dinfo%dim_size(idim)
          enddo

          time_units        = dinfo%time_units
       endif

       time_start(istep) = dinfo%time_start
       time_end  (istep) = dinfo%time_end
    enddo

    return
  end subroutine FileGetAllDatainfo

  !-----------------------------------------------------------------------------
  ! interface File_read
  !-----------------------------------------------------------------------------
% for d in 1..4
%   idx = ( [":"]*d ).join(",")
%   ["SP", "DP"].each do |rp|
  subroutine FileRead<%=d%>DReal<%=rp%>( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(<%=rp%>),    intent(out)           :: var(<%=idx%>)
    character(LEN=*), intent( in)           :: basename
    character(LEN=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(<%=d%>)
    integer :: error
    integer :: n

    logical :: single_ = .false.

    intrinsic shape
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    if ( present(single) ) single_ = single

    !--- search/register file
    call FileOpen( fid,                & ! (out)
         basename, File_FREAD, single_ ) ! (in)

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(<%=idx%>) = 0.0_<%=rp%>
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= <%=d%> ) then
       write(message,*) 'xxx rank is not <%=d%>', dinfo%rank
       call Log('E', message)
    end if
    dim_size(:) = shape(var)
    do n = 1, <%=d%>
       if ( dinfo%dim_size(n) /= dim_size(n) ) then
          write(message,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
          call Log('E', message)
       end if
    end do

    call file_read_data( var(<%=idx%>), & ! (out)
         dinfo, <%=rp%>,                & ! (in)
         error                          ) ! (out)
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileRead<%=d%>DReal<%=rp%>
%   end
% end

% for d in 1..4
%   idx = ( [":"]*d ).join(",")
%   ["SP", "DP"].each do |rp|
  subroutine FileReadVar<%=d%>DReal<%=rp%>( &
      var,           & ! (out)
      fid,           & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      myrank,        & ! (in)
      allow_missing, & ! (in) optional
      single,        & ! (in) optional
      ntypes,        & ! (in)
      dtype,         & ! (in)
      start,         & ! (in)
      count          & ! (in)
      )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(<%=rp%>),    intent(out)           :: var(<%=idx%>)
    integer,          intent( in)           :: fid
    character(LEN=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: myrank
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: error

    intrinsic size, shape
    !---------------------------------------------------------------------------

    mpi_myrank = myrank

    !--- get data information
    call file_get_datainfo( dinfo,    & ! (out)
         fid, varname, step, .false., & ! (in)
         error                        ) ! (out)

    !--- verify
    if ( error /= SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             write(message,*) 'xxx [INPUT]/[File] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             call Log('I', message)
             call Log('I', 'xxx [INPUT]/[File] Value is set to 0.')
             var(<%=idx%>) = 0.0_<%=rp%>
          else
             call Log('E', 'xxx failed to get data information :'//trim(varname))
          end if
       else
          call Log('E', 'xxx failed to get data information :'//trim(varname))
       end if
    end if

    if ( dinfo%rank /= <%=d%> ) then
       write(message,*) 'xxx rank is not <%=d%>', dinfo%rank
       call Log('E', message)
    end if

    if (present(ntypes) ) then
       call file_read_data_par( var(<%=idx%>),                    & ! (out)
            dinfo, size(shape(var)), ntypes, dtype, start, count, & ! (in)
            error                                                 ) ! (out)
    else
       call file_read_data( var(<%=idx%>), & ! (out)
            dinfo, <%=rp%>,                & ! (in)
            error                          ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to get data value')
    end if

    return
  end subroutine FileReadVar<%=d%>DReal<%=rp%>
%   end
% end

  !-----------------------------------------------------------------------------
  ! interface FileWrite
  !-----------------------------------------------------------------------------
% for d in 1..4
%   idx = ( [":"]*d ).join(",")
%   ["SP", "DP"].each do |rp|
  subroutine FileWrite<%=d%>DReal<%=rp%>( &
      fid,     & ! (in)
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
      start,   & ! (in)
      count,   & ! (in)
      ndims    & ! (in)
      )
    implicit none

    real(<%=rp%>), intent(in) :: var(<%=idx%>)
    integer,  intent(in)           :: fid
    integer,  intent(in)           :: vid
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    integer,  intent(in), optional :: count(:) ! when var has been reshaped to 1D
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D

    real(DP) :: ts, te

    integer :: start_(<%=d%>)

    integer :: error, n
    character(len=100) :: str

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          call Log('E', 'start argument is neccessary when ndims is specified')
       end if
       if ( .not. present(count) ) then
          call Log('E', 'count argument is neccessary when ndims is specified')
       end if

       call file_write_data( fid, vid, var(<%=idx%>), ts, te, <%=rp%>, & ! (in)
            ndims, start, count,                                       & ! (in)
            error                                                      ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data( fid, vid, var(<%=idx%>), ts, te, <%=rp%>, & ! (in)
            <%=d%>, start_, shape(var),                                & ! (in)
            error                                                      ) ! (out)
    end if
    if ( error /= SUCCESS_CODE ) then
       do n = 1, File_vid_count
          if ( File_vid_list(n) == vid ) then
             write(str,*) 'xxx failed to write data: ', trim(File_vname_list(n)), mpi_myrank
             exit
          end if
       enddo
       call Log('E', trim(str))
    end if

    return
  end subroutine FileWrite<%=d%>DReal<%=rp%>
%   end
% end

  !-----------------------------------------------------------------------------
  ! exit netCDF define mode and enter data mode
  subroutine FileEndDef( &
       fid & ! (in)
       )
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) exit
    end do
    if ( fid .NE. File_fid_list(n) ) then
       write(message,*) 'xxx in FileEndDef invalid fid' , fid
       call Log('E', message)
    end if
    call file_enddef( fid , & ! (in)
         error              ) ! (out)
    if ( error .EQ. SUCCESS_CODE ) then
       write(message, '(1x,A,i3)') '*** [File] File enddef : NO.', n
       call Log('I', message)
       call Log('I', '*** enddef filename: ' // trim(File_fname_list(n)))
    else
       call Log('E', 'xxx failed to exit define mode')
    end if

    return
  end subroutine FileEndDef

  !-----------------------------------------------------------------------------
  ! This subroutine is used when PnetCDF I/O method is enabled
  subroutine FileAttachBuffer( &
       fid,       & ! (in)
       buf_amount ) ! (in)
    implicit none

    integer, intent(in) :: fid
    integer, intent(in) :: buf_amount

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) exit
    end do
    if ( fid .NE. File_fid_list(n) ) then
       write(message,*) 'xxx in FileAttachBuffer invalid fid' , fid
       call Log('E', message)
    end if
    call file_attach_buffer( fid, buf_amount, & ! (in)
         error                                ) ! (out)
    if ( error .EQ. SUCCESS_CODE ) then
       write(message, '(1x,A,i3)') '*** [File] File Attach Buffer : NO.', n
       call Log('I', message)
       write(message, '(1x,A,i)') '*** attach buffer for filename: ' // trim(File_fname_list(n)) // ', size=', buf_amount
       call Log('I', message)
    else
       call Log('E', 'xxx failed to attach buffer in PnetCDF')
    end if

    return
  end subroutine FileAttachBuffer

  !-----------------------------------------------------------------------------
  ! This subroutine is used when PnetCDF I/O method is enabled
  subroutine FileDetachBuffer( &
       fid        ) ! (in)
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) exit
    end do
    if ( n .EQ. File_fid_count ) return  ! already closed

    if ( fid .NE. File_fid_list(n) ) then
       write(message,*) 'xxx in FileDetachBuffer invalid fid' , fid
       call Log('E', message)
    end if
    call file_detach_buffer( fid, & ! (in)
         error                    ) ! (out)
    if ( error .EQ. SUCCESS_CODE ) then
       write(message, '(1x,A,i3)') '*** [File] File Detach Buffer : NO.', n
       call Log('I', message)
       call Log('I', '*** detach buffer for filename: ' // trim(File_fname_list(n)))
    else
       call Log('E', 'xxx failed to detach buffer in PnetCDF')
    end if

    return
  end subroutine FileDetachBuffer

  !-----------------------------------------------------------------------------
  ! This subroutine is used when PnetCDF I/O method is enabled
  subroutine FileFlush( &
       fid & ! (in)
       )
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return
    if ( File_fid_count == 1 ) return

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) exit
    end do
    if ( n .EQ. File_fid_count ) return  ! already closed

    if ( fid .NE. File_fid_list(n) ) then
       write(message,*) 'xxx in FileFlush invalid fid' , fid
       call Log('E', message)
    end if
    call file_flush( fid,  & ! (in)
         error             ) ! (out)
    if ( error .EQ. SUCCESS_CODE ) then
       write(message, '(1x,A,i3)') '*** [File] File flush : NO.', n
       call Log('I', message)
       call Log('I', '*** FileFlush filename: ' // trim(File_fname_list(n)))
    else
       call Log('E', 'xxx failed to flush PnetCDF pending requests')
    end if

    return
  end subroutine FileFlush

  !-----------------------------------------------------------------------------
  subroutine FileClose( &
       fid & ! (in)
       )
    implicit none

    integer, intent(in) :: fid

    character(LEN=File_HLONG) :: fname
    integer                   :: error
    integer                   :: n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) exit
    end do
    if ( n .EQ. File_fid_count ) return  ! already closed

    if ( fid /= File_fid_list(n) ) then
       write(message,*) 'xxx in FileClose invalid fid ', fid
       call Log('E', message)
    end if
    call file_close( fid , & ! (in)
         error             ) ! (out)
    if ( error == SUCCESS_CODE ) then
       write(message, '(1x,A,i3)') '*** [File] File Close : NO.', n
       call Log('I', message)
       call Log('I', '*** closed filename: ' // trim(File_fname_list(n)))
    else if ( error /= ALREADY_CLOSED_CODE ) then
       call Log('E', 'xxx failed to close file')
    end if

    do n = 1, File_fid_count-1
       if ( File_fid_list(n) == fid ) then
          File_fid_list(n) = -1
          File_fname_list(n) = ''
       end if
    end do

    return
  end subroutine FileClose
  !-----------------------------------------------------------------------------
  subroutine FileCloseAll
    implicit none

    integer n
    !---------------------------------------------------------------------------

    do n = 1, File_fid_count-1
       call FileClose( File_fid_list(n) )
    enddo

    return
  end subroutine FileCloseAll

  !-----------------------------------------------------------------------------
  ! private
  !-----------------------------------------------------------------------------
  subroutine FileMakeFname( &
       fname,    & ! (out)
       basename, & ! (in)
       prefix,   & ! (in)
       myrank,   & ! (in)
       len       ) ! (in)
    character(len=*), intent(out) :: fname
    character(len=*), intent( in) :: basename
    character(len=*), intent( in) :: prefix
    integer,          intent( in) :: myrank
    integer,          intent( in) :: len

    !                           12345678901234567
    character(len=17) :: fmt = "(A, '.', A, I*.*)"
    !---------------------------------------------------------------------------

    if ( len < 1 .or. len > 9 ) then
       call Log('E', 'xxx len is invalid')
    end if

    write(fmt(14:14),'(I1)') len
    write(fmt(16:16),'(I1)') len
    write(fname, fmt) trim(basename), trim(prefix), myrank

    return
  end subroutine FileMakeFname
  !-----------------------------------------------------------------------------
  subroutine FileGetfid( &
      fid,        &
      existed,    &
      basename,   &
      mode,       &
      single,     &
      comm        )
    use MPI, only : MPI_COMM_NULL, MPI_COMM_SELF
    implicit none

    integer,          intent(out) :: fid
    logical,          intent(out) :: existed
    character(LEN=*), intent( in) :: basename
    integer,          intent( in) :: mode
    logical,          intent( in) :: single
    integer,          intent( in), optional :: comm

    character(LEN=File_HSHORT) :: rwname(0:2)
    data rwname / 'READ','WRITE','APPEND' /

    character(LEN=File_HLONG) :: fname
    integer                   :: n

    integer :: error
    integer :: comm_
    !---------------------------------------------------------------------------

    !--- register new file and open
    comm_ = MPI_COMM_NULL
    if ( present(comm) ) comm_ = comm
    if ( comm_ .NE. MPI_COMM_NULL ) then
       ! parallel I/O on a single shared netCDF file
       fname = basename
       comm_ = comm
    elseif ( single ) then
       fname = trim(basename)//'.peall'
    else
       call FileMakeFname(fname,trim(basename),'pe',mpi_myrank,6)
    endif

    !--- search existing file
    fid = -1
    do n = 1, File_fid_count-1
       if ( fname==File_fname_list(n) ) fid = File_fid_list(n)
    enddo

    if ( fid >= 0 ) then
       existed = .true.
       return
    end if

    call file_open( fid,     & ! (out)
         fname, mode, comm_, & ! (in)
         error               ) ! (out)

    if ( error /= SUCCESS_CODE ) then
       call Log('E', 'xxx failed to open file :'//trim(fname)//'.nc')
    end if

    write(message,*) '*** [File] File registration : ',trim(rwname(mode)),' -', fid
    call Log("I", message)
    write(message,*) '*** filename: ', trim(fname)
    call Log("I", message)

    File_fname_list(File_fid_count) = trim(fname)
    File_fid_list  (File_fid_count) = fid
    File_fid_count                  = File_fid_count + 1

    existed = .false.

    return
  end subroutine FileGetfid

end module gtool_file
!-------------------------------------------------------------------------------


!--
! vi<%=":"%>set readonly sw=4 ts=8
!
!Local Variables<%=":"%>
!mode: f90
!buffer-read-only: t
!End:
!
!++
