!-------------------------------------------------------------------------------
!> module Gtool_History
!!
!! @par Description
!!          module library for history output
!!
!! @author Team SCALE
!!
!! @par History
!! @li      2012-06-11 (S.Nishizawa)  [new] imported from SCALE-LES
!!
!<
!-------------------------------------------------------------------------------
! Warning: This file was generated from gtool_history.f90.erb.
!          Do not edit this file.
!-------------------------------------------------------------------------------
module gtool_history
  !-----------------------------------------------------------------------------
  !
  !++ Used modules
  !
  use dc_log, only: &
     Log, &
#if defined(__PGI) || defined(__ES2)
     LOG_fid, &
#endif
     LOG_LMSG
  use dc_types, only: &
     SP, &
     DP
  use gtool_file_h, only: &
     File_HLONG, &
     File_HSHORT, &
     File_HMID
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedures
  !
  public :: HistoryInit
  public :: HistoryAddVariable
  public :: HistoryPutAxis
  public :: HistoryPutAssociatedCoordinates
  public :: HistorySetTAttr
  public :: HistoryQuery
  public :: HistoryPut
  public :: HistoryWrite
  public :: HistoryWriteAll
  public :: HistoryGet
  public :: HistoryOutputList
  public :: HistoryFinalize

  interface HistoryPutAxis
     module procedure HistoryPutAxisSP
     module procedure HistoryPutAxisDP
  end interface HistoryPutAxis

  interface HistoryPutAssociatedCoordinates
     module procedure HistoryPut1DAssociatedCoordinatesSP
     module procedure HistoryPut1DAssociatedCoordinatesDP
     module procedure HistoryPut2DAssociatedCoordinatesSP
     module procedure HistoryPut2DAssociatedCoordinatesDP
     module procedure HistoryPut3DAssociatedCoordinatesSP
     module procedure HistoryPut3DAssociatedCoordinatesDP
     module procedure HistoryPut4DAssociatedCoordinatesSP
     module procedure HistoryPut4DAssociatedCoordinatesDP
  end interface HistoryPutAssociatedCoordinates

  interface HistoryPut
     module procedure HistoryPut1DNameSP
     module procedure HistoryPut1DIdSP
     module procedure HistoryPut1DNameDP
     module procedure HistoryPut1DIdDP
     module procedure HistoryPut2DNameSP
     module procedure HistoryPut2DIdSP
     module procedure HistoryPut2DNameDP
     module procedure HistoryPut2DIdDP
     module procedure HistoryPut3DNameSP
     module procedure HistoryPut3DIdSP
     module procedure HistoryPut3DNameDP
     module procedure HistoryPut3DIdDP
  end interface HistoryPut

  interface HistoryGet
     module procedure HistoryGet1DSP
     module procedure HistoryGet1DDP
     module procedure HistoryGet2DSP
     module procedure HistoryGet2DDP
     module procedure HistoryGet3DSP
     module procedure HistoryGet3DDP
  end interface HistoryGet

  type axis
     character(len=File_HSHORT) :: name
     character(len=File_HLONG)  :: desc
     character(len=File_HSHORT) :: units
     character(len=File_HSHORT) :: dim
     integer                    :: type
     real(DP), pointer          :: var(:)
     logical                    :: down
  end type axis
  type assoc
     character(len=File_HSHORT) :: name
     character(len=File_HLONG)  :: desc
     character(len=File_HSHORT) :: units
     character(len=File_HSHORT) :: dims(4)
     integer                    :: ndims
     integer                    :: type
     real(DP), pointer          :: var(:)
  end type assoc

  !-----------------------------------------------------------------------------
  !
  !++ included parameters
  !
  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private procedures
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private parameters & variables
  !
  character(len=File_HMID)   :: HISTORY_TITLE
  character(len=File_HMID)   :: HISTORY_SOURCE
  character(len=File_HMID)   :: HISTORY_INSTITUTION
  character(len=File_HMID)   :: HISTORY_TIME_UNITS
  character(len=File_HMID)   :: HISTORY_TIME_SINCE
  real(DP)                   :: HISTORY_DTSEC
  real(DP)                   :: HISTORY_STARTDAYSEC

  logical                    :: HISTORY_OUTPUT_STEP0  = .false. !> output value of step=0?
  real(DP)                   :: HISTORY_OUTPUT_START  = 0.0_DP  !> start time for output in second
  logical                    :: HISTORY_ERROR_PUTMISS = .false. !> Abort if the value is never stored after last output?

  integer, parameter         :: History_req_limit = 1000 !> number limit for history item request
  character(len=File_HLONG)  :: History_req_basename(History_req_limit)
  character(len=File_HSHORT) :: History_req_item    (History_req_limit)
  real(DP)                   :: History_req_tintsec (History_req_limit)
  integer                    :: History_req_tintstep(History_req_limit)
  logical                    :: History_req_tavg    (History_req_limit)
  logical                    :: History_req_zinterp (History_req_limit)
  integer                    :: History_req_dtype   (History_req_limit)

  integer                                 :: History_req_nmax = 0 !> number of requested item
  integer                                 :: History_id_count = 0 !> number of registered item
  character(len=File_HSHORT), allocatable :: History_item    (:)
  integer,                    allocatable :: History_fid     (:)
  integer,                    allocatable :: History_vid     (:)
  real(DP),                   allocatable :: History_tintsec (:)
  integer,                    allocatable :: History_tintstep(:)
  logical,                    allocatable :: History_tavg    (:)
  logical,                    allocatable :: History_zinterp (:)
  real(DP),                   allocatable :: History_varsum  (:,:)
  integer,                    allocatable :: History_size    (:)
  real(DP),                   allocatable :: History_tstart  (:)
  integer,                    allocatable :: History_tstrstep(:)
  integer,                    allocatable :: History_tlststep(:)
  real(DP),                   allocatable :: History_tsumsec (:)


  real(DP), parameter  :: eps = 1.D-10 !> epsilon for timesec
  integer              :: History_master
  integer              :: History_myrank
  integer, allocatable :: History_rankidx(:)

  integer, parameter :: History_axis_limit = 100 !> number limit of axes
  integer            :: History_axis_count = 0;
  type(axis)         :: History_axis(History_axis_limit)

  integer, parameter :: History_assoc_limit = 20 !> number limit of associated coordinates
  integer            :: History_assoc_count = 0;
  type(assoc)        :: History_assoc(History_assoc_limit)

  character(LEN=LOG_LMSG), private :: message

contains
  !-----------------------------------------------------------------------------
  subroutine HistoryInit( &
       title, source, institution,                         & ! (in)
       array_size,                                         & ! (in)
       master, myrank, rankidx,                            & ! (in)
       time_start, time_interval,                          & ! (in)
       time_units, time_since,                             & ! (in)
       default_basename,                                   & ! (in) optional
       default_tinterval, default_tunit, default_taverage, & ! (in) optional
       default_zinterp,                                    & ! (in) optional
       default_datatype,                                   & ! (in) optional
       namelist_filename, namelist_fid                     & ! (in) optional
       )
    use dc_calendar, only: &
       CalendarYmdhms2sec
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8, &
       File_preclist
    implicit none

    character(len=*), intent(in)           :: title
    character(len=*), intent(in)           :: source
    character(len=*), intent(in)           :: institution
    integer,          intent(in)           :: array_size
    integer,          intent(in)           :: master
    integer,          intent(in)           :: myrank
    integer,          intent(in)           :: rankidx(:)
    real(DP),         intent(in)           :: time_start
    real(DP),         intent(in)           :: time_interval
    character(len=*), intent(in), optional :: time_units
    character(len=*), intent(in), optional :: time_since
    character(len=*), intent(in), optional :: default_basename
    real(DP),         intent(in), optional :: default_tinterval
    character(len=*), intent(in), optional :: default_tunit
    logical,          intent(in), optional :: default_taverage
    logical,          intent(in), optional :: default_zinterp
    character(len=*), intent(in), optional :: default_datatype
    character(len=*), intent(in), optional :: namelist_filename
    integer         , intent(in), optional :: namelist_fid

    character(len=File_HLONG)  :: HISTORY_DEFAULT_BASENAME  = 'history'
    real(DP)                   :: HISTORY_DEFAULT_TINTERVAL = 1.0_DP
    character(len=File_HSHORT) :: HISTORY_DEFAULT_TUNIT     = 'sec'
    logical                    :: HISTORY_DEFAULT_TAVERAGE  = .false.
    logical                    :: HISTORY_DEFAULT_ZINTERP   = .false.
    character(len=File_HSHORT) :: HISTORY_DEFAULT_DATATYPE  = 'REAL4'

    NAMELIST / PARAM_HISTORY / &
         HISTORY_TITLE,             &
         HISTORY_SOURCE,            &
         HISTORY_INSTITUTION,       &
         HISTORY_TIME_UNITS,        &
         HISTORY_TIME_SINCE,        &
         HISTORY_DEFAULT_BASENAME,  &
         HISTORY_DEFAULT_TINTERVAL, &
         HISTORY_DEFAULT_TUNIT,     &
         HISTORY_DEFAULT_TAVERAGE,  &
         HISTORY_DEFAULT_ZINTERP,   &
         HISTORY_DEFAULT_DATATYPE,  &
         HISTORY_OUTPUT_STEP0,      &
         HISTORY_OUTPUT_START,      &
         HISTORY_ERROR_PUTMISS

    character(len=File_HLONG)  :: BASENAME  !> file base name
    character(len=File_HSHORT) :: ITEM      !> name of history item
    real(DP)                   :: TINTERVAL !> time interval to output
    character(len=File_HSHORT) :: TUNIT     !> time unit
    logical                    :: TAVERAGE  !> time average to output
    logical                    :: ZINTERP   !> z interpolation to output
    character(len=File_HSHORT) :: DATATYPE  !> data type

    NAMELIST / HISTITEM / &
       BASENAME,  &
       ITEM,      &
       TINTERVAL, &
       TUNIT,     &
       TAVERAGE,  &
       ZINTERP,   &
       DATATYPE

    integer :: fid_conf

    integer :: ierr
    integer :: n
    integer :: memsize
    intrinsic size
    !---------------------------------------------------------------------------

    call Log('I', '')
    call Log('I', '+++ Module[HISTORY]/Categ[IO]')

    !--- read namelist
    HISTORY_TITLE       = title
    HISTORY_SOURCE      = source
    HISTORY_INSTITUTION = institution
    HISTORY_STARTDAYSEC = time_start
    HISTORY_DTSEC       = time_interval
    if ( present(time_units) ) then
       HISTORY_TIME_UNITS  = time_units
    else
       HISTORY_TIME_UNITS  = 'seconds'
    endif
    if ( present(time_since) ) then
       HISTORY_TIME_SINCE = time_since
    else
       HISTORY_TIME_SINCE = ''
    endif
    if ( present(default_basename) ) then
       HISTORY_DEFAULT_BASENAME = default_basename
    endif
    if ( present(default_tinterval) ) then
       HISTORY_DEFAULT_TINTERVAL = default_tinterval
       if ( present(default_tunit) ) then
          HISTORY_DEFAULT_TUNIT = default_tunit
       endif
    endif
    if ( present(default_taverage) ) then
       HISTORY_DEFAULT_TAVERAGE = default_taverage
    endif
    if ( present(default_zinterp) ) then
       HISTORY_DEFAULT_ZINTERP = default_zinterp
    endif
    if ( present(default_datatype) ) then
       HISTORY_DEFAULT_DATATYPE = default_datatype
    endif

    if ( present(namelist_fid) ) then
       fid_conf = namelist_fid
       rewind(fid_conf)
    else if ( present(namelist_filename) ) then
       if ( namelist_filename /= '' ) then
          open( fid_conf, file = trim(namelist_filename), &
               form = 'formatted', status = 'old', iostat = ierr)
       else
          call Log('I', '*** Brank namelist file was specified. Default used. ***')
          fid_conf = -1
       endif
    else
       call Log('I', '*** No namelist was specified. Default used. ***')
       fid_conf = -1
    endif

    if ( fid_conf > 0 ) then
       read(fid_conf, nml=PARAM_HISTORY, iostat=ierr)

       if( ierr < 0 ) then !--- missing
          call Log('I', '*** Not found namelist. Default used.')
       elseif( ierr > 0 ) then !--- fatal error
          call Log('E', 'xxx Not appropriate names in namelist PARAM_HISTORY. Check!')
       endif
#if defined(__PGI) || defined(__ES2)
       write(LOG_fid,nml=PARAM_HISTORY)
#else
       write(message,nml=PARAM_HISTORY)
       call Log('I', message)
#endif
    endif

    ! listup history request
    if ( fid_conf > 0 ) then
       rewind( fid_conf )
       do n = 1, History_req_limit
          read(fid_conf, nml=HISTITEM, iostat=ierr)
          if( ierr /= 0 ) exit
       enddo
       History_req_nmax = n - 1
    else
       History_req_nmax = History_req_limit
    endif

    if    ( History_req_nmax > History_req_limit ) then
       write(message,*) '*** request of history file is exceed! n >', History_req_limit
       call Log('I', message)
    elseif( History_req_nmax == 0 ) then
       call Log('I', '*** No history file specified.')
       return
    endif

    allocate( History_item    (History_req_nmax) ); History_item(:) = ''
    allocate( History_fid     (History_req_nmax) )
    allocate( History_vid     (History_req_nmax) )
    allocate( History_tintsec (History_req_nmax) )
    allocate( History_tintstep(History_req_nmax) )
    allocate( History_tavg    (History_req_nmax) )
    allocate( History_zinterp (History_req_nmax) )

    allocate( History_varsum  (array_size,History_req_nmax) )
    allocate( History_size    (History_req_nmax) )
    allocate( History_tstart  (History_req_nmax) )
    allocate( History_tstrstep(History_req_nmax) )
    allocate( History_tlststep(History_req_nmax) )
    allocate( History_tsumsec (History_req_nmax) )

    if ( fid_conf > 0 ) rewind(fid_conf)
    memsize = 0
    do n = 1, History_req_nmax
       ! set default
       BASENAME  = HISTORY_DEFAULT_BASENAME
       ITEM      = 'unknown'
       TINTERVAL = HISTORY_DEFAULT_TINTERVAL
       TUNIT     = HISTORY_DEFAULT_TUNIT
       TAVERAGE  = HISTORY_DEFAULT_TAVERAGE
       ZINTERP   = HISTORY_DEFAULT_ZINTERP
       DATATYPE  = HISTORY_DEFAULT_DATATYPE

       if ( fid_conf > 0 ) then
          read(fid_conf, nml=HISTITEM,iostat=ierr)
          if( ierr /= 0 ) exit
       endif

       History_req_item    (n) = ITEM
       History_req_basename(n) = BASENAME
       call CalendarYmdhms2sec( History_req_tintsec(n), TINTERVAL, TUNIT )
       History_req_tintstep(n) = int( History_req_tintsec(n) / HISTORY_DTSEC )

       History_req_tavg    (n) = TAVERAGE
       History_req_zinterp (n) = ZINTERP

       if ( History_req_tintsec(n) <= 0.D0 ) then
          write(message,*) 'xxx Not appropriate time interval. Check!', ITEM, TINTERVAL
          call Log('E', message)
       endif

       if ( abs(History_req_tintsec(n)-real(History_req_tintstep(n),kind=DP)*HISTORY_DTSEC) > 0.D0 ) then
          write(message,*) 'xxx time interval must be a multiple of delta t ', &
                           History_req_tintsec(n), real(History_req_tintstep(n),kind=DP)*HISTORY_DTSEC
          call Log('E', message)
       endif

       if    ( DATATYPE == 'REAL4' ) then
          History_req_dtype(n) = File_REAL4
       elseif( DATATYPE == 'REAL8' ) then
          History_req_dtype(n) = File_REAL8
       else
          write(message,*) 'xxx Not appropriate DATATYPE. Check!', DATATYPE
          call Log('E', message)
       endif

       memsize = memsize + array_size * File_preclist(History_req_dtype(n))
    enddo

    write(message,*) '*** Number of requested history item             : ', History_req_nmax
    call Log('I', message)
    write(message,*) '*** Output default data type                     : ', HISTORY_DEFAULT_DATATYPE
    call Log('I', message)
    write(message,*) '*** Memory usage for history data buffer [Mbyte] : ', memsize/1024/1024
    call Log('I', message)

    if ( (.not. present(namelist_fid)) ) then
       if ( fid_conf > 0 ) close(fid_conf)
    endif

    History_master = master
    History_myrank = myrank
    allocate( History_rankidx(size(rankidx)) )
    History_rankidx(:) = rankidx(:)

    return
  end subroutine HistoryInit

  !-----------------------------------------------------------------------------
  subroutine HistoryAddVariable( &
       varname,    &
       dims,       &
       desc,       &
       units,      &
       id,         &
       zinterp,    &
       existed,    &
       options     )
    use gtool_file, only: &
       FileCreate,      &
       FileSetOption,   &
       FileAddVariable, &
       FileSetTAttr,    &
       FilePutAxis,     &
       FilePutAssociatedCoordinates
    implicit none

    character(len=*), intent(in)  :: varname
    character(len=*), intent(in)  :: dims(:)
    character(len=*), intent(in)  :: desc
    character(len=*), intent(in)  :: units
    integer,          intent(out) :: id
    logical,          intent(out) :: zinterp
    logical,          intent(out) :: existed
    character(len=*), intent(in), optional :: options ! 'filetype1:key1=val1&filetype2:key2=val2&...'

    character(len=File_HMID) :: tunits

    logical :: fileexisted
    integer :: nmax, reqid
    integer :: n, m
    integer :: ic, ie, is, lo

    intrinsic size
    !---------------------------------------------------------------------------

    existed = .false.

    !--- search existing item
    id = -1
    nmax = min( History_id_count, History_req_nmax )
    do n = 1, nmax
       if ( varname == History_item(n) ) then ! match existing item
          id      = n
          zinterp = History_zinterp(n)
          existed = .true.
          return
       endif
    enddo

    if ( id < 0 ) then ! request-register matching check

       do n = 1, History_req_nmax
          if ( varname == History_req_item(n) ) then
             reqid = n
             if( History_req_basename(reqid) == '' ) exit
             History_id_count = History_id_count + 1
             id = History_id_count

             ! new file registration
             if ( HISTORY_TIME_SINCE == '' ) then
                tunits = HISTORY_TIME_UNITS
             else
                tunits = trim(HISTORY_TIME_UNITS)//' since '//trim(HISTORY_TIME_SINCE)
             endif

             call FileCreate( History_fid(id),                   & ! (out)
                              fileexisted,                       & ! (out)
                              trim(History_req_basename(reqid)), & ! (in)
                              HISTORY_TITLE,                     & ! (in)
                              HISTORY_SOURCE,                    & ! (in)
                              HISTORY_INSTITUTION,               & ! (in)
                              History_master,                    & ! (in)
                              History_myrank,                    & ! (in)
                              History_rankidx,                   & ! (in)
                              time_units = tunits                ) ! (in)

             if ( .not. fileexisted ) then

                if ( present(options) ) then
                   ic = -1 ! index of ':'
                   ie = -1 ! index of '='
                   is =  1 ! start index
                   lo = len_trim(options)
                   do m = 1, lo+1
                      if ( m == lo+1 .or. options(m:m) == '&' ) then
                         if ( ic == -1 .or. ie == -1 ) then
                            call Log('E', 'xxx option is invalid: ' // trim(options))
                         endif
                         call FileSetOption(History_fid(id),        & ! (in)
                              options(is:ic-1),                     & ! (in)
                              options(ic+1:ie-1), options(ie+1:m-1) ) ! (in)
                         ic = -1
                         ie = -1
                         is = m + 1
                      else if ( options(m:m) == ':' ) then
                         ic = m
                      else if ( options(m:m) == '=' ) then
                         ie = m
                      endif
                   enddo
                endif

                do m = 1, History_axis_count
                   call FilePutAxis( History_fid(id),                             & ! (in)
                                     History_axis(m)%name,  History_axis(m)%desc, & ! (in)
                                     History_axis(m)%units, History_axis(m)%dim,  & ! (in)
                                     History_axis(m)%type,  History_axis(m)%var   ) ! (in)
                enddo

                do m = 1, History_assoc_count
                   call FilePutAssociatedCoordinates( History_fid(id),                                 & ! (in)
                                                      History_assoc(m)%name, History_assoc(m)%desc,    & ! (in)
                                                      History_assoc(m)%units,                          & ! (in)
                                                      History_assoc(m)%dims(1:History_assoc(m)%ndims), & ! (in)
                                                      History_assoc(m)%type, History_assoc(m)%var      ) ! (in)
                enddo

             endif

             History_item    (id) = varname
             History_tintsec (id) = History_req_tintsec (reqid)
             History_tintstep(id) = History_req_tintstep(reqid)
             History_tavg    (id) = History_req_tavg    (reqid)
             History_zinterp (id) = History_req_zinterp (reqid)

             History_varsum(:,id) = 0.D0

             if ( HISTORY_OUTPUT_STEP0 ) then
                History_tstrstep(id) = 1 - History_tintstep(id)
             else
                History_tstrstep(id) = 1
             endif
             if ( History_output_start > 0.0_DP ) then
                History_tstart(id) = HISTORY_STARTDAYSEC - History_output_start
             else
                History_tstart(id) = HISTORY_STARTDAYSEC
             end if
             History_tlststep(id) = History_tstrstep(id)
             History_tsumsec (id) = 0.D0

             call FileAddVariable( History_vid(id),            & ! (out)
                                   History_fid(id),            & ! (in)
                                   varname, desc, units, dims, & ! (in)
                                   History_req_dtype(reqid),   & ! (in)
                                   History_tintsec(id),        & ! (in)
                                   History_tavg   (id)         ) ! (in)

             if ( .not. fileexisted ) then
                do m = 1, History_axis_count
                   if ( History_axis(m)%down ) then
                      call FileSetTAttr( History_fid(id), History_axis(m)%name, "positive", "down" )
                   endif
                enddo
             endif

             write(message,*) '*** [HIST] Item registration No.= ', id
             call Log('I', message)
             write(message,*) '] Name                : ', trim(History_item(id))
             call Log('I', message)
             write(message,*) '] Description         : ', trim(desc)
             call Log('I', message)
             write(message,*) '] Unit                : ', trim(units)
             call Log('I', message)
             write(message,*) '] Interval [sec]      : ', History_tintsec (id)
             call Log('I', message)
             write(message,*) '] Interval [step]     : ', History_tintstep(id)
             call Log('I', message)
             write(message,*) '] Time Average?       : ', History_tavg    (id)
             call Log('I', message)
             write(message,*) '] z* -> z conversion? : ', History_zinterp (id)
             call Log('I', message)
             call Log('I', '')

             zinterp = History_zinterp(id)

             exit
          endif
       enddo

    endif

    return
  end subroutine HistoryAddVariable

  !-----------------------------------------------------------------------------
  ! interface HistoryPutAxis
  !-----------------------------------------------------------------------------
  subroutine HistoryPutAxisSP( &
       name,  & ! (in)
       desc,  & ! (in)
       units, & ! (in)
       dim,   & ! (in)
       var,   & ! (in)
       dtype, & ! (in) optional
       down   & ! (in) optional
       )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim
    real(SP),         intent(in) :: var(:)
    character(len=*), intent(in), optional :: dtype
    logical,          intent(in), optional :: down

    integer :: type
    !---------------------------------------------------------------------------

    if ( present(dtype) ) then
       if ( dtype == 'REAL4' ) then
          type = File_REAL4
       else if ( dtype == 'REAL8' ) then
          type = File_REAL8
       else
          write(message,*) 'xxx Not appropriate dtype. Check!', dtype
          call Log('E', message)
       endif
    else
       type = File_REAL4
    endif

    if ( History_axis_count < History_axis_limit ) then
       History_axis_count = History_axis_count + 1
       History_axis(History_axis_count)%name  = name
       History_axis(History_axis_count)%desc  = desc
       History_axis(History_axis_count)%units = units
       History_axis(History_axis_count)%dim   = dim
       History_axis(History_axis_count)%type  = type
       allocate(History_axis(History_axis_count)%var(size(var)))
       History_axis(History_axis_count)%var = var
       if ( present(down) ) then
          History_axis(History_axis_count)%down = down
       else
          History_axis(History_axis_count)%down = .false.
       endif
    else
       write(message,*) 'xxx Number of axis exceeds the limit.'
       call Log('E', message)
    endif

    return
  end subroutine HistoryPutAxisSP
  subroutine HistoryPutAxisDP( &
       name,  & ! (in)
       desc,  & ! (in)
       units, & ! (in)
       dim,   & ! (in)
       var,   & ! (in)
       dtype, & ! (in) optional
       down   & ! (in) optional
       )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim
    real(DP),         intent(in) :: var(:)
    character(len=*), intent(in), optional :: dtype
    logical,          intent(in), optional :: down

    integer :: type
    !---------------------------------------------------------------------------

    if ( present(dtype) ) then
       if ( dtype == 'REAL4' ) then
          type = File_REAL4
       else if ( dtype == 'REAL8' ) then
          type = File_REAL8
       else
          write(message,*) 'xxx Not appropriate dtype. Check!', dtype
          call Log('E', message)
       endif
    else
       type = File_REAL8
    endif

    if ( History_axis_count < History_axis_limit ) then
       History_axis_count = History_axis_count + 1
       History_axis(History_axis_count)%name  = name
       History_axis(History_axis_count)%desc  = desc
       History_axis(History_axis_count)%units = units
       History_axis(History_axis_count)%dim   = dim
       History_axis(History_axis_count)%type  = type
       allocate(History_axis(History_axis_count)%var(size(var)))
       History_axis(History_axis_count)%var = var
       if ( present(down) ) then
          History_axis(History_axis_count)%down = down
       else
          History_axis(History_axis_count)%down = .false.
       endif
    else
       write(message,*) 'xxx Number of axis exceeds the limit.'
       call Log('E', message)
    endif

    return
  end subroutine HistoryPutAxisDP

  !-----------------------------------------------------------------------------
  ! interface HistoryPutAssociatedCoordinates
  !-----------------------------------------------------------------------------
  subroutine HistoryPut1DAssociatedCoordinatesSP( &
       name,  & ! (in)
       desc,  & ! (in)
       units, & ! (in)
       dims,  & ! (in)
       var,   & ! (in)
       dtype  & ! (in) optional
       )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(SP),         intent(in) :: var(:)
    character(len=*), intent(in), optional :: dtype

    integer :: type
    !---------------------------------------------------------------------------

    if ( present(dtype) ) then
       if ( dtype == 'REAL4' ) then
          type = File_REAL4
       else if ( dtype == 'REAL8' ) then
          type = File_REAL8
       else
          write(message,*) 'xxx Not appropriate dtype. Check!', dtype
          call Log('E', message)
       endif
    else
       type = File_REAL4
    endif

    if ( History_assoc_count < History_assoc_limit ) then
       History_assoc_count = History_assoc_count + 1
       History_assoc(History_assoc_count)%name  = name
       History_assoc(History_assoc_count)%desc  = desc
       History_assoc(History_assoc_count)%units = units
       History_assoc(History_assoc_count)%dims(1:1) = dims
       History_assoc(History_assoc_count)%ndims = 1
       History_assoc(History_assoc_count)%type  = type
       allocate(History_assoc(History_assoc_count)%var(size(var)))
       History_assoc(History_assoc_count)%var = reshape(var, (/size(var)/))
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E', message)
    endif

    return
  end subroutine HistoryPut1DAssociatedCoordinatesSP
  subroutine HistoryPut1DAssociatedCoordinatesDP( &
       name,  & ! (in)
       desc,  & ! (in)
       units, & ! (in)
       dims,  & ! (in)
       var,   & ! (in)
       dtype  & ! (in) optional
       )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(DP),         intent(in) :: var(:)
    character(len=*), intent(in), optional :: dtype

    integer :: type
    !---------------------------------------------------------------------------

    if ( present(dtype) ) then
       if ( dtype == 'REAL4' ) then
          type = File_REAL4
       else if ( dtype == 'REAL8' ) then
          type = File_REAL8
       else
          write(message,*) 'xxx Not appropriate dtype. Check!', dtype
          call Log('E', message)
       endif
    else
       type = File_REAL8
    endif

    if ( History_assoc_count < History_assoc_limit ) then
       History_assoc_count = History_assoc_count + 1
       History_assoc(History_assoc_count)%name  = name
       History_assoc(History_assoc_count)%desc  = desc
       History_assoc(History_assoc_count)%units = units
       History_assoc(History_assoc_count)%dims(1:1) = dims
       History_assoc(History_assoc_count)%ndims = 1
       History_assoc(History_assoc_count)%type  = type
       allocate(History_assoc(History_assoc_count)%var(size(var)))
       History_assoc(History_assoc_count)%var = reshape(var, (/size(var)/))
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E', message)
    endif

    return
  end subroutine HistoryPut1DAssociatedCoordinatesDP
  subroutine HistoryPut2DAssociatedCoordinatesSP( &
       name,  & ! (in)
       desc,  & ! (in)
       units, & ! (in)
       dims,  & ! (in)
       var,   & ! (in)
       dtype  & ! (in) optional
       )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(SP),         intent(in) :: var(:,:)
    character(len=*), intent(in), optional :: dtype

    integer :: type
    !---------------------------------------------------------------------------

    if ( present(dtype) ) then
       if ( dtype == 'REAL4' ) then
          type = File_REAL4
       else if ( dtype == 'REAL8' ) then
          type = File_REAL8
       else
          write(message,*) 'xxx Not appropriate dtype. Check!', dtype
          call Log('E', message)
       endif
    else
       type = File_REAL4
    endif

    if ( History_assoc_count < History_assoc_limit ) then
       History_assoc_count = History_assoc_count + 1
       History_assoc(History_assoc_count)%name  = name
       History_assoc(History_assoc_count)%desc  = desc
       History_assoc(History_assoc_count)%units = units
       History_assoc(History_assoc_count)%dims(1:2) = dims
       History_assoc(History_assoc_count)%ndims = 2
       History_assoc(History_assoc_count)%type  = type
       allocate(History_assoc(History_assoc_count)%var(size(var)))
       History_assoc(History_assoc_count)%var = reshape(var, (/size(var)/))
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E', message)
    endif

    return
  end subroutine HistoryPut2DAssociatedCoordinatesSP
  subroutine HistoryPut2DAssociatedCoordinatesDP( &
       name,  & ! (in)
       desc,  & ! (in)
       units, & ! (in)
       dims,  & ! (in)
       var,   & ! (in)
       dtype  & ! (in) optional
       )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(DP),         intent(in) :: var(:,:)
    character(len=*), intent(in), optional :: dtype

    integer :: type
    !---------------------------------------------------------------------------

    if ( present(dtype) ) then
       if ( dtype == 'REAL4' ) then
          type = File_REAL4
       else if ( dtype == 'REAL8' ) then
          type = File_REAL8
       else
          write(message,*) 'xxx Not appropriate dtype. Check!', dtype
          call Log('E', message)
       endif
    else
       type = File_REAL8
    endif

    if ( History_assoc_count < History_assoc_limit ) then
       History_assoc_count = History_assoc_count + 1
       History_assoc(History_assoc_count)%name  = name
       History_assoc(History_assoc_count)%desc  = desc
       History_assoc(History_assoc_count)%units = units
       History_assoc(History_assoc_count)%dims(1:2) = dims
       History_assoc(History_assoc_count)%ndims = 2
       History_assoc(History_assoc_count)%type  = type
       allocate(History_assoc(History_assoc_count)%var(size(var)))
       History_assoc(History_assoc_count)%var = reshape(var, (/size(var)/))
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E', message)
    endif

    return
  end subroutine HistoryPut2DAssociatedCoordinatesDP
  subroutine HistoryPut3DAssociatedCoordinatesSP( &
       name,  & ! (in)
       desc,  & ! (in)
       units, & ! (in)
       dims,  & ! (in)
       var,   & ! (in)
       dtype  & ! (in) optional
       )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(SP),         intent(in) :: var(:,:,:)
    character(len=*), intent(in), optional :: dtype

    integer :: type
    !---------------------------------------------------------------------------

    if ( present(dtype) ) then
       if ( dtype == 'REAL4' ) then
          type = File_REAL4
       else if ( dtype == 'REAL8' ) then
          type = File_REAL8
       else
          write(message,*) 'xxx Not appropriate dtype. Check!', dtype
          call Log('E', message)
       endif
    else
       type = File_REAL4
    endif

    if ( History_assoc_count < History_assoc_limit ) then
       History_assoc_count = History_assoc_count + 1
       History_assoc(History_assoc_count)%name  = name
       History_assoc(History_assoc_count)%desc  = desc
       History_assoc(History_assoc_count)%units = units
       History_assoc(History_assoc_count)%dims(1:3) = dims
       History_assoc(History_assoc_count)%ndims = 3
       History_assoc(History_assoc_count)%type  = type
       allocate(History_assoc(History_assoc_count)%var(size(var)))
       History_assoc(History_assoc_count)%var = reshape(var, (/size(var)/))
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E', message)
    endif

    return
  end subroutine HistoryPut3DAssociatedCoordinatesSP
  subroutine HistoryPut3DAssociatedCoordinatesDP( &
       name,  & ! (in)
       desc,  & ! (in)
       units, & ! (in)
       dims,  & ! (in)
       var,   & ! (in)
       dtype  & ! (in) optional
       )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(DP),         intent(in) :: var(:,:,:)
    character(len=*), intent(in), optional :: dtype

    integer :: type
    !---------------------------------------------------------------------------

    if ( present(dtype) ) then
       if ( dtype == 'REAL4' ) then
          type = File_REAL4
       else if ( dtype == 'REAL8' ) then
          type = File_REAL8
       else
          write(message,*) 'xxx Not appropriate dtype. Check!', dtype
          call Log('E', message)
       endif
    else
       type = File_REAL8
    endif

    if ( History_assoc_count < History_assoc_limit ) then
       History_assoc_count = History_assoc_count + 1
       History_assoc(History_assoc_count)%name  = name
       History_assoc(History_assoc_count)%desc  = desc
       History_assoc(History_assoc_count)%units = units
       History_assoc(History_assoc_count)%dims(1:3) = dims
       History_assoc(History_assoc_count)%ndims = 3
       History_assoc(History_assoc_count)%type  = type
       allocate(History_assoc(History_assoc_count)%var(size(var)))
       History_assoc(History_assoc_count)%var = reshape(var, (/size(var)/))
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E', message)
    endif

    return
  end subroutine HistoryPut3DAssociatedCoordinatesDP
  subroutine HistoryPut4DAssociatedCoordinatesSP( &
       name,  & ! (in)
       desc,  & ! (in)
       units, & ! (in)
       dims,  & ! (in)
       var,   & ! (in)
       dtype  & ! (in) optional
       )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(SP),         intent(in) :: var(:,:,:,:)
    character(len=*), intent(in), optional :: dtype

    integer :: type
    !---------------------------------------------------------------------------

    if ( present(dtype) ) then
       if ( dtype == 'REAL4' ) then
          type = File_REAL4
       else if ( dtype == 'REAL8' ) then
          type = File_REAL8
       else
          write(message,*) 'xxx Not appropriate dtype. Check!', dtype
          call Log('E', message)
       endif
    else
       type = File_REAL4
    endif

    if ( History_assoc_count < History_assoc_limit ) then
       History_assoc_count = History_assoc_count + 1
       History_assoc(History_assoc_count)%name  = name
       History_assoc(History_assoc_count)%desc  = desc
       History_assoc(History_assoc_count)%units = units
       History_assoc(History_assoc_count)%dims(1:4) = dims
       History_assoc(History_assoc_count)%ndims = 4
       History_assoc(History_assoc_count)%type  = type
       allocate(History_assoc(History_assoc_count)%var(size(var)))
       History_assoc(History_assoc_count)%var = reshape(var, (/size(var)/))
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E', message)
    endif

    return
  end subroutine HistoryPut4DAssociatedCoordinatesSP
  subroutine HistoryPut4DAssociatedCoordinatesDP( &
       name,  & ! (in)
       desc,  & ! (in)
       units, & ! (in)
       dims,  & ! (in)
       var,   & ! (in)
       dtype  & ! (in) optional
       )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(DP),         intent(in) :: var(:,:,:,:)
    character(len=*), intent(in), optional :: dtype

    integer :: type
    !---------------------------------------------------------------------------

    if ( present(dtype) ) then
       if ( dtype == 'REAL4' ) then
          type = File_REAL4
       else if ( dtype == 'REAL8' ) then
          type = File_REAL8
       else
          write(message,*) 'xxx Not appropriate dtype. Check!', dtype
          call Log('E', message)
       endif
    else
       type = File_REAL8
    endif

    if ( History_assoc_count < History_assoc_limit ) then
       History_assoc_count = History_assoc_count + 1
       History_assoc(History_assoc_count)%name  = name
       History_assoc(History_assoc_count)%desc  = desc
       History_assoc(History_assoc_count)%units = units
       History_assoc(History_assoc_count)%dims(1:4) = dims
       History_assoc(History_assoc_count)%ndims = 4
       History_assoc(History_assoc_count)%type  = type
       allocate(History_assoc(History_assoc_count)%var(size(var)))
       History_assoc(History_assoc_count)%var = reshape(var, (/size(var)/))
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E', message)
    endif

    return
  end subroutine HistoryPut4DAssociatedCoordinatesDP

  !-----------------------------------------------------------------------------
  ! HistorySetTAttr
  subroutine HistorySetTAttr( &
       varname, &
       key,     &
       val      )
    use gtool_file, only: &
       FileSetTAttr
    implicit none

    character(len=*), intent(in) :: varname
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer :: n
    !---------------------------------------------------------------------------

    do n = 1, History_id_count
       call FileSetTAttr( History_fid(n), & ! (in)
                          varname,        & ! (in)
                          key,            & ! (in)
                          val             ) ! (in)
    enddo

  end subroutine HistorySetTAttr

  !-----------------------------------------------------------------------------
  ! HistoryQuery
  subroutine HistoryQuery( &
       itemid,    &
       step_next, &
       answer     )
    implicit none

    integer, intent(in)  :: itemid
    integer, intent(in)  :: step_next
    logical, intent(out) :: answer
    !---------------------------------------------------------------------------

    answer = .false.

    if    ( History_tavg(itemid) ) then
       answer = .true.
    elseif( step_next == History_tstrstep(itemid) + History_tintstep(itemid) ) then
       answer = .true.
    endif

    return
  end subroutine HistoryQuery

  !-----------------------------------------------------------------------------
  ! interface HistoryPut(by NAME)
  subroutine HistoryPut1DNameSP( &
       varname,   &
       step_next, &
       var        )
    implicit none

    character(len=*), intent(in) :: varname
    integer,          intent(in) :: step_next
    real(SP),         intent(in) :: var(:)

    integer :: itemid, n
    !---------------------------------------------------------------------------

    ! search item id
    itemid = -1
    do n = 1, History_id_count
       if ( varname == History_item(n) ) then
          itemid = n
          exit
       endif
    enddo

    call HistoryPut1DIdSP(itemid, step_next, var)

    return
  end subroutine HistoryPut1DNameSP

  !-----------------------------------------------------------------------------
  ! interface HistoryPut(by ID)
  subroutine HistoryPut1DIdSP( &
       itemid,    &
       step_next, &
       var        )
    implicit none

    integer,  intent(in) :: itemid
    integer,  intent(in) :: step_next
    real(SP), intent(in) :: var(:)

    real(DP) :: dt
    integer  :: ijk(1), idx
    integer  :: i
    intrinsic shape
    !---------------------------------------------------------------------------

    if ( itemid < 0 ) return

    ijk = shape(var)
    dt  = ( step_next - History_tlststep(itemid) ) * HISTORY_DTSEC

    if ( dt < eps .AND. ( .NOT. History_tavg(itemid) ) ) then
       write(message,*) 'xxx History variable was put two times before output!: ', &
                        trim(History_item(itemid)), &
                        step_next, History_tlststep(itemid)
       call Log('E', message)
    endif

    if ( History_tavg(itemid) ) then
       do i = 1, ijk(1)
          idx = i

          History_varsum(idx,itemid) = History_varsum(idx,itemid) + var(i) * dt
       enddo
    else
       do i = 1, ijk(1)
          idx = i

          History_varsum(idx,itemid) = var(i)
       enddo
    endif

    History_size    (itemid) = idx
    History_tlststep(itemid) = step_next
    History_tsumsec (itemid) = History_tsumsec(itemid) + dt

    return
  end subroutine HistoryPut1DIdSP
  subroutine HistoryPut1DNameDP( &
       varname,   &
       step_next, &
       var        )
    implicit none

    character(len=*), intent(in) :: varname
    integer,          intent(in) :: step_next
    real(DP),         intent(in) :: var(:)

    integer :: itemid, n
    !---------------------------------------------------------------------------

    ! search item id
    itemid = -1
    do n = 1, History_id_count
       if ( varname == History_item(n) ) then
          itemid = n
          exit
       endif
    enddo

    call HistoryPut1DIdDP(itemid, step_next, var)

    return
  end subroutine HistoryPut1DNameDP

  !-----------------------------------------------------------------------------
  ! interface HistoryPut(by ID)
  subroutine HistoryPut1DIdDP( &
       itemid,    &
       step_next, &
       var        )
    implicit none

    integer,  intent(in) :: itemid
    integer,  intent(in) :: step_next
    real(DP), intent(in) :: var(:)

    real(DP) :: dt
    integer  :: ijk(1), idx
    integer  :: i
    intrinsic shape
    !---------------------------------------------------------------------------

    if ( itemid < 0 ) return

    ijk = shape(var)
    dt  = ( step_next - History_tlststep(itemid) ) * HISTORY_DTSEC

    if ( dt < eps .AND. ( .NOT. History_tavg(itemid) ) ) then
       write(message,*) 'xxx History variable was put two times before output!: ', &
                        trim(History_item(itemid)), &
                        step_next, History_tlststep(itemid)
       call Log('E', message)
    endif

    if ( History_tavg(itemid) ) then
       do i = 1, ijk(1)
          idx = i

          History_varsum(idx,itemid) = History_varsum(idx,itemid) + var(i) * dt
       enddo
    else
       do i = 1, ijk(1)
          idx = i

          History_varsum(idx,itemid) = var(i)
       enddo
    endif

    History_size    (itemid) = idx
    History_tlststep(itemid) = step_next
    History_tsumsec (itemid) = History_tsumsec(itemid) + dt

    return
  end subroutine HistoryPut1DIdDP
  subroutine HistoryPut2DNameSP( &
       varname,   &
       step_next, &
       var        )
    implicit none

    character(len=*), intent(in) :: varname
    integer,          intent(in) :: step_next
    real(SP),         intent(in) :: var(:,:)

    integer :: itemid, n
    !---------------------------------------------------------------------------

    ! search item id
    itemid = -1
    do n = 1, History_id_count
       if ( varname == History_item(n) ) then
          itemid = n
          exit
       endif
    enddo

    call HistoryPut2DIdSP(itemid, step_next, var)

    return
  end subroutine HistoryPut2DNameSP

  !-----------------------------------------------------------------------------
  ! interface HistoryPut(by ID)
  subroutine HistoryPut2DIdSP( &
       itemid,    &
       step_next, &
       var        )
    implicit none

    integer,  intent(in) :: itemid
    integer,  intent(in) :: step_next
    real(SP), intent(in) :: var(:,:)

    real(DP) :: dt
    integer  :: ijk(2), idx
    integer  :: i, j
    intrinsic shape
    !---------------------------------------------------------------------------

    if ( itemid < 0 ) return

    ijk = shape(var)
    dt  = ( step_next - History_tlststep(itemid) ) * HISTORY_DTSEC

    if ( dt < eps .AND. ( .NOT. History_tavg(itemid) ) ) then
       write(message,*) 'xxx History variable was put two times before output!: ', &
                        trim(History_item(itemid)), &
                        step_next, History_tlststep(itemid)
       call Log('E', message)
    endif

    if ( History_tavg(itemid) ) then
       do j = 1, ijk(2)
       do i = 1, ijk(1)
          idx = j*ijk(i)+i

          History_varsum(idx,itemid) = History_varsum(idx,itemid) + var(i,j) * dt
       enddo
       enddo
    else
       do j = 1, ijk(2)
       do i = 1, ijk(1)
          idx = j*ijk(i)+i

          History_varsum(idx,itemid) = var(i,j)
       enddo
       enddo
    endif

    History_size    (itemid) = idx
    History_tlststep(itemid) = step_next
    History_tsumsec (itemid) = History_tsumsec(itemid) + dt

    return
  end subroutine HistoryPut2DIdSP
  subroutine HistoryPut2DNameDP( &
       varname,   &
       step_next, &
       var        )
    implicit none

    character(len=*), intent(in) :: varname
    integer,          intent(in) :: step_next
    real(DP),         intent(in) :: var(:,:)

    integer :: itemid, n
    !---------------------------------------------------------------------------

    ! search item id
    itemid = -1
    do n = 1, History_id_count
       if ( varname == History_item(n) ) then
          itemid = n
          exit
       endif
    enddo

    call HistoryPut2DIdDP(itemid, step_next, var)

    return
  end subroutine HistoryPut2DNameDP

  !-----------------------------------------------------------------------------
  ! interface HistoryPut(by ID)
  subroutine HistoryPut2DIdDP( &
       itemid,    &
       step_next, &
       var        )
    implicit none

    integer,  intent(in) :: itemid
    integer,  intent(in) :: step_next
    real(DP), intent(in) :: var(:,:)

    real(DP) :: dt
    integer  :: ijk(2), idx
    integer  :: i, j
    intrinsic shape
    !---------------------------------------------------------------------------

    if ( itemid < 0 ) return

    ijk = shape(var)
    dt  = ( step_next - History_tlststep(itemid) ) * HISTORY_DTSEC

    if ( dt < eps .AND. ( .NOT. History_tavg(itemid) ) ) then
       write(message,*) 'xxx History variable was put two times before output!: ', &
                        trim(History_item(itemid)), &
                        step_next, History_tlststep(itemid)
       call Log('E', message)
    endif

    if ( History_tavg(itemid) ) then
       do j = 1, ijk(2)
       do i = 1, ijk(1)
          idx = j*ijk(i)+i

          History_varsum(idx,itemid) = History_varsum(idx,itemid) + var(i,j) * dt
       enddo
       enddo
    else
       do j = 1, ijk(2)
       do i = 1, ijk(1)
          idx = j*ijk(i)+i

          History_varsum(idx,itemid) = var(i,j)
       enddo
       enddo
    endif

    History_size    (itemid) = idx
    History_tlststep(itemid) = step_next
    History_tsumsec (itemid) = History_tsumsec(itemid) + dt

    return
  end subroutine HistoryPut2DIdDP
  subroutine HistoryPut3DNameSP( &
       varname,   &
       step_next, &
       var        )
    implicit none

    character(len=*), intent(in) :: varname
    integer,          intent(in) :: step_next
    real(SP),         intent(in) :: var(:,:,:)

    integer :: itemid, n
    !---------------------------------------------------------------------------

    ! search item id
    itemid = -1
    do n = 1, History_id_count
       if ( varname == History_item(n) ) then
          itemid = n
          exit
       endif
    enddo

    call HistoryPut3DIdSP(itemid, step_next, var)

    return
  end subroutine HistoryPut3DNameSP

  !-----------------------------------------------------------------------------
  ! interface HistoryPut(by ID)
  subroutine HistoryPut3DIdSP( &
       itemid,    &
       step_next, &
       var        )
    implicit none

    integer,  intent(in) :: itemid
    integer,  intent(in) :: step_next
    real(SP), intent(in) :: var(:,:,:)

    real(DP) :: dt
    integer  :: ijk(3), idx
    integer  :: i, j, k
    intrinsic shape
    !---------------------------------------------------------------------------

    if ( itemid < 0 ) return

    ijk = shape(var)
    dt  = ( step_next - History_tlststep(itemid) ) * HISTORY_DTSEC

    if ( dt < eps .AND. ( .NOT. History_tavg(itemid) ) ) then
       write(message,*) 'xxx History variable was put two times before output!: ', &
                        trim(History_item(itemid)), &
                        step_next, History_tlststep(itemid)
       call Log('E', message)
    endif

    if ( History_tavg(itemid) ) then
       do k = 1, ijk(3)
       do j = 1, ijk(2)
       do i = 1, ijk(1)
          idx = (k*ijk(2)+j)*ijk(1)+i

          History_varsum(idx,itemid) = History_varsum(idx,itemid) + var(i,j,k) * dt
       enddo
       enddo
       enddo
    else
       do k = 1, ijk(3)
       do j = 1, ijk(2)
       do i = 1, ijk(1)
          idx = (k*ijk(2)+j)*ijk(1)+i

          History_varsum(idx,itemid) = var(i,j,k)
       enddo
       enddo
       enddo
    endif

    History_size    (itemid) = idx
    History_tlststep(itemid) = step_next
    History_tsumsec (itemid) = History_tsumsec(itemid) + dt

    return
  end subroutine HistoryPut3DIdSP
  subroutine HistoryPut3DNameDP( &
       varname,   &
       step_next, &
       var        )
    implicit none

    character(len=*), intent(in) :: varname
    integer,          intent(in) :: step_next
    real(DP),         intent(in) :: var(:,:,:)

    integer :: itemid, n
    !---------------------------------------------------------------------------

    ! search item id
    itemid = -1
    do n = 1, History_id_count
       if ( varname == History_item(n) ) then
          itemid = n
          exit
       endif
    enddo

    call HistoryPut3DIdDP(itemid, step_next, var)

    return
  end subroutine HistoryPut3DNameDP

  !-----------------------------------------------------------------------------
  ! interface HistoryPut(by ID)
  subroutine HistoryPut3DIdDP( &
       itemid,    &
       step_next, &
       var        )
    implicit none

    integer,  intent(in) :: itemid
    integer,  intent(in) :: step_next
    real(DP), intent(in) :: var(:,:,:)

    real(DP) :: dt
    integer  :: ijk(3), idx
    integer  :: i, j, k
    intrinsic shape
    !---------------------------------------------------------------------------

    if ( itemid < 0 ) return

    ijk = shape(var)
    dt  = ( step_next - History_tlststep(itemid) ) * HISTORY_DTSEC

    if ( dt < eps .AND. ( .NOT. History_tavg(itemid) ) ) then
       write(message,*) 'xxx History variable was put two times before output!: ', &
                        trim(History_item(itemid)), &
                        step_next, History_tlststep(itemid)
       call Log('E', message)
    endif

    if ( History_tavg(itemid) ) then
       do k = 1, ijk(3)
       do j = 1, ijk(2)
       do i = 1, ijk(1)
          idx = (k*ijk(2)+j)*ijk(1)+i

          History_varsum(idx,itemid) = History_varsum(idx,itemid) + var(i,j,k) * dt
       enddo
       enddo
       enddo
    else
       do k = 1, ijk(3)
       do j = 1, ijk(2)
       do i = 1, ijk(1)
          idx = (k*ijk(2)+j)*ijk(1)+i

          History_varsum(idx,itemid) = var(i,j,k)
       enddo
       enddo
       enddo
    endif

    History_size    (itemid) = idx
    History_tlststep(itemid) = step_next
    History_tsumsec (itemid) = History_tsumsec(itemid) + dt

    return
  end subroutine HistoryPut3DIdDP

  !-----------------------------------------------------------------------------
  ! HistoryWrite
  subroutine HistoryWrite( &
       itemid,  &
       step_now )
    use dc_calendar, only: &
       CalendarSec2ymdhms
    use gtool_file, only: &
       FileWrite
    implicit none

    integer, intent(in) :: itemid
    integer, intent(in) :: step_now

    integer  :: isize
    real(DP) :: time_str, time_end
    real(DP) :: sec_str,  sec_end

    real(DP), save :: sec_end_last = -1.0_DP
    logical,  save :: firsttime    = .true.
    !---------------------------------------------------------------------------

    if( History_id_count == 0 ) return

    if ( step_now < History_tstrstep(itemid) + History_tintstep(itemid) ) then
       return
    endif

    if ( History_tlststep(itemid) == History_tstrstep(itemid) ) then
       write(message,*) 'xxx History variable was never put after the last output!: ', &
                        trim(History_item(itemid))
       if ( HISTORY_ERROR_PUTMISS ) then
          call Log('E', message)
       else
          call Log('I', message)
       endif
    endif

    isize = History_size(itemid)

    if ( History_tavg(itemid) ) then
       History_varsum(1:isize,itemid) = History_varsum(1:isize,itemid) / History_tsumsec(itemid)
    endif

    if ( firsttime ) then
       firsttime = .false.

       call HistoryOutputList

       if ( HISTORY_OUTPUT_STEP0 ) then
          History_tstrstep(itemid) = step_now
       endif
    endif

    time_str = HISTORY_STARTDAYSEC + real(History_tstrstep(itemid)-1,kind=DP) * HISTORY_DTSEC
    time_end = HISTORY_STARTDAYSEC + real(step_now-1                ,kind=DP) * HISTORY_DTSEC

    ! convert time units
    call CalendarSec2ymdhms( sec_str, time_str, HISTORY_TIME_UNITS )
    call CalendarSec2ymdhms( sec_end, time_end, HISTORY_TIME_UNITS )

    if ( sec_end .ge.  History_tstart(itemid) ) then
       if ( sec_end_last < sec_end ) then
          write(message,'(A)') '*** Output History'
          call Log('I', message)
       endif

       call FileWrite( History_vid   (itemid),         & ! id
                       History_varsum(1:isize,itemid), & ! data
                       sec_str,                        & ! start time
                       sec_end                         ) ! end   time
    else
       if ( sec_end_last < sec_end ) then
          write(message,'(A,2F15.3)') '*** Output History: Suppressed ', sec_end, History_tstart(itemid)
          call Log('I', message)
       endif
    endif

    History_varsum(:,itemid) = 0.0_DP
    History_tstrstep(itemid) = step_now
    History_tlststep(itemid) = step_now
    History_tsumsec (itemid) = 0.0_DP

    sec_end_last = sec_end

    return
  end subroutine HistoryWrite

  !-----------------------------------------------------------------------------
  ! HistoryWritaAll
  subroutine HistoryWriteAll( &
       step_now )
    implicit none

    integer, intent(in) :: step_now

    integer :: n
    !---------------------------------------------------------------------------

    do n = 1, History_id_count
       call HistoryWrite( n, step_now )
    enddo

    return
  end subroutine HistoryWriteAll

  !-----------------------------------------------------------------------------
  ! interface HistoryGet
  subroutine HistoryGet1DDP( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use gtool_file, only: &
       FileRead
    implicit none

    real(DP),         intent(out) :: var(:)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single
    !---------------------------------------------------------------------------

    call FileRead( var,            & ! [OUT]
                   basename,       & ! [IN]
                   varname,        & ! [IN]
                   step,           & ! [IN]
                   History_myrank, & ! [IN]
                   allow_missing,  & ! [IN]
                   single          ) ! [IN]

    return
  end subroutine HistoryGet1DDP
  subroutine HistoryGet1DSP( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use gtool_file, only: &
       FileRead
    implicit none

    real(SP),         intent(out) :: var(:)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single
    !---------------------------------------------------------------------------

    call FileRead( var,            & ! [OUT]
                   basename,       & ! [IN]
                   varname,        & ! [IN]
                   step,           & ! [IN]
                   History_myrank, & ! [IN]
                   allow_missing,  & ! [IN]
                   single          ) ! [IN]

    return
  end subroutine HistoryGet1DSP
  subroutine HistoryGet2DDP( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use gtool_file, only: &
       FileRead
    implicit none

    real(DP),         intent(out) :: var(:,:)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single
    !---------------------------------------------------------------------------

    call FileRead( var,            & ! [OUT]
                   basename,       & ! [IN]
                   varname,        & ! [IN]
                   step,           & ! [IN]
                   History_myrank, & ! [IN]
                   allow_missing,  & ! [IN]
                   single          ) ! [IN]

    return
  end subroutine HistoryGet2DDP
  subroutine HistoryGet2DSP( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use gtool_file, only: &
       FileRead
    implicit none

    real(SP),         intent(out) :: var(:,:)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single
    !---------------------------------------------------------------------------

    call FileRead( var,            & ! [OUT]
                   basename,       & ! [IN]
                   varname,        & ! [IN]
                   step,           & ! [IN]
                   History_myrank, & ! [IN]
                   allow_missing,  & ! [IN]
                   single          ) ! [IN]

    return
  end subroutine HistoryGet2DSP
  subroutine HistoryGet3DDP( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use gtool_file, only: &
       FileRead
    implicit none

    real(DP),         intent(out) :: var(:,:,:)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single
    !---------------------------------------------------------------------------

    call FileRead( var,            & ! [OUT]
                   basename,       & ! [IN]
                   varname,        & ! [IN]
                   step,           & ! [IN]
                   History_myrank, & ! [IN]
                   allow_missing,  & ! [IN]
                   single          ) ! [IN]

    return
  end subroutine HistoryGet3DDP
  subroutine HistoryGet3DSP( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use gtool_file, only: &
       FileRead
    implicit none

    real(SP),         intent(out) :: var(:,:,:)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single
    !---------------------------------------------------------------------------

    call FileRead( var,            & ! [OUT]
                   basename,       & ! [IN]
                   varname,        & ! [IN]
                   step,           & ! [IN]
                   History_myrank, & ! [IN]
                   allow_missing,  & ! [IN]
                   single          ) ! [IN]

    return
  end subroutine HistoryGet3DSP

  !-----------------------------------------------------------------------------
  subroutine HistoryOutputList
    implicit none

    integer :: n
    !---------------------------------------------------------------------------

    call Log('I', '')
    write(message,*) '*** [HIST] Output item list '
    call Log('I', message)
    write(message,*) '*** Number of history item :', History_req_nmax
    call Log('I', message)
    write(message,*) 'NAME            :size    :interval[sec]:  [step]:timeavg?:zinterp?'
    call Log('I', message)
    write(message,*) '============================================================================'
    call Log('I', message)

    do n = 1, History_id_count
       write(message,'(1x,A,1x,I8,1x,f13.3,1x,I8,1x,L8,1x,L8)') &
                     History_item(n), History_size(n), History_tintsec(n), History_tintstep(n), History_tavg(n), History_zinterp(n)
       call Log('I', message)
    enddo

    write(message,*) '============================================================================'
    call Log('I', message)
    call Log('I', '')

    return
  end subroutine HistoryOutputList

  !-----------------------------------------------------------------------------
  subroutine HistoryFinalize
    use gtool_file, only: &
       FileClose
    implicit none

    integer :: n
    !---------------------------------------------------------------------------

    do n = 1, History_id_count
       call FileClose( History_fid(n) )
    enddo

    return
  end subroutine HistoryFinalize

end module gtool_history
!-------------------------------------------------------------------------------



!--
! vi:set readonly sw=4 ts=8
!
!Local Variables:
!mode: f90
!buffer-read-only:t
!End:
!
!++
