% # -*- f90 -*-
% # vi: set sw=4 ts=8:
!-------------------------------------------------------------------------------
!> module Gtool_History
!!
!! @par Description
!!          module library for history output
!!
!! @author Team SCALE
!!
!! @par History
!! @li      2012-06-11 (S.Nishizawa)  [new] imported from SCALE-LES
!!
!<
!-------------------------------------------------------------------------------
! Warning: This file was generated from <%=__FILE__%>.
!          Do not edit this file.
!-------------------------------------------------------------------------------
module gtool_history
  !-----------------------------------------------------------------------------
  !
  !++ Used modules
  !
  use dc_log, only: &
     Log, &
#if defined(__PGI) || defined(__ES2)
     LOG_fid, &
#endif
     LOG_LMSG
  use dc_types, only: &
     SP, &
     DP
  use gtool_file_h, only: &
     File_HLONG, &
     File_HSHORT, &
     File_HMID
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedures
  !
  public :: HistoryInit
  public :: HistoryCheck
  public :: HistoryAddVariable
  public :: HistoryPutAxis
  public :: HistoryPutAssociatedCoordinates
  public :: HistorySetTAttr
  public :: HistoryQuery
  public :: HistoryPut
  public :: HistoryWriteAll
  public :: HistoryWriteAxes
  public :: HistoryWrite
  public :: HistoryGet
  public :: HistoryOutputList
  public :: HistoryFinalize

  interface HistoryPutAxis
     module procedure HistoryPutAxisSP
     module procedure HistoryPutAxisDP
  end interface HistoryPutAxis

  interface HistoryPutAssociatedCoordinates
%  for n in 1..4
%  %w(SP DP).each do |rp|
     module procedure HistoryPut<%=n%>DAssociatedCoordinates<%=rp%>
%  end
%  end
  end interface HistoryPutAssociatedCoordinates

  interface HistoryPut
%  for n in 0..3
%  ["SP","DP"].each do |rp|
     module procedure HistoryPut<%=n%>DId<%=rp%>
%  end
%  end
  end interface HistoryPut

  interface HistoryGet
%  for n in 1..3
%  ["SP","DP"].each do |rp|
     module procedure HistoryGet<%=n%>D<%=rp%>
%  end
%  end
  end interface HistoryGet

  type request
     character(len=File_HSHORT) :: item           !> Name of variable (in the code)
     character(len=File_HMID)   :: zcoord         !> Z-coordinate
     character(len=File_HSHORT) :: outname        !> Name of variable (for output)
     character(len=File_HLONG)  :: basename       !> Base name of the file
     integer                    :: dstep          !> Time unit
     logical                    :: taverage       !> Apply time average?
     integer                    :: dtype          !> Data type
  end type request

  type vars
     character(len=File_HSHORT) :: item           !> Name of variable (in the code)
     character(len=File_HMID)   :: zcoord         !> Z-coordinate
     character(len=File_HSHORT) :: outname        !> Name of variable (for output)
     integer                    :: fid            !> File id of the file
     integer                    :: dstep          !> Time unit
     logical                    :: taverage       !> Apply time average?
     logical                    :: axis_written   !> Axis for this item is already written?
     integer                    :: vid            !> Variable id

     real(DP)                   :: waitsec        !> Time length to suppress output [sec]
     integer                    :: laststep_write !> Last step when the variable is written
     integer                    :: laststep_put   !> Last step when the variable is put
     integer                    :: size           !> Size of array
     real(DP)                   :: timesum        !> Buffer for time
     real(DP), pointer          :: varsum(:)      !> Buffer for value
     integer                    :: ndims          !> Number of dimension
     integer                    :: start(4)
     integer                    :: count(4)
  end type vars

  type axis
     integer                    :: id
     character(len=File_HSHORT) :: name
     character(len=File_HLONG)  :: desc
     character(len=File_HSHORT) :: units
     character(len=File_HSHORT) :: dim
     integer                    :: dtype
     integer                    :: dim_size
     real(DP), pointer          :: var(:)
     logical                    :: down
     integer                    :: gdim_size  ! global dimension size
     integer                    :: start      ! global array start index
  end type axis

  type assoc
     integer                    :: id
     character(len=File_HSHORT) :: name
     character(len=File_HLONG)  :: desc
     character(len=File_HSHORT) :: units
     integer                    :: ndims
     character(len=File_HSHORT) :: dims(4)
     integer                    :: dtype
     real(DP), pointer          :: var(:)
     integer                    :: start(4)   ! global array start indices
     integer                    :: count(4)   ! global array request lengths
  end type assoc

  !-----------------------------------------------------------------------------
  !
  !++ included parameters
  !
  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private procedures
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private parameters & variables
  !

  ! From upstream side of the library
  integer,                    private              :: History_master                    !> Number of master rank
  integer,                    private              :: History_myrank                    !> Number of my rank
  integer,                    private, allocatable :: History_rankidx(:)                !> Index number in the 2D rank mesh

  real(DP),                   private              :: History_STARTDAYSEC               !> Start date [second]
  real(DP),                   private              :: History_DTSEC                     !> Delta t    [second]
  character(len=File_HMID),   private              :: History_TIME_SINCE    = ''        !> Offset time

  ! From NAMELIST or upstream side of the library
  character(len=File_HMID),   private              :: History_TITLE                     !> Header information of the output file: title
  character(len=File_HMID),   private              :: History_SOURCE                    !> Header information of the output file: model name
  character(len=File_HMID),   private              :: History_INSTITUTION               !> Header information of the output file: institution
  character(len=File_HMID),   private              :: History_TIME_UNITS    = 'seconds' !> Unit for time axis

  logical,                    private              :: History_OUTPUT_STEP0  = .false.   !> Output value at step=0?
  real(DP),                   private              :: History_OUTPUT_WAIT   = 0.0_DP    !> Time length to suppress output [sec]

  logical,                    private              :: History_ERROR_PUTMISS = .true.   !> Abort if the value is never stored after last output?

  ! working
  integer,                    private, parameter   :: History_req_limit     = 1000      !> number limit for history item request
  integer,                    private              :: History_req_count     = 0         !> number of requested item
  type(request),              private, allocatable :: History_req(:)

  integer,                    private              :: History_id_count      = 0         !> number of registered item
  type(vars),                 private, allocatable :: History_vars(:)

  integer,                    private, parameter   :: History_axis_limit    = 100       !> number limit of axes
  integer,                    private              :: History_axis_count    =   0
  type(axis),                 private              :: History_axis(History_axis_limit)

  integer,                    private, parameter   :: History_assoc_limit   = 20        !> number limit of associated coordinates
  integer,                    private              :: History_assoc_count   =  0
  type(assoc),                private              :: History_assoc(History_assoc_limit)

  real(DP),                   private, parameter   :: eps                   = 1.D-10    !> epsilon for timesec

  integer,                    private              :: laststep_write = -1
  logical,                    private              :: firsttime      = .true.
  character(LEN=LOG_LMSG),    private              :: message        = ''
  logical,                    private              :: debug          = .false.

  integer,                    private              :: io_buffer_size

contains
  !-----------------------------------------------------------------------------
  subroutine HistoryInit( &
       item_count,        &
       variant_count,     &
       isize,             &
       jsize,             &
       ksize,             &
       master,            &
       myrank,            &
       rankidx,           &
       title,             &
       source,            &
       institution,       &
       time_start,        &
       time_interval,     &
       time_units,        &
       time_since,        &
       default_basename,  &
       default_zcoord,    &
       default_tinterval, &
       default_tunit,     &
       default_taverage,  &
       default_datatype,  &
       namelist_filename, &
       namelist_fid       )
    use dc_calendar, only: &
       CalendarYmdhms2sec
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8, &
       File_preclist
    implicit none

    integer,          intent(out)          :: item_count
    integer,          intent(out)          :: variant_count
    integer,          intent(in)           :: isize
    integer,          intent(in)           :: jsize
    integer,          intent(in)           :: ksize
    integer,          intent(in)           :: master
    integer,          intent(in)           :: myrank
    integer,          intent(in)           :: rankidx(:)
    character(len=*), intent(in)           :: title
    character(len=*), intent(in)           :: source
    character(len=*), intent(in)           :: institution
    real(DP),         intent(in)           :: time_start
    real(DP),         intent(in)           :: time_interval
    character(len=*), intent(in), optional :: time_units
    character(len=*), intent(in), optional :: time_since
    character(len=*), intent(in), optional :: default_basename
    character(len=*), intent(in), optional :: default_zcoord
    real(DP),         intent(in), optional :: default_tinterval
    character(len=*), intent(in), optional :: default_tunit
    logical,          intent(in), optional :: default_taverage
    character(len=*), intent(in), optional :: default_datatype
    character(len=*), intent(in), optional :: namelist_filename
    integer         , intent(in), optional :: namelist_fid

    character(len=File_HLONG)  :: History_DEFAULT_BASENAME  = ''       !> base name of the file
    real(DP)                   :: History_DEFAULT_TINTERVAL = -1.0_DP  !> time interval
    character(len=File_HSHORT) :: History_DEFAULT_TUNIT     = 'sec'    !> time unit
    logical                    :: History_DEFAULT_TAVERAGE  = .false.  !> apply time average?
    character(len=File_HSHORT) :: History_DEFAULT_ZCOORD    = ''       !> default z-coordinate
    character(len=File_HSHORT) :: History_DEFAULT_DATATYPE  = 'REAL4'  !> data type
                                                                       !> REAL4 : single precision
                                                                       !> REAL8 : double precision

    NAMELIST / PARAM_HISTORY / &
       History_TITLE,             &
       History_SOURCE,            &
       History_INSTITUTION,       &
       History_TIME_UNITS,        &
       History_DEFAULT_BASENAME,  &
       History_DEFAULT_TINTERVAL, &
       History_DEFAULT_TUNIT,     &
       History_DEFAULT_TAVERAGE,  &
       History_DEFAULT_ZCOORD,    &
       History_DEFAULT_DATATYPE,  &
       History_OUTPUT_STEP0,      &
       History_OUTPUT_WAIT,       &
       History_ERROR_PUTMISS,     &
       debug

    character(len=File_HSHORT) :: ITEM      !> name of variable (in the code)
    character(len=File_HSHORT) :: OUTNAME   !> name of variable (for output)

    character(len=File_HLONG)  :: BASENAME  !> base name of the file
    real(DP)                   :: TINTERVAL !> time interval
    character(len=File_HSHORT) :: TUNIT     !> time unit
    logical                    :: TAVERAGE  !> apply time average?
    character(len=File_HSHORT) :: ZCOORD    !> z-coordinate
    character(len=File_HSHORT) :: DATATYPE  !> data type

    NAMELIST / HISTITEM / &
       ITEM,      &
       OUTNAME,   &
       BASENAME,  &
       TINTERVAL, &
       TUNIT,     &
       TAVERAGE,  &
       ZCOORD,    &
       DATATYPE

    integer  :: array_size
    integer  :: memsize
    integer  :: reqid
    real(DP) :: item_dtsec
    integer  :: item_dstep

    integer                    :: id1, id2, count
    character(len=File_HSHORT) :: item1, item2

    integer  :: fid, ierr
    integer  :: n, k, id

    intrinsic size
    !---------------------------------------------------------------------------

    call Log('I','')
    call Log('I','+++ Module[HISTORY]/Categ[GTOOL]')

    ! setup
    allocate( History_rankidx(size(rankidx)) )
    History_master      = master
    History_myrank      = myrank
    History_rankidx(:)  = rankidx(:)

    History_STARTDAYSEC = time_start
    History_DTSEC       = time_interval
    if( present(time_since) ) History_TIME_SINCE = time_since

    !--- read namelist
    History_TITLE       = title
    History_SOURCE      = source
    History_INSTITUTION = institution
    if( present(time_units)        ) History_TIME_UNITS        = time_units
    if( present(default_basename)  ) History_DEFAULT_BASENAME  = default_basename
    if( present(default_tinterval) ) History_DEFAULT_TINTERVAL = default_tinterval
    if( present(default_tunit)     ) History_DEFAULT_TUNIT     = default_tunit
    if( present(default_taverage)  ) History_DEFAULT_TAVERAGE  = default_taverage
    if( present(default_zcoord)    ) History_DEFAULT_ZCOORD    = default_zcoord
    if( present(default_datatype)  ) History_DEFAULT_DATATYPE  = default_datatype

    fid = -1
    if ( present(namelist_fid) ) then
       fid = namelist_fid
    elseif( present(namelist_filename) ) then
       if ( namelist_filename /= '' ) then
          open( unit   = fid,                     &
                file   = trim(namelist_filename), &
                form   = 'formatted',             &
                status = 'old'                    )
       endif
    endif

    if ( fid <= 0 ) then
       call Log('E','xxx No namelist file is specified. Check!')
    endif

    rewind(fid)
    read(fid,nml=PARAM_HISTORY,iostat=ierr)
    if    ( ierr < 0 ) then !--- missing
       call Log('I','*** Not found namelist. Default used.')
    elseif( ierr > 0 ) then !--- fatal error
       call Log('E','xxx Not appropriate names in namelist PARAM_HISTORY. Check!')
    endif
#if defined(__PGI) || defined(__ES2)
    write(LOG_fid,nml=PARAM_HISTORY)
#else
    write(message,nml=PARAM_HISTORY)
    call Log('I',message)
#endif

    if ( History_OUTPUT_WAIT < 0.0_DP ) then
       write(message,*) 'xxx History_OUTPUT_WAIT must be positive. STOP'
       call Log('E',message)
    endif

    array_size = isize * jsize * ksize

    ! count history request
    History_req_count = 0
    rewind(fid)
    do n = 1, History_req_limit
       ITEM      = ''
       OUTNAME   = 'undefined'
       BASENAME  = History_DEFAULT_BASENAME

       read(fid,nml=HISTITEM,iostat=ierr)
       if( ierr /= 0 ) exit
       if( BASENAME == '' .OR. ITEM == '' .OR. OUTNAME == '' ) cycle ! invalid HISTITEM

       History_req_count = History_req_count + 1
    enddo

    item_count    = History_req_count
    variant_count = 1

    if    ( History_req_count > History_req_limit ) then
       write(message,*) 'xxx request of history file is exceed! n >', History_req_limit
       call Log('E',message)
    elseif( History_req_count == 0 ) then
       call Log('I','*** No history file specified.')
       return
    endif


    allocate( History_req(History_req_count) )

    io_buffer_size = array_size * History_req_count * 8

    ! read history request
    memsize = 0
    reqid   = 0
    rewind(fid)
    do n = 1, History_req_limit
       ! set default
       ITEM      = ''
       OUTNAME   = 'undefined'
       BASENAME  = History_DEFAULT_BASENAME
       TINTERVAL = History_DEFAULT_TINTERVAL
       TUNIT     = History_DEFAULT_TUNIT
       TAVERAGE  = History_DEFAULT_TAVERAGE
       ZCOORD    = History_DEFAULT_ZCOORD
       DATATYPE  = History_DEFAULT_DATATYPE

       read(fid,nml=HISTITEM,iostat=ierr)
       if( ierr /= 0 ) exit
       if( BASENAME == '' .OR. ITEM == '' .OR. OUTNAME == '' ) cycle ! invalid HISTITEM

       ! check duplicated request
       if ( OUTNAME == 'undefined' ) OUTNAME = ITEM ! set default name
       do id = 1, reqid
          if ( History_req(id)%outname == OUTNAME ) then
             write(message,*) &
             'xxx Same name of history output is already registered. Check!', trim(OUTNAME)
             call Log('E',message)
          endif
       enddo

       reqid = reqid + 1

       History_req(reqid)%item     = ITEM
       History_req(reqid)%outname  = OUTNAME
       History_req(reqid)%basename = BASENAME
       History_req(reqid)%taverage = TAVERAGE

       call CalendarYmdhms2sec( item_dtsec, TINTERVAL, TUNIT )
       item_dstep = int( item_dtsec / History_DTSEC )

       if ( item_dtsec <= 0.D0 ) then
          write(message,*) &
          'xxx Not appropriate time interval. Check!', trim(ITEM), TINTERVAL, trim(TUNIT)
          call Log('E',message)
       endif

       if ( abs(item_dtsec-real(item_dstep,kind=DP)*History_DTSEC ) > eps ) then
          write(message,*) &
          'xxx time interval must be a multiple of delta t. (interval,dt)=', item_dtsec, History_DTSEC
          call Log('E',message)
       endif

       History_req(reqid)%dstep  = item_dstep
       History_req(reqid)%zcoord = ZCOORD

       if    ( DATATYPE == 'REAL4' ) then
          History_req(reqid)%dtype  = File_REAL4
          memsize = memsize + array_size * File_preclist(File_REAL4)
       elseif( DATATYPE == 'REAL8' ) then
          History_req(reqid)%dtype  = File_REAL8
          memsize = memsize + array_size * File_preclist(File_REAL8)
       else
          write(message,*) 'xxx Not appropriate DATATYPE. Check!', DATATYPE
          call Log('E',message)
       endif
    enddo

    write(message,*) '*** Number of requested history item             : ', History_req_count
    call Log('I',message)
    write(message,*) '*** Output default data type                     : ', History_DEFAULT_DATATYPE
    call Log('I',message)
    write(message,*) '*** Memory usage for history data buffer [Mbyte] : ', memsize / 1024 / 1024
    call Log('I',message)
    write(message,*) '*** Output value at the initial step?            : ', History_OUTPUT_STEP0
    call Log('I',message)
    write(message,*) '*** Check if requested item is not registered?   : ', History_ERROR_PUTMISS
    call Log('I',message)
    if ( History_OUTPUT_WAIT > 0.0_DP ) then
       write(message,*) '*** Time to suppress output [sec]                : ', History_OUTPUT_WAIT
       call Log('I',message)
    endif

    if ( .NOT. present(namelist_fid) ) then
       if( fid > 0 ) close(fid)
    endif

    History_id_count = 0
    allocate( History_vars(History_req_count) )

    do n = 1, History_req_count
       allocate( History_vars(n)%varsum(array_size) )
    enddo

    ! count number of items and variants
    do id1 = 1, item_count
       item1 = History_req(id1)%item
       count = 1
       do id2 = id1, item_count
          item2 = History_req(id2)%item
          if( item1 == item2 ) count = count + 1
       enddo
       variant_count = max( variant_count, count)
    enddo

    return
  end subroutine HistoryInit

  !-----------------------------------------------------------------------------
  subroutine HistoryCheck( &
       existed,   &
       item,      &
       zcoord     )
    implicit none

    logical,          intent(out)          :: existed
    character(len=*), intent(in)           :: item
    character(len=*), intent(in), optional :: zcoord

    integer :: max_count
    integer :: n

    intrinsic size
    !---------------------------------------------------------------------------

    existed = .false.

    max_count = min( History_id_count, History_req_count )

    do n = 1, max_count

       !--- search existing item
       if ( item == History_vars(n)%item ) then ! match (at least one) existing item
          !--- check z-coordinate
          if ( present(zcoord) ) then
             if ( History_vars(n)%zcoord == zcoord ) then
                existed = .true.
                return
             endif
          else
             existed = .true.
             return
          endif

       end if

    enddo

    return
  end subroutine HistoryCheck

  !-----------------------------------------------------------------------------
  subroutine HistoryAddVariable( &
       nregist,  &
       item,     &
       dims,     &
       desc,     &
       units,    &
       now_step, &
       zcoord,   &
       options,  &
       start,    &
       count,    &
       comm      )
    use gtool_file, only: &
       FileCreate,      &
       FileSetOption,   &
       FileAddVariable, &
       FileSetTAttr,    &
       FileDefAxis,     &
       FileDefAssociatedCoordinates, &
       FileAttachBuffer
    use MPI, only: &
       MPI_COMM_NULL
    implicit none

    integer,          intent(out) :: nregist
    character(len=*), intent(in)  :: item
    character(len=*), intent(in)  :: dims(:)
    character(len=*), intent(in)  :: desc
    character(len=*), intent(in)  :: units
    integer,          intent(in)  :: now_step
    character(len=*), intent(in), optional :: zcoord
    character(len=*), intent(in), optional :: options  ! 'filetype1:key1=val1&filetype2:key2=val2&...'
    integer,          intent(in), optional :: start(:) ! global indices of this process's write request
    integer,          intent(in), optional :: count(:) ! length of this process's write request
    integer,          intent(in), optional :: comm     ! MPI communicator

    character(len=File_HMID) :: tunits
    logical                  :: fileexisted
    integer                  :: ic, ie, is, lo
    real(DP)                 :: dtsec
    logical                  :: existed
    integer                  :: ndim

    logical                  :: shared_file_io
    integer                  :: nmax, reqid
    integer                  :: id
    integer                  :: n, m, dim_size

    intrinsic size
    !---------------------------------------------------------------------------

    nregist = 0

    shared_file_io = .FALSE.
    if ( present(comm) .AND. comm .NE. MPI_COMM_NULL ) shared_file_io = .TRUE.

    call HistoryCheck( existed, & ! [OUT]
                       item,    & ! [IN]
                       zcoord   ) ! [IN]

    if ( .NOT. existed ) then ! request-register matching check

       ! new file registration
       if ( History_TIME_SINCE == '' ) then
          tunits = trim(History_TIME_UNITS)
       else
          tunits = trim(History_TIME_UNITS)//' since '//trim(History_TIME_SINCE)
       endif

       ndim = size(dims)

       do reqid = 1, History_req_count

          ! note: plural requests are allowed for each item
          if ( item == History_req(reqid)%item ) then

             if ( present(zcoord) ) then
                if ( History_req(reqid)%zcoord /= zcoord ) cycle
             end if

             existed = .true.
             nregist = nregist + 1

             History_id_count = History_id_count + 1
             id               = History_id_count

             History_vars(id)%item     = History_req(reqid)%item
             History_vars(id)%outname  = History_req(reqid)%outname

             call FileCreate( History_vars(id)%fid,        & ! [OUT]
                              fileexisted,                 & ! [OUT]
                              History_req(reqid)%basename, & ! [IN]
                              History_TITLE,               & ! [IN]
                              History_SOURCE,              & ! [IN]
                              History_INSTITUTION,         & ! [IN]
                              History_master,              & ! [IN]
                              History_myrank,              & ! [IN]
                              History_rankidx(:),          & ! [IN]
                              time_units = tunits,         & ! [IN]
                              comm = comm                  ) ! [IN]

             History_vars(id)%dstep    = History_req(reqid)%dstep
             History_vars(id)%taverage = History_req(reqid)%taverage
             History_vars(id)%zcoord   = History_req(reqid)%zcoord

             if ( .NOT. fileexisted ) then ! new file

                ! write options
                if ( present(options) ) then
                   ic = -1 ! index of ':'
                   ie = -1 ! index of '='
                   is =  1 ! start index
                   lo = len_trim(options)
                   do m = 1, lo+1
                      if ( m == lo+1 .OR. options(m:m) == '&' ) then
                         if ( ic == -1 .OR. ie == -1 ) then
                            call Log('E','xxx option is invalid: '//trim(options))
                         endif

                         call FileSetOption( History_vars(id)%fid, & ! [IN]
                                             options(is  :ic-1),   & ! [IN]
                                             options(ic+1:ie-1),   & ! [IN]
                                             options(ie+1:m -1)    ) ! [IN]

                         ic = -1
                         ie = -1
                         is = m+1
                      elseif( options(m:m) == ':' ) then
                         ic = m
                      elseif( options(m:m) == '=' ) then
                         ie = m
                      endif
                   enddo
                endif

                ! define axis
                do m = 1, History_axis_count
                   History_axis(m)%id = id

                   if ( shared_file_io ) then
                      dim_size = History_axis(m)%gdim_size
                   else
                      dim_size = History_axis(m)%dim_size
                   end if

                   call FileDefAxis( History_vars(id)%fid,    & ! [IN]
                                     History_axis(m)%name,    & ! [IN]
                                     History_axis(m)%desc,    & ! [IN]
                                     History_axis(m)%units,   & ! [IN]
                                     History_axis(m)%dim,     & ! [IN]
                                     History_axis(m)%dtype,   & ! [IN]
                                     dim_size                 ) ! [IN]
                enddo

                ! define associated coordinate
                do m = 1, History_assoc_count
                   History_assoc(m)%id = id

                   if ( shared_file_io ) then
                      dim_size = History_axis(m)%gdim_size
                   else
                      dim_size = History_axis(m)%dim_size
                   end if

                   call FileDefAssociatedCoordinates( History_vars(id)%fid,                            & ! [IN]
                                                      History_assoc(m)%name,                           & ! [IN]
                                                      History_assoc(m)%desc,                           & ! [IN]
                                                      History_assoc(m)%units,                          & ! [IN]
                                                      History_assoc(m)%dims(1:History_assoc(m)%ndims), & ! [IN]
                                                      History_assoc(m)%dtype                           ) ! [IN]
                enddo

                ! allows PnetCDF to use an internal buffer
                call FileAttachBuffer( History_vars(id)%fid, io_buffer_size )

                History_vars(id)%axis_written = .false.

             endif ! new file?

             ! Add new variable
             dtsec = real(History_vars(id)%dstep,kind=DP) * History_DTSEC

             ! history variable has been reshaped to 1D, we preserve the
             ! original shape in count(:) and History_vars(id)%count(:)
             ! History_ndims(id) stores number of dimensions of original shape
             History_vars(id)%ndims    = size(dims)

             History_vars(id)%start(:) = 1
             History_vars(id)%count(:) = 1
             if ( present(start) ) History_vars(id)%start(:) = start(:)
             if ( present(count) ) History_vars(id)%count(:) = count(:)

             call FileAddVariable( History_vars(id)%vid,     & ! [OUT]
                                   History_vars(id)%fid,     & ! [IN]
                                   History_vars(id)%outname, & ! [IN]
                                   desc,                     & ! [IN]
                                   units,                    & ! [IN]
                                   dims(1:ndim),             & ! [IN]
                                   History_req(reqid)%dtype, & ! [IN]
                                   dtsec,                    & ! [IN]
                                   History_vars(id)%taverage ) ! [IN]

             if ( .NOT. fileexisted ) then
                do m = 1, History_axis_count
                   if ( History_axis(m)%down ) then
                      call FileSetTAttr( History_vars(id)%fid, History_axis(m)%name, 'positive', 'down' )
                   endif
                enddo
             endif

             ! initialize
             History_vars(id)%size         = 0
             History_vars(id)%waitsec      = History_OUTPUT_WAIT
             if ( History_OUTPUT_STEP0 .AND. now_step == 1 ) then
                History_vars(id)%laststep_write = 1 - History_vars(id)%dstep
             else
                History_vars(id)%laststep_write = 1
             endif
             History_vars(id)%laststep_put = History_vars(id)%laststep_write
             History_vars(id)%timesum      = 0.0_DP
             History_vars(id)%varsum(:)    = 0.0_DP

             if ( debug ) then
                write(message,*) '*** [HIST] Item registration No.= ', id
                call Log('I',message)
                write(message,*) '] Item name           : ', trim(History_vars(id)%item)
                call Log('I',message)
                write(message,*) '] Output name         : ', trim(History_vars(id)%outname)
                call Log('I',message)
                write(message,*) '] Description         : ', trim(desc)
                call Log('I',message)
                write(message,*) '] Unit                : ', trim(units)
                call Log('I',message)
                write(message,*) '] Z-coordinate        : ', trim(History_vars(id)%zcoord)
                call Log('I',message)
                write(message,*) '] Interval [sec,step] : ', dtsec, History_vars(id)%dstep
                call Log('I',message)
                write(message,*) '] Time Average?       : ', History_vars(id)%taverage
                call Log('I',message)
                write(message,*) '] axis name           : ', dims(1:ndim)
                call Log('I',message)
                call Log('I','')
             endif

          endif ! match item?
       enddo

    endif ! new items?

    return
  end subroutine HistoryAddVariable

  !-----------------------------------------------------------------------------
  ! interface HistoryPutAxis
  !-----------------------------------------------------------------------------
% ["SP", "DP"].each do |rp|
  !-----------------------------------------------------------------------------
  subroutine HistoryPutAxis<%=rp%>( &
       name,     &
       desc,     &
       units,    &
       dim,      &
       var,      &
       datatype, &
       down,     &
       gsize,    &
       start     )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim
    real(<%=rp%>),         intent(in) :: var(:)
    character(len=*), intent(in), optional :: datatype
    logical,          intent(in), optional :: down
    integer,          intent(in), optional :: gsize ! global dim size
    integer,          intent(in), optional :: start ! global subarray start indices

    integer :: dtype
    integer :: dim_size
    integer :: id

    intrinsic size
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if ( datatype == 'REAL4' ) then
          dtype = File_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = File_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = <%= rp=="SP" ? "File_REAL4" : "File_REAL8" %>
    endif

    dim_size = size(var)

    if ( History_axis_count < History_axis_limit ) then
       History_axis_count = History_axis_count + 1
       id                 = History_axis_count

       allocate( History_axis(id)%var(dim_size) )

       History_axis(id)%name     = name
       History_axis(id)%desc     = desc
       History_axis(id)%units    = units
       History_axis(id)%dim      = dim
       History_axis(id)%dtype    = dtype
       History_axis(id)%dim_size = dim_size
       History_axis(id)%var(:)   = var(:)

       if ( present(down) ) then
          History_axis(History_axis_count)%down = down
       else
          History_axis(History_axis_count)%down = .false.
       endif
       if ( present(gsize) ) &
          History_axis(History_axis_count)%gdim_size = gsize
       if ( present(start) ) then
          History_axis(History_axis_count)%start = start
       else
          History_axis(History_axis_count)%start = 1
       end if
    else
       write(message,*) 'xxx Number of axis exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine HistoryPutAxis<%=rp%>

%end
% for n in 1..4
%   ["SP", "DP"].each do |rp|
  !-----------------------------------------------------------------------------
  subroutine HistoryPut<%=n%>DAssociatedCoordinates<%=rp%>( &
       name,     &
       desc,     &
       units,    &
       dims,     &
       var,      &
       datatype, &
       start     )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(<%=rp%>),         intent(in) :: var(<%=Array.new(n){":"}.join(",")%>)
    character(len=*), intent(in), optional :: datatype
    integer,          intent(in), optional :: start(:)

    integer :: dtype
    integer :: dim_size
    integer :: id
    integer :: type

    intrinsic size, shape, reshape
    !---------------------------------------------------------------------------

    if ( present(datatype) ) then
       if    ( datatype == 'REAL4' ) then
          dtype = File_REAL4
       elseif( datatype == 'REAL8' ) then
          dtype = File_REAL8
       else
          write(message,*) 'xxx Not appropriate datatype. Check!', datatype
          call Log('E',message)
       endif
    else
       dtype = <%= rp=="SP" ? "File_REAL4" : "File_REAL8" %>
    endif

    dim_size = size(var)

    if ( History_assoc_count < History_assoc_limit ) then
       History_assoc_count = History_assoc_count + 1
       id                  = History_assoc_count

       allocate( History_assoc(id)%var(dim_size) )

       History_assoc(id)%name      = name
       History_assoc(id)%desc      = desc
       History_assoc(id)%units     = units
       History_assoc(id)%ndims     = <%=n%>
       History_assoc(id)%dims(:)   = ''
       History_assoc(id)%dims(1:<%=n%>) = dims(1:<%=n%>)
       History_assoc(id)%dtype     = dtype
       History_assoc(id)%var(:)    = reshape( var, (/ dim_size /) )

       ! start and count are used for parallel I/O to a single shared file
       ! since var is reshaped into 1D array, we need to save its shape in count
       History_assoc(id)%count(1:<%=n%>) = shape(var)
       if ( present(start) ) then
          History_assoc(id)%start(1:<%=n%>) = start(1:<%=n%>)
       else
          History_assoc(id)%start = (/ 1, 1, 1, 1 /)
       end if
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine HistoryPut<%=n%>DAssociatedCoordinates<%=rp%>

%  end
% end
  !-----------------------------------------------------------------------------
  subroutine HistorySetTAttr( &
       varname, &
       key,     &
       val      )
    use gtool_file, only: &
       FileSetTAttr
    implicit none

    character(len=*), intent(in) :: varname
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer :: id
    !---------------------------------------------------------------------------

    do id = 1, History_id_count
       call FileSetTAttr( History_vars(id)%fid, & ! [IN]
                          varname,              & ! [IN]
                          key,                  & ! [IN]
                          val                   ) ! [IN]
    enddo

  end subroutine HistorySetTAttr

  !-----------------------------------------------------------------------------
  subroutine HistoryQuery( &
       item,     &
       step_now, &
       answer    )
    implicit none

    character(len=*), intent(in)  :: item
    integer,          intent(in)  :: step_now
    logical,          intent(out) :: answer

    integer :: id
    !---------------------------------------------------------------------------

    answer  = .false.

    ! note: multiple put may be necessary for the item
    do id = 1, History_id_count
       if ( item == History_vars(id)%item ) then
          if    ( History_vars(id)%taverage ) then
             answer = .true.
          elseif( step_now == History_vars(id)%laststep_write + History_vars(id)%dstep ) then
             answer = .true.
          endif
       endif
    enddo

    return
  end subroutine HistoryQuery

% for n in 0..3
% varDecl  = (n==0) ? "var" : "var(#{([":"]*n).join(",")})"
% var_elem = (n==0) ? "var" : "var(#{["i","j","k"][0...n].join(",")})"
% ["SP", "DP"].each do |rp|
  !-----------------------------------------------------------------------------
  subroutine HistoryPut<%=n%>DId<%=rp%>( &
       id,       &
       step_now, &
       var       )
    implicit none

    integer,  intent(in) :: id
    integer,  intent(in) :: step_now
    real(<%=rp%>), intent(in) :: <%=varDecl%>

    real(DP) :: dt
    integer  :: idx
% if n > 0 then
    integer  :: vsize(<%=n%>)
    integer  :: <%=["i", "j", "k"][0...n].join(", ")%>
% end

    intrinsic shape
    !---------------------------------------------------------------------------

    if ( id < 0 ) return

% if n > 0 then
    vsize = shape(var)
% end
    dt  = ( step_now - History_vars(id)%laststep_put ) * History_DTSEC

    if ( dt < eps .AND. ( .NOT. History_vars(id)%taverage ) ) then
       write(message,*) 'xxx History variable was put two times before output!: ', &
                        trim(History_vars(id)%item), step_now, History_vars(id)%laststep_put
       call Log('E',message)
    endif

    if ( History_vars(id)%taverage ) then
% n.times do |i|
       do <%=["i", "j", "k"][0...n][n-i-1]%> = 1, vsize(<%=n-i%>)
% end
% if n==0 then
          idx = 1
% else
          idx = <%=["i", "(j-1)*vsize(1)+i", "((k-1)*vsize(2)+(j-1))*vsize(1)+i"][n-1]%>
% end
          History_vars(id)%varsum(idx) = History_vars(id)%varsum(idx) + <%=var_elem%> * dt
% n.times do |i|
       enddo
% end

       History_vars(id)%timesum = History_vars(id)%timesum + dt
    else
% n.times do |i|
       do <%=["i", "j", "k"][0...n][n-i-1]%> = 1, vsize(<%=n-i%>)
% end
% if n==0 then
          idx = 1
% else
          idx = <%=["i", "(j-1)*vsize(1)+i", "((k-1)*vsize(2)+(j-1))*vsize(1)+i"][n-1]%>
% end
          History_vars(id)%varsum(idx) = <%=var_elem%>
% n.times do |i|
       enddo
% end

       History_vars(id)%timesum = 0.0_DP
    endif

    History_vars(id)%size         = idx
    History_vars(id)%laststep_put = step_now

    return
  end subroutine HistoryPut<%=n%>DId<%=rp%>

% end
% end
  !-----------------------------------------------------------------------------
  subroutine HistoryWriteAll( &
       step_now )
    use gtool_file, only: &
       FileFlush
    implicit none
    integer, intent(in) :: step_now

    integer :: id
    integer :: fid, prev_fid
    !---------------------------------------------------------------------------

    ! Write registered axis variables to history file
    ! This subroutine must be called after all HIST_reg calls are completed
    call HistoryWriteAxes

    do id = 1, History_id_count
       call HistoryWrite( id,      & ! [IN]
                          step_now ) ! [IN]
    enddo

    prev_fid = -1
    do id = 1, History_id_count
       fid = History_vars(id)%fid
       if ( fid .NE. prev_fid ) then
          call FileFlush( fid )
          prev_fid = fid
       end if
    end do

    return
  end subroutine HistoryWriteAll

  !-----------------------------------------------------------------------------
  subroutine HistoryWriteAxes
    use dc_log, only: &
       LOG_fid
    use gtool_file, only: &
       FileEndDef,    &
       FileFlush,     &
       FileWriteAxis, &
       FileWriteAssociatedCoordinates
    implicit none

    integer :: m, id
    integer :: fid, prev_fid
    integer :: start(1)
    !---------------------------------------------------------------------------

    if( History_req_count  == 0 ) return
    if( History_axis_count == 0 ) return

    ! Assume all history axes are written into the same file
    id = History_axis(1)%id

    if ( History_vars(id)%axis_written ) return

    call FileEndDef( History_vars(id)%fid )

    ! write registered history variables to file
    do m = 1, History_axis_count
       id = History_axis(m)%id
       if ( History_axis(m)%start > 0 ) then
          start(1) = History_axis(m)%start
          call FileWriteAxis( History_vars(id)%fid, & ! [IN]
                              History_axis(m)%name, & ! [IN]
                              History_axis(m)%var,  & ! [IN]
                              start                 ) ! [IN]
       end if
    enddo

    do m = 1, History_assoc_count
       id = History_assoc(m)%id

       call FileWriteAssociatedCoordinates( History_vars(id)%fid,   & ! [IN]
                                            History_assoc(m)%name,  & ! [IN]
                                            History_assoc(m)%var,   & ! [IN]
                                            History_assoc(m)%start, & ! [IN]
                                            History_assoc(m)%count, & ! [IN]
                                            History_assoc(m)%ndims  ) ! [IN]
    enddo

    ! for parallel I/O, flush all pending nonblocking write requests
    prev_fid = -1
    do m = 1, History_axis_count
       id = History_axis(m)%id
       fid = History_vars(id)%fid
       if ( fid .NE. prev_fid ) then
          call FileFlush( fid )
          prev_fid = fid
       end if
    end do
    do m = 1, History_assoc_count
       id = History_axis(m)%id
       fid = History_vars(id)%fid
       if ( fid .NE. prev_fid ) then
          call FileFlush( fid )
          prev_fid = fid
       end if
    end do

    ! Assume all history axes are written into the same file
    id = History_axis(1)%id

    History_vars(id)%axis_written = .true.

    return
  end subroutine HistoryWriteAxes

  !-----------------------------------------------------------------------------
  subroutine HistoryWrite( &
       id,  &
       step_now )
    use dc_calendar, only: &
       CalendarSec2ymdhms
    use gtool_file, only: &
       FileWrite
    implicit none

    integer, intent(in) :: id
    integer, intent(in) :: step_now

    integer  :: isize
    real(DP) :: time_str, time_end
    real(DP) :: sec_str,  sec_end
    !---------------------------------------------------------------------------

    if( History_req_count == 0 ) return

    if ( step_now < History_vars(id)%laststep_write + History_vars(id)%dstep ) then
       return
    endif

    if ( History_vars(id)%laststep_put == History_vars(id)%laststep_write ) then
       write(message,*) 'xxx History variable was never put after the last output!: ', &
                        trim(History_vars(id)%item)
       if ( History_ERROR_PUTMISS ) then
          call Log('E',message)
       else
          call Log('I',message)
       endif
    endif

    isize = History_vars(id)%size

    if ( History_vars(id)%taverage ) then
       History_vars(id)%varsum(1:isize) = History_vars(id)%varsum(1:isize) / History_vars(id)%timesum
    endif

    if ( firsttime ) then
       firsttime = .false.
       call HistoryOutputList
    endif

    sec_str = History_STARTDAYSEC + real(History_vars(id)%laststep_write-1,kind=DP) * History_DTSEC
    sec_end = History_STARTDAYSEC + real(step_now                       -1,kind=DP) * History_DTSEC

    if ( sec_end >= History_STARTDAYSEC + History_vars(id)%waitsec ) then
       if ( laststep_write < step_now ) then ! log only once in this step
          write(message,'(A)') '*** Output History'
          call Log('I',message)
       endif

       ! convert time units [sec]->[sec,min,hour,day,month,year]
       call CalendarSec2ymdhms( time_str, sec_str, History_TIME_UNITS )
       call CalendarSec2ymdhms( time_end, sec_end, History_TIME_UNITS )

       if ( History_vars(id)%count(1) .GT. 0 ) then

          ! for one-file-per-process I/O method, History_vars(:)%count(1) == 1
          ! for one file shared by all processes, History_vars(:)%count(1) >= 0,
          ! being 0 indicates a 1D history variable, which will be written
          ! by only south-most processes in parallel
          call FileWrite( History_vars(id)%fid,             & ! [IN]
                          History_vars(id)%vid,             & ! [IN]
                          History_vars(id)%varsum(1:isize), & ! [IN]
                          time_str,                         & ! [IN]
                          time_end,                         & ! [IN]
                          History_vars(id)%start,           & ! global subarray start indices
                          History_vars(id)%count,           & ! global subarray lengths
                          History_vars(id)%ndims            ) ! ndims before reshape
       end if
    else
       if ( laststep_write < step_now ) then
          write(message,'(A)') '*** Output History: Suppressed.'
          call Log('I',message)
       endif
    endif

    History_vars(id)%laststep_write = step_now
    History_vars(id)%laststep_put   = step_now
    History_vars(id)%timesum        = 0.0_DP
    History_vars(id)%varsum(:)      = 0.0_DP

    laststep_write = step_now ! remember for multiple call in the same step

    return
  end subroutine HistoryWrite

  !-----------------------------------------------------------------------------
  ! interface HistoryGet
% for n in 1..3
% ["DP", "SP"].each do |rp|
  !-----------------------------------------------------------------------------
  subroutine HistoryGet<%=n%>D<%=rp%>( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use gtool_file, only: &
       FileRead
    implicit none

    real(<%=rp%>),         intent(out) :: var(<%=([":"]*n).join(",")%>)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single

    logical :: allow_missing_ = .false.
    logical :: single_        = .false.
    !---------------------------------------------------------------------------

    if ( present(allow_missing) ) then
       allow_missing_ = allow_missing
    endif

    if ( present(single) ) then
       single_ = single
    endif

    call FileRead( var,             & ! [OUT]
                   basename,        & ! [IN]
                   varname,         & ! [IN]
                   step,            & ! [IN]
                   History_myrank,  & ! [IN]
                   allow_missing_,  & ! [IN]
                   single_          ) ! [IN]

    return
  end subroutine HistoryGet<%=n%>D<%=rp%>

%   end
% end
  !-----------------------------------------------------------------------------
  subroutine HistoryOutputList
    implicit none

    real(DP) :: dtsec
    integer  :: id
    !---------------------------------------------------------------------------

    call Log('I','')
    write(message,*) '*** [HIST] Output item list '
    call Log('I',message)
    write(message,*) '*** Number of history item :', History_req_count
    call Log('I',message)
    write(message,*) 'ITEM            :OUTNAME         :size    :interval[sec]:  [step]:timeavg?:zcoord'
    call Log('I',message)
    write(message,*) '=================================================================================='
    call Log('I',message)

    do id = 1, History_id_count
       dtsec = real(History_vars(id)%dstep,kind=DP) * History_DTSEC

       write(message,'(1x,A,1x,A,1x,I8,1x,F13.3,1x,I8,1x,L8,1x,A6)') History_vars(id)%item,     &
                                                                     History_vars(id)%outname,  &
                                                                     History_vars(id)%size,     &
                                                                     dtsec,                     &
                                                                     History_vars(id)%dstep,    &
                                                                     History_vars(id)%taverage, &
                                                                     History_vars(id)%zcoord
       call Log('I',message)
    enddo

    write(message,*) '=================================================================================='
    call Log('I',message)
    call Log('I','')

    return
  end subroutine HistoryOutputList

  !-----------------------------------------------------------------------------
  subroutine HistoryFinalize
    use gtool_file, only: &
       FileDetachBuffer, &
       FileClose
    implicit none

    integer :: id
    integer :: fid, prev_fid
    !---------------------------------------------------------------------------

    prev_fid = -1
    do id = 1, History_id_count
       fid = History_vars(id)%fid 
       if ( fid .NE. prev_fid ) then
          call FileDetachBuffer( fid )
          call FileClose( fid )
          prev_fid =  fid
       end if
    enddo

    return
  end subroutine HistoryFinalize

end module gtool_history



!--
! vi<%=":"%>set readonly sw=4 ts=8
!
!Local Variables<%=":"%>
!mode: f90
!buffer-read-only:t
!End:
!
!++
