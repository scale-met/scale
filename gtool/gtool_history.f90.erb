% # -*- f90 -*-
% # vi: set sw=4 ts=8:
!-------------------------------------------------------------------------------
!> module Gtool_History
!!
!! @par Description
!!          module library for history output 
!!
!! @author H.Tomita and SCALE developpers
!!
!! @par History
!! @li      2012-06-11 (S.Nishizawa)  [new] imported from SCALE-LES
!!
!<
!-------------------------------------------------------------------------------
! Warning: This file was generated from <%=__FILE__%>.
!          Do not edit this file.
!-------------------------------------------------------------------------------
module gtool_history
  !-----------------------------------------------------------------------------
  !
  !++ Used modules
  !
  use dc_log, only: &
     Log, &
     LOG_LMSG
  use gtool_file_h, only: &
     File_HLONG, &
     File_HSHORT, &
     File_HMID
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedures
  !
  public :: HistoryInit
  public :: HistoryAddVariable
  public :: HistoryPutAxis
  public :: HistoryPutAdditionalAxis
  public :: HistoryPut
  public :: HistoryWrite
  public :: HistoryWriteAll
  public :: HistoryGet
  public :: HistoryOutputList
  public :: HistoryFinalize

  interface HistoryPutAxis
     module procedure HistoryPutAxisSP
     module procedure HistoryPutAxisDP
  end interface HistoryPutAxis

  interface HistoryPutAdditionalAxis
     module procedure HistoryPutAdditionalAxisSP
     module procedure HistoryPutAdditionalAxisDP
  end interface HistoryPutAdditionalAxis

  interface HistoryPut
% for n in 1..3
%   ["SP","DP"].each do |rp|
     module procedure HistoryPut<%=n%>DName<%=rp%>
     module procedure HistoryPut<%=n%>DId<%=rp%>
%   end
% end
  end interface HistoryPut

  interface HistoryWrite
     module procedure HistoryWriteSP
     module procedure HistoryWriteDP
  end interface HistoryWrite

  interface HistoryWriteAll
     module procedure HistoryWriteAllSP
     module procedure HistoryWriteAllDP
  end interface HistoryWriteAll

  interface HistoryGet
% for n in 1..3
%   ["SP","DP"].each do |rp|
     module procedure HistoryGet<%=n%>D<%=rp%>
%   end
% end
  end interface HistoryGet
  !-----------------------------------------------------------------------------
  !
  !++ included parameters
  !
  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private procedures
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private parameters & variables
  !
  integer,                    private, parameter :: SP = 4 ! single precision
  integer,                    private, parameter :: DP = 8 ! double precision

  character(len=File_HMID),   private,      save :: HISTORY_TITLE
  character(len=File_HMID),   private,      save :: HISTORY_SOURCE
  character(len=File_HMID),   private,      save :: HISTORY_INSTITUTION
  character(len=File_HMID),   private,      save :: HISTORY_TIME_UNITS

  integer,                    private, parameter :: History_req_limit = 1000 !> number limit for history item request
  character(len=File_HLONG),  private,      save :: History_req_basename(History_req_limit)
  character(len=File_HSHORT), private,      save :: History_req_item    (History_req_limit)
  real(DP),                   private,      save :: History_req_tintsec (History_req_limit)
  logical,                    private,      save :: History_req_tavg    (History_req_limit)
  integer,                    private,      save :: History_req_dtype   (History_req_limit)

  integer,                    private,              save :: History_req_nmax = 0 !> number of requested item
  character(len=File_HSHORT), private, allocatable, save :: History_item   (:)
  integer,                    private, allocatable, save :: History_fid    (:)
  integer,                    private, allocatable, save :: History_vid    (:)
  real(DP),                   private, allocatable, save :: History_tintsec(:)
  logical,                    private, allocatable, save :: History_tavg   (:)

  real(DP),                   private, allocatable, save :: History_varsum (:,:)
  integer,                    private, allocatable, save :: History_size   (:)
  real(DP),                   private, allocatable, save :: History_tstrsec(:)
  real(DP),                   private, allocatable, save :: History_tsumsec(:)

  integer,                    private,              save :: History_id_count = 0 !> number of registered item

  character(len=File_HSHORT), private, allocatable, save :: History_dim_name(:)
  integer,                    private, allocatable, save :: History_dim_size(:)
  character(len=File_HMID),   private, allocatable, save :: History_dim_desc(:)
  character(len=File_HSHORT), private, allocatable, save :: History_dim_units(:)
  integer,                    private, allocatable, save :: History_dim_type(:)

  real(DP),                   private, parameter :: eps = 1.D-10 !> epsilon for timesec

  character(LEN=LOG_LMSG),    private :: message

contains
  !-----------------------------------------------------------------------------
  subroutine HistoryInit( &
       title, source, institution,                         & ! (in)
       dim_name, dim_size, dim_desc, dim_units,            & ! (in)
       dim_type,                                           & ! (in) optional
       default_basename,                                   & ! (in) optional
       default_tinterval, default_tunit, default_taverage, & ! (in) optional
       default_datatype,                                   & ! (in) optional
       namelist_filename, namelist_fid                     & ! (in) optional
       )
    use dc_calendar, only: &
       CalendarYmdhms2sec
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8, &
       File_preclist
    implicit none

    character(len=*), intent(in)           :: title
    character(len=*), intent(in)           :: source
    character(len=*), intent(in)           :: institution
    character(len=*), intent(in)           :: dim_name(:)
    integer,          intent(in)           :: dim_size(:)
    character(len=*), intent(in)           :: dim_desc(:)
    character(len=*), intent(in)           :: dim_units(:)
    character(len=*), intent(in), optional :: dim_type(:)
    character(len=*), intent(in), optional :: default_basename
    real(DP)        , intent(in), optional :: default_tinterval
    character(len=*), intent(in), optional :: default_tunit
    logical,          intent(in), optional :: default_taverage
    character(len=*), intent(in), optional :: default_datatype
    character(len=*), intent(in), optional :: namelist_filename
    integer         , intent(in), optional :: namelist_fid

    integer :: ndims
    character(len=File_HLONG)  :: HISTORY_DEFAULT_BASENAME  = 'history'
    real(DP)                   :: HISTORY_DEFAULT_TINTERVAL = 1.0_DP
    character(len=File_HSHORT) :: HISTORY_DEFAULT_TUNIT     = 'sec'
    logical                    :: HISTORY_DEFAULT_TAVERAGE  = .false.
    character(len=File_HSHORT) :: HISTORY_DEFAULT_DATATYPE  = 'REAL4'

    NAMELIST / PARAM_HISTORY / &
         HISTORY_TITLE,             &
         HISTORY_SOURCE,            &
         HISTORY_INSTITUTION,       &
         HISTORY_TIME_UNITS,        &
         HISTORY_DEFAULT_BASENAME,  &
         HISTORY_DEFAULT_TINTERVAL, &
         HISTORY_DEFAULT_TUNIT,     &
         HISTORY_DEFAULT_TAVERAGE,  &
         HISTORY_DEFAULT_DATATYPE

    character(len=File_HLONG)  :: BASENAME  !> file base name
    character(len=File_HSHORT) :: ITEM      !> name of history item
    real(DP)                    :: TINTERVAL !> time interval to output
    character(len=File_HSHORT) :: TUNIT     !> time unit
    logical                    :: TAVERAGE  !> time average to output
    character(len=File_HSHORT) :: DATATYPE  !> data type

    NAMELIST / HISTITEM / &
       BASENAME,  &
       ITEM,      &
       TINTERVAL, &
       TUNIT,     &
       TAVERAGE,  &
       DATATYPE

    integer :: fid_conf

    integer :: ierr
    integer :: n
    integer :: arysize, memsize
    intrinsic size
    !---------------------------------------------------------------------------

    call Log('I', '')
    call Log('I', '+++ Module[HISTORY]/Categ[IO]')

    ndims = size(dim_name)
    if ( size(dim_size)  /= ndims .or. &
         size(dim_desc)  /= ndims .or. &
         size(dim_units) /= ndims      &
         ) then
       call Log('E', 'xxx size of dimensions are mismatch')
    end if

    !--- read namelist
    HISTORY_TITLE       = title
    HISTORY_SOURCE      = source
    HISTORY_INSTITUTION = institution
    HISTORY_TIME_UNITS  = 'sec'
    if ( present(default_basename) ) then
       HISTORY_DEFAULT_BASENAME = default_basename
    end if
    if ( present(default_tinterval) ) then
       HISTORY_DEFAULT_TINTERVAL = default_tinterval
       if ( present(default_tunit) ) then
          HISTORY_DEFAULT_TUNIT = default_tunit
       end if
    end if
    if ( present(default_taverage) ) then
       HISTORY_DEFAULT_TAVERAGE = default_taverage
    end if
    if ( present(default_datatype) ) then
       HISTORY_DEFAULT_DATATYPE = default_datatype
    end if

    if ( present(namelist_fid) ) then
       fid_conf = namelist_fid
       rewind(fid_conf)
    else if ( present(namelist_filename) .and. trim(namelist_filename) /= '' ) then
       open( fid_conf, file = trim(namelist_filename), &
            form = 'formatted', status = 'old', iostat = ierr)
    else
       call Log('I', '*** No namelist was specified. Default used. ***')
       fid_conf = -1
    end if

    if ( fid_conf > 0 ) then
       read(fid_conf, nml=PARAM_HISTORY, iostat=ierr)

       if( ierr < 0 ) then !--- missing
          call Log('I', '*** Not found namelist. Default used.')
       elseif( ierr > 0 ) then !--- fatal error
          call Log('E', 'xxx Not appropriate names in namelist PARAM_HISTORY. Check!')
       endif
       write(message,nml=PARAM_HISTORY)
       call Log('I', message)
    end if

    allocate(History_dim_name (ndims))
    allocate(History_dim_size (ndims))
    allocate(History_dim_desc (ndims))
    allocate(History_dim_units(ndims))
    allocate(History_dim_type (ndims))
    do n = 1, ndims
      History_dim_name(n)  = dim_name(n)
      History_dim_size(n)  = dim_size(n)
      History_dim_desc(n)  = dim_desc(n)
      History_dim_units(n) = dim_units(n)
      History_dim_type(n)  = File_REAL4
      if ( present(dim_type) ) then
         if ( size(dim_type) >= n ) then
            if    ( trim(dim_type(n)) == 'REAL4' ) then
               History_dim_type(n) = File_REAL4
            elseif( trim(dim_type(n)) == 'REAL8' ) then
               History_dim_type(n) = File_REAL8
            else
               write(message,*) 'xxx Not appropriate dim_type. Check!', dim_type(n), n
               call Log('E', message)
            endif
         end if
      end if
    end do

    ! listup history request
    if ( fid_conf > 0 ) then
       rewind( fid_conf )
       do n = 1, History_req_limit
          read(fid_conf, nml=HISTITEM, iostat=ierr)
          if( ierr /= 0 ) exit
       enddo
       History_req_nmax = n - 1
    else
       History_req_nmax = History_req_limit
    end if

    if    ( History_req_nmax > History_req_limit ) then
       write(message,*) '*** request of history file is exceed! n >', History_req_limit
       call Log('I', message)
    elseif( History_req_nmax == 0 ) then
       call Log('I', '*** No history file specified.')
       return
    endif

    arysize = 1
    do n = 1, ndims
       arysize = arysize * dim_size(n)
    end do

    allocate( History_item   (History_req_nmax) ); History_item(:) = ''
    allocate( History_fid    (History_req_nmax) )
    allocate( History_vid    (History_req_nmax) )
    allocate( History_tintsec(History_req_nmax) )
    allocate( History_tavg   (History_req_nmax) )

    allocate( History_varsum (arysize,History_req_nmax) )
    allocate( History_size   (History_req_nmax) )
    allocate( History_tstrsec(History_req_nmax) )
    allocate( History_tsumsec(History_req_nmax) )

    if ( fid_conf > 0 ) rewind(fid_conf)
    memsize = 0
    do n = 1, History_req_nmax
       ! set default
       BASENAME  = HISTORY_DEFAULT_BASENAME
       ITEM      = 'unknown'
       TINTERVAL = HISTORY_DEFAULT_TINTERVAL
       TUNIT     = HISTORY_DEFAULT_TUNIT
       TAVERAGE  = HISTORY_DEFAULT_TAVERAGE
       DATATYPE  = HISTORY_DEFAULT_DATATYPE

       if ( fid_conf > 0 ) then
          read(fid_conf, nml=HISTITEM,iostat=ierr)
          if( ierr /= 0 ) exit
       end if

       History_req_item(n) = ITEM
       History_req_basename(n) = BASENAME
       call CalendarYmdhms2sec( History_req_tintsec(n), TINTERVAL, TUNIT )
       History_req_tavg(n) = TAVERAGE

       if ( History_req_tintsec(n) <= 0.D0 ) then
          write(message,*) 'xxx Not appropriate time interval. Check!', ITEM, TINTERVAL
          call Log('E', message)
       endif

       if    ( trim(DATATYPE) == 'REAL4' ) then
          History_req_dtype(n) = File_REAL4
       elseif( trim(DATATYPE) == 'REAL8' ) then
          History_req_dtype(n) = File_REAL8
       else
          write(message,*) 'xxx Not appropriate DATATYPE. Check!', DATATYPE
          call Log('E', message)
       endif

       memsize = memsize + arysize*File_preclist(History_req_dtype(n))
    enddo

    write(message,*) '*** Number of requested history item             : ', History_req_nmax
    call Log('I', message)
    write(message,*) '*** Output default data type                             : ', HISTORY_DEFAULT_DATATYPE
    call Log('I', message)
    write(message,*) '*** Memory usage for history data buffer [Mbyte] : ', memsize/1024/1024
    call Log('I', message)

    if ( (.not. present(namelist_fid)) .and. fid_conf > 0 ) close(fid_conf)

    return
  end subroutine HistoryInit

  !-----------------------------------------------------------------------------
  subroutine HistoryAddVariable( &
      varname, &
      dims,    &
      desc,    &
      units,   &
      master,  &
      myrank,  &
      options, &
      itemid   )
    use gtool_file, only : &
         FileCreate, &
         FileSetOption, &
         FileAddVariable
    implicit none

    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: dims(:)
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    integer,          intent( in) :: master
    integer,          intent( in) :: myrank
    character(len=*), intent( in), optional :: options ! 'filetype1:key1=val1&filetype2:key2=val2&...'
    integer,          intent(out), optional :: itemid

    integer :: id
    integer :: ary_size
    integer :: nmax, reqid
    integer :: n, m, l
    integer :: ic, ie, is, lo
    intrinsic size
    !---------------------------------------------------------------------------

    !--- search existing item
    id = -1
    nmax = min( History_id_count, History_req_nmax )
    do n = 1, nmax
       if ( trim(varname) == trim(History_item(n)) ) then ! match existing item
          if ( present(itemid) ) itemid = n
          return
       endif
    enddo


    if ( id < 0 ) then ! request-register matching check
       do n = 1, History_req_nmax
          if ( trim(varname) == History_req_item(n) ) then
             reqid  = n
             History_id_count = History_id_count + 1
             id = History_id_count

             ! new file registration
             call FileCreate(History_fid(id),                           & ! (out)
                  trim(History_req_basename(reqid)),                    & ! (in)
                  HISTORY_TITLE, HISTORY_SOURCE, HISTORY_INSTITUTION,   & ! (in)
                  History_dim_name, History_dim_size, History_dim_desc, & ! (in)
                  History_dim_units, History_dim_type,                  & ! (in)
                  master, myrank,                                       & ! (in)
                  time_units = HISTORY_TIME_UNITS                       & ! (in)
                  )

             if ( present(options) ) then
                ic = -1 ! index of ':'
                ie = -1 ! index of '='
                is = 1  ! start index
                lo = len_trim(options)
                do m = 1, lo+1
                   if ( m == lo+1 .or. options(m:m) == '&' ) then
                      if ( ic == -1 .or. ie == -1 ) then
                         call Log('E', 'xxx option is invalid: ' // trim(options))
                      end if
                      call FileSetOption(History_fid(id),        & ! (in)
                           options(is:ic-1),                     & ! (in)
                           options(ic+1:ie-1), options(ie+1:m-1) ) ! (in)
                      ic = -1
                      ie = -1
                      is = m + 1
                   else if ( options(m:m) == ':' ) then
                      ic = m
                   else if ( options(m:m) == '=' ) then
                      ie = m
                   end if
                end do
             end if

             call FileAddVariable(History_vid(id), & ! (out)
                  History_fid(id),                 & ! (in)
                  varname, desc, units, dims,      & ! (in)
                  History_req_dtype  (reqid),      & ! (in)
                  History_req_tintsec(reqid),      & ! (in)
                  History_req_tavg   (reqid)       & ! (in)
                  )

             ary_size = 1
             do m = 1, size(dims)
                do l = 1, size(History_dim_name)
                   if ( trim(dims(m)) == trim(History_dim_name(l)) ) then
                      if ( History_dim_size(l) > 0 ) then
                         ary_size = ary_size * History_dim_size(l)
                         exit
                      end if
                   end if
                end do
             end do

             History_item   (id) = varname

             History_tintsec(id) = History_req_tintsec(reqid)
             History_tavg   (id) = History_req_tavg   (reqid)

             History_varsum(:,id) =  0.D0
             History_size    (id) = ary_size
             History_tstrsec (id) = -1.D0
             History_tsumsec (id) =  0.D0

             write(message,*) '*** [HIST] Item registration No.= ', id
             call Log('I', message)
             write(message,*) '] Name           : ', trim(History_item(id))
             call Log('I', message)
             write(message,*) '] Description    : ', trim(desc)
             call Log('I', message)
             write(message,*) '] Unit           : ', trim(units)
             call Log('I', message)
             write(message,*) '] size           : ', ary_size
             call Log('I', message)
             write(message,*) '] Interval [sec] : ', History_tintsec(id)
             call Log('I', message)
             write(message,*) '] Average?       : ', History_tavg   (id)
             call Log('I', message)
          endif
       enddo
    endif

    if ( present(itemid) ) itemid = id

    return
  end subroutine HistoryAddVariable

  !-----------------------------------------------------------------------------
  ! interface HistoryPutAxis
  !-----------------------------------------------------------------------------
% ["SP", "DP"].each do |rp|
  subroutine HistoryPutAxis<%=rp%>( &
       dim, & ! (in)
       val  & ! (in)
       )
    use gtool_file, only : &
         FilePutAxis
    implicit none

    character(len=*), intent(in) :: dim
    real(<%=rp%>),         intent(in) :: val(:)

    integer :: m, n
    logical :: flag = .false.
    intrinsic size
    !---------------------------------------------------------------------------

    do m = 1, size(History_dim_name)
       if ( trim(History_dim_name(m)) == trim(dim) ) then ! dimension is found
          flag = .true.
          exit
       end if
    end do

    if ( .not. flag ) then ! dimension was not found
       write(message,*) "xxx dimension name is invalid: ", dim
       call Log('E', message)
    end if

    do m = 1, History_id_count
       flag = .true.
       do n = 1, m-1
          if ( History_fid(m) == History_fid(n) ) then
             flag = .false.
             exit
          end if
       end do
       if ( flag ) call FilePutAxis( History_fid(m), dim, val )
    end do

    return
  end subroutine HistoryPutAxis<%=rp%>
% end

  !-----------------------------------------------------------------------------
% ["SP", "DP"].each do |rp|
  subroutine HistoryPutAdditionalAxis<%=rp%>( &
       name,  & ! (in)
       desc,  & ! (in)
       units, & ! (in)
       dim,   & ! (in)
       var,   & ! (in)
       dtype  & ! (in) optional
       )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    use gtool_file, only : &
       FilePutAdditionalAxis
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim
    real(<%=rp%>),         intent(in) :: var(:)
    character(len=*), intent(in), optional :: dtype

    integer :: type
    integer :: m, n
    logical flag
    intrinsic size
    !---------------------------------------------------------------------------

    if ( present(dtype) ) then
       if ( trim(dtype) == 'REAL4' ) then
          type = File_REAL4
       else if ( trim(dtype) == 'REAL8' ) then
          type = File_REAL8
       else
          write(message,*) 'xxx Not appropriate dtype. Check!', dtype
          call Log('E', message)
       end if
    else
       type = <%= rp=="SP" ? "File_REAL4" : "File_REAL8" %>
    end if

    do m = 1, size(History_dim_name)
       if ( trim(History_dim_name(m)) == trim(dim) ) then
          if ( History_dim_size(m) /= size(var) ) then
             write(message,*) 'xxx size of var is not match to dim. Check!', size(var), History_dim_size(m), '(', dim, ')'
             call Log('E', message)
          end if
          exit
       end if
    end do

    do m = 1, History_id_count
       flag = .true.
       do n = 1, m-1
          if ( History_fid(m) == History_fid(n) ) then
             flag = .false.
             exit
          end if
       end do
       if ( flag ) then
          call FilePutAdditionalAxis( History_fid(m),       & ! (in)
               name, desc, units, dim, type, var, size(var) ) ! (in)
       end if
    end do

    return
  end subroutine HistoryPutAdditionalAxis<%=rp%>
%end

  !-----------------------------------------------------------------------------
  ! interface HistoryPut
  !-----------------------------------------------------------------------------
% for n in 1..3
%   idx = ([":"]*n).join(",")
%   ["SP", "DP"].each do |rp|
  subroutine HistoryPut<%=n%>DName<%=rp%>( &
       varname, &
       var,     &
       dt,      &
       force    )
    implicit none

    character(len=*), intent(in)           :: varname
    real(<%=rp%>),         intent(in)           :: var(<%=idx%>)
    real(8),          intent(in)           :: dt
    logical,          intent(in), optional :: force

    integer :: itemid, n
    !---------------------------------------------------------------------------

    ! search item id
    itemid = -1
    do n = 1, History_id_count
       if ( trim(varname) == trim(History_item(n)) ) then
          itemid = n
          exit
       end if
    end do

    call HistoryPut<%=n%>DId<%=rp%>(itemid, var, dt, force)

    return
  end subroutine HistoryPut<%=n%>DName<%=rp%>
  subroutine HistoryPut<%=n%>DId<%=rp%>( &
       itemid,  &
       var,     &
       dt,      &
       force    )
    implicit none

    integer,          intent(in)           :: itemid
    real(<%=rp%>),         intent(in)           :: var(<%=idx%>)
    real(8),         intent(in)            :: dt
    logical,          intent(in), optional :: force

    integer :: ijk(<%=n%>), idx
    integer :: <%= ["i", "j", "k"][0...n].join(", ")%>
    intrinsic shape
    !---------------------------------------------------------------------------

    if ( itemid < 0 ) return

    ijk = shape(var)

    if ( History_tavg(itemid) ) then
% n.times do |i|
       do <%=["i","j","k"][0...n][n-i-1]%> = 1, ijk(<%=n-i%>)
% end
          idx = <%=["i", "j*ijk(i)+i", "(k*ijk(2)+j)*ijk(1)+i"][n-1]%>
          History_varsum(idx,itemid) = &
                  History_varsum(idx,itemid) &
                  + var(<%=["i","j","k"][0...n].join(",")%>) * dt
% n.times do |i|
       end do
% end
    else
% n.times do |i|
       do <%=["i","j","k"][0...n][n-i-1]%> = 1, ijk(<%=n-i%>)
% end
          idx = <%=["i", "j*ijk(i)+i", "(k*ijk(2)+j)*ijk(1)+i"][n-1]%>
          History_varsum(idx,itemid) = var(<%=["i","j","k"][0...n].join(",")%>)
% n.times do |i|
       end do
% end
    endif
    History_tsumsec(itemid) = History_tsumsec(itemid) + dt

    return
  end subroutine HistoryPut<%=n%>DId<%=rp%>
%   end
% end

  !-----------------------------------------------------------------------------
  ! interface HistoryWrite
  !-----------------------------------------------------------------------------
% ["SP", "DP"].each do |rp|
  subroutine HistoryWrite<%=rp%>( &
       itemid, &
       time, &
       force )
    use dc_calendar, only: &
       CalendarSec2ymdhms
    use gtool_file, only: &
       FileWrite
    implicit none

    integer, intent(in) :: itemid
    real(<%=rp%>), intent(in) :: time
    logical, intent(in), optional :: force

    real(DP) :: stime, etime
    logical, save :: firsttime = .true.
    !---------------------------------------------------------------------------

    if( History_id_count == 0 ) return

    if (firsttime) then
       firsttime = .false.
       call HistoryOutputList
    endif

    if ( .not. ( present(force) .and. force ) .and. &
         History_tsumsec(itemid) - History_tintsec(itemid) <= -eps ) then
       return
    end if

    if ( History_tsumsec(itemid) > eps ) then
       if ( History_tavg(itemid) ) then
          History_varsum(1:History_size(itemid),itemid) = &
               History_varsum(1:History_size(itemid),itemid) / History_tsumsec(itemid)
       end if

       if ( History_tstrsec(itemid) < 0.D0 ) then ! first time
          stime = time - History_tsumsec(itemid)
          etime = time
       else
          stime = History_tstrsec(itemid)
          etime = History_tstrsec(itemid) + History_tsumsec(itemid) ! neary equal to time
       end if

       ! convert time units
       call CalendarSec2ymdhms( stime, stime, HISTORY_TIME_UNITS )
       call CalendarSec2ymdhms( etime, etime, HISTORY_TIME_UNITS )

       call FileWrite( History_vid(itemid),                & ! vid
            History_varsum(1:History_size(itemid),itemid), & ! data
            stime, etime                                   ) ! start & end time

    endif

    History_varsum(:,itemid) = 0.0_DP
    History_tstrsec (itemid) = time
    History_tsumsec (itemid) = 0.0_DP

    return
  end subroutine HistoryWrite<%=rp%>
% end

  !-----------------------------------------------------------------------------
  ! interface HistoryWritaAll
  !-----------------------------------------------------------------------------
% ["SP", "DP"].each do |rp|
  subroutine HistoryWriteAll<%=rp%>( &
       time, & ! (in)
       force & ! (in) optional
       )
    implicit none

    real(<%=rp%>), intent(in) :: time
    logical,  intent(in), optional :: force

    integer :: n

    do n = 1, History_id_count
       call HistoryWrite( n, time, force )
    end do

    return
  end subroutine HistoryWriteAll<%=rp%>
% end

  !-----------------------------------------------------------------------------
  ! interface HistoryGet
  !-----------------------------------------------------------------------------
% for n in 1..3
%  ["DP", "SP"].each do |rp|
  subroutine HistoryGet<%=n%>D<%=rp%>( &
       var, &
       basename, &
       varname, &
       step, &
       myrank, &
       allow_missing, &
       single &
       )
    use gtool_file, only : &
         FileRead
    implicit none

    real(<%=rp%>),         intent(out) :: var(<%=([":"]*n).join(",")%>)
    character(len=*), intent( in) :: basename
    character(len=*), intent( in) :: varname
    integer,          intent( in) :: step
    integer,          intent( in) :: myrank
    logical,          intent( in), optional :: allow_missing
    logical,          intent( in), optional :: single
    !---------------------------------------------------------------------------

    call FileRead(var,                    & ! (out)
         basename, varname, step, myrank, & ! (in)
         allow_missing, single            & ! (in)
         )

    return
  end subroutine HistoryGet<%=n%>D<%=rp%>
%   end
% end

  !-----------------------------------------------------------------------------
  subroutine HistoryOutputList
    implicit none

    integer :: n
    !---------------------------------------------------------------------------

    call Log('I', '')
    call Log('I', '*** [HIST] Output item list ')
    write(message,*) '*** Number of history item :', History_req_nmax
    call Log('I', message)
    call Log('I', 'NAME           :size         :interval[sec]:avg')
    call Log('I', '============================================================================')
 
    do n = 1, History_id_count
       write(message,'(1x,A,I10,1x,f13.3,1x,L)') History_item(n), History_size(n), History_tintsec(n), History_tavg(n)
       call Log('I', message)
    enddo

    call Log('I', '============================================================================')

    return
  end subroutine HistoryOutputList

  !-----------------------------------------------------------------------------
  subroutine HistoryFinalize
    use gtool_file, only : &
       FileClose
    implicit none

    integer :: n
    !---------------------------------------------------------------------------

    do n = 1, History_id_count
       call FileClose( History_fid(n) )
    end do

    return
  end subroutine HistoryFinalize

end module gtool_history
!-------------------------------------------------------------------------------



!--
! vi<%=":"%>set readonly sw=4 ts=8
!
!Local Variables<%=":"%>
!mode: f90
!buffer-read-only:t
!End:
!
!++
