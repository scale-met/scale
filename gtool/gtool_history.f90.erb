% # -*- f90 -*-
% # vi: set sw=4 ts=8:
!-------------------------------------------------------------------------------
!> module Gtool_History
!!
!! @par Description
!!          module library for history output
!!
!! @author Team SCALE
!!
!! @par History
!! @li      2012-06-11 (S.Nishizawa)  [new] imported from SCALE-LES
!!
!<
!-------------------------------------------------------------------------------
! Warning: This file was generated from <%=__FILE__%>.
!          Do not edit this file.
!-------------------------------------------------------------------------------
module gtool_history
  !-----------------------------------------------------------------------------
  !
  !++ Used modules
  !
  use dc_log, only: &
     Log, &
#if defined(__PGI) || defined(__ES2)
     LOG_fid, &
#endif
     LOG_LMSG
  use dc_types, only: &
     SP, &
     DP
  use gtool_file_h, only: &
     File_HLONG, &
     File_HSHORT, &
     File_HMID
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedures
  !
  public :: HistoryInit
  public :: HistoryAddVariable
  public :: HistoryPutAxis
  public :: HistoryPutAssociatedCoordinates
  public :: HistoryWriteAxes
  public :: HistorySetTAttr
  public :: HistoryQuery
  public :: HistoryPut
  public :: HistoryWrite
  public :: HistoryWriteAll
  public :: HistoryGet
  public :: HistoryOutputList
  public :: HistoryFinalize

  interface HistoryPutAxis
     module procedure HistoryPutAxisSP
     module procedure HistoryPutAxisDP
  end interface HistoryPutAxis

  interface HistoryPutAssociatedCoordinates
%  for n in 1..4
%  %w(SP DP).each do |rp|
     module procedure HistoryPut<%=n%>DAssociatedCoordinates<%=rp%>
%  end
%  end
  end interface HistoryPutAssociatedCoordinates

  interface HistoryPut
%  for n in 0..3
%  ["SP","DP"].each do |rp|
     module procedure HistoryPut<%=n%>DName<%=rp%>
     module procedure HistoryPut<%=n%>DId<%=rp%>
%  end
%  end
  end interface HistoryPut

  interface HistoryGet
%  for n in 1..3
%  ["SP","DP"].each do |rp|
     module procedure HistoryGet<%=n%>D<%=rp%>
%  end
%  end
  end interface HistoryGet

  type axis
     character(len=File_HSHORT) :: name
     character(len=File_HLONG)  :: desc
     character(len=File_HSHORT) :: units
     character(len=File_HSHORT) :: dim
     integer                    :: type
     integer                    :: dim_size
     integer                    :: id
     real(DP), pointer          :: var(:)
     logical                    :: down
  end type axis

  type assoc
     character(len=File_HSHORT) :: name
     character(len=File_HLONG)  :: desc
     character(len=File_HSHORT) :: units
     character(len=File_HSHORT) :: dims(4)
     integer                    :: ndims
     integer                    :: type
     integer                    :: id
     real(DP), pointer          :: var(:)
  end type assoc

  !-----------------------------------------------------------------------------
  !
  !++ included parameters
  !
  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private procedures
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private parameters & variables
  !
  character(len=File_HMID),   private :: HISTORY_TITLE
  character(len=File_HMID),   private :: HISTORY_SOURCE
  character(len=File_HMID),   private :: HISTORY_INSTITUTION
  character(len=File_HMID),   private :: HISTORY_TIME_UNITS
  character(len=File_HMID),   private :: HISTORY_TIME_SINCE
  real(DP),                   private :: HISTORY_DTSEC
  real(DP),                   private :: HISTORY_STARTDAYSEC

  logical,                    private :: HISTORY_OUTPUT_STEP0  = .false. !> output value of step=0?
  real(DP),                   private :: HISTORY_OUTPUT_START  = 0.0_DP  !> start time for output in second
  logical,                    private :: HISTORY_ERROR_PUTMISS = .false. !> Abort if the value is never stored after last output?

  integer,                    private, parameter   :: History_req_limit = 1000 !> number limit for history item request
  character(len=File_HLONG),  private              :: History_req_basename(History_req_limit)
  character(len=File_HSHORT), private              :: History_req_item    (History_req_limit)
  real(DP),                   private              :: History_req_tintsec (History_req_limit)
  integer,                    private              :: History_req_tintstep(History_req_limit)
  logical,                    private              :: History_req_tavg    (History_req_limit)
  logical,                    private              :: History_req_zinterp (History_req_limit)
  integer,                    private              :: History_req_dtype   (History_req_limit)

  integer,                    private              :: History_req_nmax = 0 !> number of requested item
  integer,                    private              :: History_id_count = 0 !> number of registered item
  character(len=File_HSHORT), private, allocatable :: History_item    (:)
  integer,                    private, allocatable :: History_fid     (:)
  integer,                    private, allocatable :: History_vid     (:)
  real(DP),                   private, allocatable :: History_tintsec (:)
  integer,                    private, allocatable :: History_tintstep(:)
  logical,                    private, allocatable :: History_tavg    (:)
  logical,                    private, allocatable :: History_zinterp (:)
  real(DP),                   private, allocatable :: History_varsum  (:,:)
  integer,                    private, allocatable :: History_size    (:)
  real(DP),                   private, allocatable :: History_tstart  (:)
  integer,                    private, allocatable :: History_tstrstep(:)
  integer,                    private, allocatable :: History_tlststep(:)
  real(DP),                   private, allocatable :: History_tsumsec (:)
  logical,                    private, allocatable :: History_axis_written(:)


  real(DP), private, parameter   :: eps = 1.D-10 !> epsilon for timesec
  integer,  private              :: History_master
  integer,  private              :: History_myrank
  integer,  private, allocatable :: History_rankidx(:)

  integer,  private, parameter   :: History_axis_limit = 100 !> number limit of axes
  integer,  private              :: History_axis_count = 0;
  type(axis)                     :: History_axis(History_axis_limit)

  integer,  private, parameter   :: History_assoc_limit = 20 !> number limit of associated coordinates
  integer,  private              :: History_assoc_count = 0;
  type(assoc)                    :: History_assoc(History_assoc_limit)

  character(LEN=LOG_LMSG), private :: message

  !-----------------------------------------------------------------------------
contains
  !-----------------------------------------------------------------------------
  subroutine HistoryInit( &
       title, source, institution,                         & ! (in)
       array_size,                                         & ! (in)
       master, myrank, rankidx,                            & ! (in)
       time_start, time_interval,                          & ! (in)
       time_units, time_since,                             & ! (in)
       default_basename,                                   & ! (in) optional
       default_tinterval, default_tunit, default_taverage, & ! (in) optional
       default_zinterp,                                    & ! (in) optional
       default_datatype,                                   & ! (in) optional
       namelist_filename, namelist_fid                     & ! (in) optional
       )
    use dc_calendar, only: &
       CalendarYmdhms2sec
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8, &
       File_preclist
    implicit none

    character(len=*), intent(in)           :: title
    character(len=*), intent(in)           :: source
    character(len=*), intent(in)           :: institution
    integer,          intent(in)           :: array_size
    integer,          intent(in)           :: master
    integer,          intent(in)           :: myrank
    integer,          intent(in)           :: rankidx(:)
    real(DP),         intent(in)           :: time_start
    real(DP),         intent(in)           :: time_interval
    character(len=*), intent(in), optional :: time_units
    character(len=*), intent(in), optional :: time_since
    character(len=*), intent(in), optional :: default_basename
    real(DP),         intent(in), optional :: default_tinterval
    character(len=*), intent(in), optional :: default_tunit
    logical,          intent(in), optional :: default_taverage
    logical,          intent(in), optional :: default_zinterp
    character(len=*), intent(in), optional :: default_datatype
    character(len=*), intent(in), optional :: namelist_filename
    integer         , intent(in), optional :: namelist_fid

    character(len=File_HLONG)  :: HISTORY_DEFAULT_BASENAME  = ''
    real(DP)                   :: HISTORY_DEFAULT_TINTERVAL = 1.0_DP
    character(len=File_HSHORT) :: HISTORY_DEFAULT_TUNIT     = 'sec'
    logical                    :: HISTORY_DEFAULT_TAVERAGE  = .false.
    logical                    :: HISTORY_DEFAULT_ZINTERP   = .false.
    character(len=File_HSHORT) :: HISTORY_DEFAULT_DATATYPE  = 'REAL4'

    NAMELIST / PARAM_HISTORY / &
         HISTORY_TITLE,             &
         HISTORY_SOURCE,            &
         HISTORY_INSTITUTION,       &
         HISTORY_TIME_UNITS,        &
         HISTORY_DEFAULT_BASENAME,  &
         HISTORY_DEFAULT_TINTERVAL, &
         HISTORY_DEFAULT_TUNIT,     &
         HISTORY_DEFAULT_TAVERAGE,  &
         HISTORY_DEFAULT_ZINTERP,   &
         HISTORY_DEFAULT_DATATYPE,  &
         HISTORY_OUTPUT_STEP0,      &
         HISTORY_OUTPUT_START,      &
         HISTORY_ERROR_PUTMISS

    character(len=File_HLONG)  :: BASENAME  !> file base name
    character(len=File_HSHORT) :: ITEM      !> name of history item
    real(DP)                   :: TINTERVAL !> time interval to output
    character(len=File_HSHORT) :: TUNIT     !> time unit
    logical                    :: TAVERAGE  !> time average to output
    logical                    :: ZINTERP   !> z interpolation to output
    character(len=File_HSHORT) :: DATATYPE  !> data type

    NAMELIST / HISTITEM / &
       BASENAME,  &
       ITEM,      &
       TINTERVAL, &
       TUNIT,     &
       TAVERAGE,  &
       ZINTERP,   &
       DATATYPE

    integer :: fid_conf

    integer :: ierr
    integer :: n, ni
    integer :: memsize

    intrinsic size
    !---------------------------------------------------------------------------

    call Log('I','')
    call Log('I','+++ Module[HISTORY]/Categ[IO]')

    !--- read namelist
    HISTORY_TITLE       = title
    HISTORY_SOURCE      = source
    HISTORY_INSTITUTION = institution
    HISTORY_STARTDAYSEC = time_start
    HISTORY_DTSEC       = time_interval
    if ( present(time_units) ) then
       HISTORY_TIME_UNITS  = time_units
    else
       HISTORY_TIME_UNITS  = 'seconds'
    endif
    if ( present(time_since) ) then
       HISTORY_TIME_SINCE = time_since
    else
       HISTORY_TIME_SINCE = ''
    endif
    if ( present(default_basename) ) then
       HISTORY_DEFAULT_BASENAME = default_basename
    endif
    if ( present(default_tinterval) ) then
       HISTORY_DEFAULT_TINTERVAL = default_tinterval
       if ( present(default_tunit) ) then
          HISTORY_DEFAULT_TUNIT = default_tunit
       endif
    endif
    if ( present(default_taverage) ) then
       HISTORY_DEFAULT_TAVERAGE = default_taverage
    endif
    if ( present(default_zinterp) ) then
       HISTORY_DEFAULT_ZINTERP = default_zinterp
    endif
    if ( present(default_datatype) ) then
       HISTORY_DEFAULT_DATATYPE = default_datatype
    endif

    if ( present(namelist_fid) ) then
       fid_conf = namelist_fid
       rewind(fid_conf)
    elseif( present(namelist_filename) ) then
       if ( namelist_filename /= '' ) then
          open( fid_conf, file = trim(namelist_filename), &
               form = 'formatted', status = 'old', iostat = ierr)
       else
          call Log('I','*** Brank namelist file was specified. Default used. ***')
          fid_conf = -1
       endif
    else
       call Log('I','*** No namelist was specified. Default used. ***')
       fid_conf = -1
    endif

    if ( fid_conf > 0 ) then
       read(fid_conf, nml=PARAM_HISTORY, iostat=ierr)

       if    ( ierr < 0 ) then !--- missing
          call Log('I','*** Not found namelist. Default used.')
       elseif( ierr > 0 ) then !--- fatal error
          call Log('E', 'xxx Not appropriate names in namelist PARAM_HISTORY. Check!')
       endif
#if defined(__PGI) || defined(__ES2)
       write(LOG_fid,nml=PARAM_HISTORY)
#else
       write(message,nml=PARAM_HISTORY)
       call Log('I',message)
#endif
    endif

    ! listup history request
    History_req_nmax = 0
    if ( fid_conf > 0 ) then
       rewind( fid_conf )
       do n = 1, History_req_limit
          BASENAME  = HISTORY_DEFAULT_BASENAME
          read(fid_conf, nml=HISTITEM, iostat=ierr)
          if( ierr /= 0 ) exit
          if( BASENAME /= "" ) History_req_nmax = History_req_nmax + 1
       enddo
    endif

    if    ( History_req_nmax > History_req_limit ) then
       write(message,*) '*** request of history file is exceed! n >', History_req_limit
       call Log('I',message)
    elseif( History_req_nmax == 0 ) then
       call Log('I','*** No history file specified.')
       return
    endif

    allocate( History_item    (History_req_nmax) ); History_item(:) = ''
    allocate( History_fid     (History_req_nmax) )
    allocate( History_vid     (History_req_nmax) )
    allocate( History_tintsec (History_req_nmax) )
    allocate( History_tintstep(History_req_nmax) )
    allocate( History_tavg    (History_req_nmax) )
    allocate( History_zinterp (History_req_nmax) )

    allocate( History_varsum  (array_size,History_req_nmax) )
    allocate( History_size    (History_req_nmax) )
    allocate( History_tstart  (History_req_nmax) )
    allocate( History_tstrstep(History_req_nmax) )
    allocate( History_tlststep(History_req_nmax) )
    allocate( History_tsumsec (History_req_nmax) )

    allocate( History_axis_written (History_req_nmax) )

    if ( fid_conf > 0 ) rewind(fid_conf)
    memsize = 0
    ni = 0
    do n = 1, History_req_limit
       ! set default
       BASENAME  = HISTORY_DEFAULT_BASENAME
       ITEM      = 'unknown'
       TINTERVAL = HISTORY_DEFAULT_TINTERVAL
       TUNIT     = HISTORY_DEFAULT_TUNIT
       TAVERAGE  = HISTORY_DEFAULT_TAVERAGE
       ZINTERP   = HISTORY_DEFAULT_ZINTERP
       DATATYPE  = HISTORY_DEFAULT_DATATYPE

       if ( fid_conf > 0 ) then
          read(fid_conf, nml=HISTITEM,iostat=ierr)
          if( ierr /= 0 ) exit
       endif

       if ( BASENAME == "" ) cycle
       ni = ni + 1

       History_req_item    (ni) = ITEM
       History_req_basename(ni) = BASENAME
       call CalendarYmdhms2sec( History_req_tintsec(ni), TINTERVAL, TUNIT )
       History_req_tintstep(ni) = int( History_req_tintsec(ni) / HISTORY_DTSEC )

       History_req_tavg    (ni) = TAVERAGE
       History_req_zinterp (ni) = ZINTERP

       if ( History_req_tintsec(ni) <= 0.D0 ) then
          write(message,*) 'xxx Not appropriate time interval. Check!', ITEM, TINTERVAL
          call Log('E',message)
       endif

       if ( abs(History_req_tintsec(ni)-real(History_req_tintstep(ni),kind=DP)*HISTORY_DTSEC) > eps ) then
          write(message,*) 'xxx time interval must be a multiple of delta t ', &
                           History_req_tintsec(ni), real(History_req_tintstep(ni),kind=DP)*HISTORY_DTSEC
          call Log('E',message)
       endif

       if    ( DATATYPE == 'REAL4' ) then
          History_req_dtype(n) = File_REAL4
       elseif( DATATYPE == 'REAL8' ) then
          History_req_dtype(n) = File_REAL8
       else
          write(message,*) 'xxx Not appropriate DATATYPE. Check!', DATATYPE
          call Log('E',message)
       endif

       memsize = memsize + array_size * File_preclist(History_req_dtype(ni))
    enddo

    write(message,*) '*** Number of requested history item             : ', History_req_nmax
    call Log('I',message)
    write(message,*) '*** Output default data type                     : ', HISTORY_DEFAULT_DATATYPE
    call Log('I',message)
    write(message,*) '*** Memory usage for history data buffer [Mbyte] : ', memsize/1024/1024
    call Log('I',message)

    if ( (.not. present(namelist_fid)) ) then
       if ( fid_conf > 0 ) close(fid_conf)
    endif

    History_master = master
    History_myrank = myrank

    allocate( History_rankidx(size(rankidx)) )
    History_rankidx(:) = rankidx(:)

    return
  end subroutine HistoryInit

  !-----------------------------------------------------------------------------
  subroutine HistoryAddVariable( &
       varname,  &
       dims,     &
       desc,     &
       units,    &
       now_step, &
       id,       &
       zinterp,  &
       existed,  &
       options   )
    use gtool_file, only: &
       FileCreate,      &
       FileSetOption,   &
       FileAddVariable, &
       FileSetTAttr,    &
       FileDefAxis,     &
       FileDefAssociatedCoordinates
    implicit none

    character(len=*), intent(in)  :: varname
    character(len=*), intent(in)  :: dims(:)
    character(len=*), intent(in)  :: desc
    character(len=*), intent(in)  :: units
    integer,          intent(in)  :: now_step
    integer,          intent(out) :: id
    logical,          intent(out) :: zinterp
    logical,          intent(out) :: existed
    character(len=*), intent(in), optional :: options ! 'filetype1:key1=val1&filetype2:key2=val2&...'

    character(len=File_HMID) :: tunits

    logical :: fileexisted
    integer :: nmax, reqid
    integer :: n, m
    integer :: ic, ie, is, lo

    intrinsic size
    !---------------------------------------------------------------------------

    existed = .false.

    !--- search existing item
    id = -1
    nmax = min( History_id_count, History_req_nmax )
    do n = 1, nmax
       if ( varname == History_item(n) ) then ! match existing item
          id      = n
          zinterp = History_zinterp(n)
          existed = .true.
          return
       endif
    enddo

    if ( id < 0 ) then ! request-register matching check

       ! new file registration
       if ( HISTORY_TIME_SINCE == '' ) then
          tunits = HISTORY_TIME_UNITS
       else
          tunits = trim(HISTORY_TIME_UNITS)//' since '//trim(HISTORY_TIME_SINCE)
       endif

       do n = 1, History_req_nmax
          if ( varname == History_req_item(n) ) then
             reqid = n
             if( History_req_basename(reqid) == '' ) exit
             History_id_count = History_id_count + 1
             id = History_id_count

             call FileCreate( History_fid(id),                   & ! (out)
                              fileexisted,                       & ! (out)
                              trim(History_req_basename(reqid)), & ! (in)
                              HISTORY_TITLE,                     & ! (in)
                              HISTORY_SOURCE,                    & ! (in)
                              HISTORY_INSTITUTION,               & ! (in)
                              History_master,                    & ! (in)
                              History_myrank,                    & ! (in)
                              History_rankidx,                   & ! (in)
                              time_units = tunits                ) ! (in)

             if ( .not. fileexisted ) then

                if ( present(options) ) then
                   ic = -1 ! index of ':'
                   ie = -1 ! index of '='
                   is =  1 ! start index
                   lo = len_trim(options)
                   do m = 1, lo+1
                      if ( m == lo+1 .or. options(m:m) == '&' ) then
                         if ( ic == -1 .or. ie == -1 ) then
                            call Log('E', 'xxx option is invalid: ' // trim(options))
                         endif
                         call FileSetOption(History_fid(id),        & ! (in)
                              options(is:ic-1),                     & ! (in)
                              options(ic+1:ie-1), options(ie+1:m-1) ) ! (in)
                         ic = -1
                         ie = -1
                         is = m + 1
                      elseif( options(m:m) == ':' ) then
                         ic = m
                      elseif( options(m:m) == '=' ) then
                         ie = m
                      endif
                   enddo
                endif

                ! define registered history variables in file
                do m = 1, History_axis_count
                   History_axis(m)%id = id
                   call FileDefAxis( History_fid(id),                                & ! (in)
                                     History_axis(m)%name,  History_axis(m)%desc,    & ! (in)
                                     History_axis(m)%units, History_axis(m)%dim,     & ! (in)
                                     History_axis(m)%type,  History_axis(m)%dim_size ) ! (in)
                enddo

                do m = 1, History_assoc_count
                   History_assoc(m)%id = id
                   call FileDefAssociatedCoordinates( History_fid(id),                                 & ! (in)
                                                      History_assoc(m)%name, History_assoc(m)%desc,    & ! (in)
                                                      History_assoc(m)%units,                          & ! (in)
                                                      History_assoc(m)%dims(1:History_assoc(m)%ndims), & ! (in)
                                                      History_assoc(m)%type                            ) ! (in)
                enddo
                History_axis_written(id) = .FALSE.

             endif

             History_item    (id) = varname
             History_tintsec (id) = History_req_tintsec (reqid)
             History_tintstep(id) = History_req_tintstep(reqid)
             History_tavg    (id) = History_req_tavg    (reqid)
             History_zinterp (id) = History_req_zinterp (reqid)

             History_varsum(:,id) = 0.D0

             if ( HISTORY_OUTPUT_STEP0 .and. now_step==1 ) then
                History_tstrstep(id) = 1 - History_tintstep(id)
             else
                History_tstrstep(id) = 1
             endif
             if ( History_output_start > 0.0_DP ) then
                History_tstart(id) = HISTORY_STARTDAYSEC + History_output_start
             else
                History_tstart(id) = HISTORY_STARTDAYSEC
             endif
             History_tlststep(id) = History_tstrstep(id)
             History_tsumsec (id) = 0.D0

             call FileAddVariable( History_vid(id),            & ! (out)
                                   History_fid(id),            & ! (in)
                                   varname, desc, units, dims, & ! (in)
                                   History_req_dtype(reqid),   & ! (in)
                                   History_tintsec(id),        & ! (in)
                                   History_tavg   (id)         ) ! (in)

             if ( .not. fileexisted ) then
                do m = 1, History_axis_count
                   if ( History_axis(m)%down ) then
                      call FileSetTAttr( History_fid(id), History_axis(m)%name, "positive", "down" )
                   endif
                enddo
             endif

             write(message,*) '*** [HIST] Item registration No.= ', id
             call Log('I',message)
             write(message,*) '] Name                : ', trim(History_item(id))
             call Log('I',message)
             write(message,*) '] Description         : ', trim(desc)
             call Log('I',message)
             write(message,*) '] Unit                : ', trim(units)
             call Log('I',message)
             write(message,*) '] Interval [sec]      : ', History_tintsec (id)
             call Log('I',message)
             write(message,*) '] Interval [step]     : ', History_tintstep(id)
             call Log('I',message)
             write(message,*) '] Time Average?       : ', History_tavg    (id)
             call Log('I',message)
             write(message,*) '] z* -> z conversion? : ', History_zinterp (id)
             call Log('I',message)
             call Log('I','')

             zinterp = History_zinterp(id)

             exit
          endif
       enddo

    endif

    return
  end subroutine HistoryAddVariable

  !-----------------------------------------------------------------------------
  subroutine HistoryWriteAxes
    use gtool_file, only: &
       FileEndDef,        &
       FileWriteAxis,     &
       FileWriteAssociatedCoordinates
    implicit none

    integer :: m
    !---------------------------------------------------------------------------

    if ( History_req_nmax == 0 ) return

    ! Assume all history axes are written into the same file
    if ( History_axis_written(History_axis(1)%id) ) return

    call FileEndDef( History_fid(History_axis(1)%id) )

    ! write registered history variables to file
    do m = 1, History_axis_count
       call FileWriteAxis( History_fid(History_axis(m)%id), & ! (in)
                           History_axis(m)%name,            & ! (in)
                           History_axis(m)%var              ) ! (in)
    enddo

    do m = 1, History_assoc_count
       call FileWriteAssociatedCoordinates( History_fid(History_assoc(m)%id), & ! (in)
                                            History_assoc(m)%name,            & ! (in)
                                            History_assoc(m)%var              ) ! (in)
    enddo

    History_axis_written(History_axis(1)%id) = .TRUE.

    return
  end subroutine HistoryWriteAxes

  !-----------------------------------------------------------------------------
  ! interface HistoryPutAxis
  !-----------------------------------------------------------------------------
% ["SP", "DP"].each do |rp|
  subroutine HistoryPutAxis<%=rp%>( &
       name,  & ! (in)
       desc,  & ! (in)
       units, & ! (in)
       dim,   & ! (in)
       var,   & ! (in)
       dtype, & ! (in) optional
       down   ) ! (in) optional
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim
    real(<%=rp%>),         intent(in) :: var(:)
    character(len=*), intent(in), optional :: dtype
    logical,          intent(in), optional :: down

    integer :: type
    !---------------------------------------------------------------------------

    if ( present(dtype) ) then
       if    ( dtype == 'REAL4' ) then
          type = File_REAL4
       elseif( dtype == 'REAL8' ) then
          type = File_REAL8
       else
          write(message,*) 'xxx Not appropriate dtype. Check!', dtype
          call Log('E',message)
       endif
    else
       type = <%= rp=="SP" ? "File_REAL4" : "File_REAL8" %>
    endif

    if ( History_axis_count < History_axis_limit ) then
       History_axis_count = History_axis_count + 1

       History_axis(History_axis_count)%name     = name
       History_axis(History_axis_count)%desc     = desc
       History_axis(History_axis_count)%units    = units
       History_axis(History_axis_count)%dim      = dim
       History_axis(History_axis_count)%type     = type
       History_axis(History_axis_count)%dim_size = size(var)

       allocate(History_axis(History_axis_count)%var(size(var)))
       History_axis(History_axis_count)%var      = var

       if ( present(down) ) then
          History_axis(History_axis_count)%down = down
       else
          History_axis(History_axis_count)%down = .false.
       endif
    else
       write(message,*) 'xxx Number of axis exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine HistoryPutAxis<%=rp%>
%end

% for n in 1..4
%   ["SP", "DP"].each do |rp|
  !-----------------------------------------------------------------------------
  !> interface HistoryPutAssociatedCoordinates
  subroutine HistoryPut<%=n%>DAssociatedCoordinates<%=rp%>( &
       name,  & ! (in)
       desc,  & ! (in)
       units, & ! (in)
       dims,  & ! (in)
       var,   & ! (in)
       dtype  ) ! (in) optional
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dims(:)
    real(<%=rp%>),         intent(in) :: var (<%=Array.new(n){":"}.join(",")%>)
    character(len=*), intent(in), optional :: dtype

    integer :: type
    !---------------------------------------------------------------------------

    if ( present(dtype) ) then
       if    ( dtype == 'REAL4' ) then
          type = File_REAL4
       elseif( dtype == 'REAL8' ) then
          type = File_REAL8
       else
          write(message,*) 'xxx Not appropriate dtype. Check!', dtype
          call Log('E',message)
       endif
    else
       type = <%= rp=="SP" ? "File_REAL4" : "File_REAL8" %>
    endif

    if ( History_assoc_count < History_assoc_limit ) then
       History_assoc_count = History_assoc_count + 1

       History_assoc(History_assoc_count)%name      = name
       History_assoc(History_assoc_count)%desc      = desc
       History_assoc(History_assoc_count)%units     = units
       History_assoc(History_assoc_count)%dims(1:<%=n%>) = dims
       History_assoc(History_assoc_count)%ndims     = <%=n%>
       History_assoc(History_assoc_count)%type      = type

       allocate(History_assoc(History_assoc_count)%var(size(var)))
       History_assoc(History_assoc_count)%var       = reshape(var, (/size(var)/))
    else
       write(message,*) 'xxx Number of associate coordinates exceeds the limit.'
       call Log('E',message)
    endif

    return
  end subroutine HistoryPut<%=n%>DAssociatedCoordinates<%=rp%>

%  end
% end
  !-----------------------------------------------------------------------------
  ! HistorySetTAttr
  subroutine HistorySetTAttr( &
       varname, &
       key,     &
       val      )
    use gtool_file, only: &
       FileSetTAttr
    implicit none

    character(len=*), intent(in) :: varname
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer :: n
    !---------------------------------------------------------------------------

    do n = 1, History_id_count
       call FileSetTAttr( History_fid(n), & ! (in)
                          varname,        & ! (in)
                          key,            & ! (in)
                          val             ) ! (in)
    enddo

  end subroutine HistorySetTAttr

  !-----------------------------------------------------------------------------
  ! HistoryQuery
  subroutine HistoryQuery( &
       itemid,    &
       step_next, &
       answer     )
    implicit none

    integer, intent(in)  :: itemid
    integer, intent(in)  :: step_next
    logical, intent(out) :: answer
    !---------------------------------------------------------------------------

    answer = .false.

    if    ( History_tavg(itemid) ) then
       answer = .true.
    elseif( step_next == History_tstrstep(itemid) + History_tintstep(itemid) ) then
       answer = .true.
    endif

    return
  end subroutine HistoryQuery

% for n in 0..3
%   varDecl  = (n==0) ? "var" : "var(#{([":"]*n).join(",")})"
%   var_elem = (n==0) ? "var" : "var(#{["i","j","k"][0...n].join(",")})"
%   ["SP", "DP"].each do |rp|
  !-----------------------------------------------------------------------------
  ! interface HistoryPut(by NAME)
  subroutine HistoryPut<%=n%>DName<%=rp%>( &
       varname,   &
       step_next, &
       var        )
    implicit none

    character(len=*), intent(in) :: varname
    integer,          intent(in) :: step_next
    real(<%=rp%>),         intent(in) :: <%=varDecl%>

    integer :: itemid, n
    !---------------------------------------------------------------------------

    ! search item id
    itemid = -1
    do n = 1, History_id_count
       if ( varname == History_item(n) ) then
          itemid = n
          exit
       endif
    enddo

    call HistoryPut<%=n%>DId<%=rp%>(itemid, step_next, var)

    return
  end subroutine HistoryPut<%=n%>DName<%=rp%>

  !-----------------------------------------------------------------------------
  ! interface HistoryPut(by ID)
  subroutine HistoryPut<%=n%>DId<%=rp%>( &
       itemid,    &
       step_next, &
       var        )
    implicit none

    integer,  intent(in) :: itemid
    integer,  intent(in) :: step_next
    real(<%=rp%>), intent(in) :: <%=varDecl%>

    real(DP) :: dt
    integer  :: idx
% if n > 0 then
    integer  :: ijk(<%=n%>)
    integer  :: <%= ["i", "j", "k"][0...n].join(", ")%>
% end

    intrinsic shape
    !---------------------------------------------------------------------------

    if ( itemid < 0 ) return

% if n > 0 then
    ijk = shape(var)
% end
    dt  = ( step_next - History_tlststep(itemid) ) * HISTORY_DTSEC

    if ( dt < eps .AND. ( .NOT. History_tavg(itemid) ) ) then
       write(message,*) 'xxx History variable was put two times before output!: ', &
                        trim(History_item(itemid)), step_next, History_tlststep(itemid)
       call Log('E',message)
    endif

    if ( History_tavg(itemid) ) then
% n.times do |i|
       do <%=["i","j","k"][0...n][n-i-1]%> = 1, ijk(<%=n-i%>)
% end
% if n==0 then
          idx = 1
% else
          idx = <%=["i", "j*ijk(i)+i", "(k*ijk(2)+j)*ijk(1)+i"][n-1]%>
% end
          History_varsum(idx,itemid) = History_varsum(idx,itemid) + <%=var_elem%> * dt
% n.times do |i|
       enddo
% end
    else
% n.times do |i|
       do <%=["i","j","k"][0...n][n-i-1]%> = 1, ijk(<%=n-i%>)
% end
% if n==0 then
          idx = 1
% else
          idx = <%=["i", "j*ijk(i)+i", "(k*ijk(2)+j)*ijk(1)+i"][n-1]%>
% end
          History_varsum(idx,itemid) = <%=var_elem%>
% n.times do |i|
       enddo
% end
    endif

    History_size    (itemid) = idx
    History_tlststep(itemid) = step_next
    History_tsumsec (itemid) = History_tsumsec(itemid) + dt

    return
  end subroutine HistoryPut<%=n%>DId<%=rp%>

%   end
% end
  !-----------------------------------------------------------------------------
  ! HistoryWrite
  subroutine HistoryWrite( &
       itemid,  &
       step_now )
    use dc_calendar, only: &
       CalendarSec2ymdhms
    use gtool_file, only: &
       FileWrite
    implicit none

    integer, intent(in) :: itemid
    integer, intent(in) :: step_now

    integer  :: isize
    real(DP) :: time_str, time_end
    real(DP) :: sec_str,  sec_end

    real(DP), save :: sec_end_last = -1.0_DP
    logical,  save :: firsttime    = .true.
    !---------------------------------------------------------------------------

    if( History_id_count == 0 ) return

    if ( step_now < History_tstrstep(itemid) + History_tintstep(itemid) ) then
       return
    endif

    if ( History_tlststep(itemid) == History_tstrstep(itemid) ) then
       write(message,*) 'xxx History variable was never put after the last output!: ', &
                        trim(History_item(itemid))
       if ( HISTORY_ERROR_PUTMISS ) then
          call Log('E',message)
       else
          call Log('I',message)
       endif
    endif

    isize = History_size(itemid)

    if ( History_tavg(itemid) ) then
       History_varsum(1:isize,itemid) = History_varsum(1:isize,itemid) / History_tsumsec(itemid)
    endif

    if ( firsttime ) then
       firsttime = .false.
       call HistoryOutputList
    endif

    sec_str = HISTORY_STARTDAYSEC + real(History_tstrstep(itemid)-1,kind=DP) * HISTORY_DTSEC
    sec_end = HISTORY_STARTDAYSEC + real(step_now-1                ,kind=DP) * HISTORY_DTSEC

    ! convert time units
    call CalendarSec2ymdhms( time_str, sec_str, HISTORY_TIME_UNITS )
    call CalendarSec2ymdhms( time_end, sec_end, HISTORY_TIME_UNITS )

    if ( sec_end .ge.  History_tstart(itemid) ) then
       if ( sec_end_last < sec_end ) then
          write(message,'(A)') '*** Output History'
          call Log('I',message)
       endif

       call FileWrite( History_fid   (itemid),         & ! file id
                       History_vid   (itemid),         & ! variable id
                       History_varsum(1:isize,itemid), & ! data
                       time_str,                       & ! start time
                       time_end                        ) ! end   time
    else
       if ( sec_end_last < sec_end ) then
          write(message,'(A,2F15.3)') '*** Output History: Suppressed ', sec_end, History_tstart(itemid)
          call Log('I',message)
       endif
    endif

    History_varsum(:,itemid) = 0.0_DP
    History_tstrstep(itemid) = step_now
    History_tlststep(itemid) = step_now
    History_tsumsec (itemid) = 0.0_DP

    sec_end_last = sec_end

    return
  end subroutine HistoryWrite

  !-----------------------------------------------------------------------------
  ! HistoryWritaAll
  subroutine HistoryWriteAll( &
       step_now )
    implicit none

    integer, intent(in) :: step_now

    integer :: n
    !---------------------------------------------------------------------------

    ! Write registered axis variables to history file
    ! This subroutine must be called after all HIST_reg calls are completed
    call HistoryWriteAxes

    do n = 1, History_id_count
       call HistoryWrite( n, step_now )
    enddo

    return
  end subroutine HistoryWriteAll

% for n in 1..3
%  ["DP", "SP"].each do |rp|
  !-----------------------------------------------------------------------------
  ! interface HistoryGet
  subroutine HistoryGet<%=n%>D<%=rp%>( &
       var,           &
       basename,      &
       varname,       &
       step,          &
       allow_missing, &
       single         )
    use gtool_file, only: &
       FileRead
    implicit none

    real(<%=rp%>),         intent(out) :: var(<%=([":"]*n).join(",")%>)
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: varname
    integer,          intent(in)  :: step
    logical,          intent(in), optional :: allow_missing
    logical,          intent(in), optional :: single
    !---------------------------------------------------------------------------

    call FileRead( var,            & ! [OUT]
                   basename,       & ! [IN]
                   varname,        & ! [IN]
                   step,           & ! [IN]
                   History_myrank, & ! [IN]
                   allow_missing,  & ! [IN]
                   single          ) ! [IN]

    return
  end subroutine HistoryGet<%=n%>D<%=rp%>

%   end
% end
  !-----------------------------------------------------------------------------
  subroutine HistoryOutputList
    implicit none

    integer :: n
    !---------------------------------------------------------------------------

    call Log('I','')
    write(message,*) '*** [HIST] Output item list '
    call Log('I',message)
    write(message,*) '*** Number of history item :', History_req_nmax
    call Log('I',message)
    write(message,*) 'NAME            :size    :interval[sec]:  [step]:timeavg?:zinterp?'
    call Log('I',message)
    write(message,*) '============================================================================'
    call Log('I',message)

    do n = 1, History_id_count
       write(message,'(1x,A,1x,I8,1x,f13.3,1x,I8,1x,L8,1x,L8)') &
                     History_item(n), History_size(n), History_tintsec(n), History_tintstep(n), History_tavg(n), History_zinterp(n)
       call Log('I',message)
    enddo

    write(message,*) '============================================================================'
    call Log('I',message)
    call Log('I','')

    return
  end subroutine HistoryOutputList

  !-----------------------------------------------------------------------------
  subroutine HistoryFinalize
    use gtool_file, only: &
       FileClose
    implicit none

    integer :: n
    !---------------------------------------------------------------------------

    do n = 1, History_id_count
       call FileClose( History_fid(n) )
    enddo

    return
  end subroutine HistoryFinalize

end module gtool_history
!-------------------------------------------------------------------------------



!--
! vi<%=":"%>set readonly sw=4 ts=8
!
!Local Variables<%=":"%>
!mode: f90
!buffer-read-only:t
!End:
!
!++
