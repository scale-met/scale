!-------------------------------------------------------------------------------
!> module ATMOSPHERE / Physics Turbulence
!!
!! @par Description
!!          Boundary layer turbulence model
!!          Mellor-Yamada Nakanishi-Niino model
!!
!! @author Team SCALE
!!
!! @par History
!! @li      2014-08-27 (S.Nishizawa) [new]
!!
!! - Reference
!!  - Nakanishi and Niino, 2009:
!!    Development of an improved turbulence closure model for the atmospheric boundary layer.
!!    J. Meteorol. Soc. Japan, 87, 895-912
!!
!<
!-------------------------------------------------------------------------------
#include "inc_openmp.h"
module scale_atmos_phy_tb_mynn
  !-----------------------------------------------------------------------------
  !
  !++ used modules
  !
  use scale_precision
  use scale_stdio
  use scale_prof
  use scale_grid_index
  use scale_tracer

#include "macro_thermodyn.h"

#if defined DEBUG || defined QUICKDEBUG
  use scale_debug, only: &
     CHECK
  use scale_const, only: &
     UNDEF  => CONST_UNDEF, &
     IUNDEF => CONST_UNDEF2
#endif
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedure
  !
  public :: ATMOS_PHY_TB_mynn_config
  public :: ATMOS_PHY_TB_mynn_setup
  public :: ATMOS_PHY_TB_mynn

  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private procedure
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private parameters & variables
  !
  real(RP), private, parameter :: OneOverThree = 1.0_RP / 3.0_RP
  real(RP), private, parameter :: TKE_min      = 1.E-10_RP
  real(RP), private, parameter :: LT_min       = 1.E-6_RP
  real(RP), private, parameter :: Us_min       = 1.E-6_RP

  real(RP), private            :: A1
  real(RP), private            :: A2
  real(RP), private, parameter :: B1 = 24.0_RP
  real(RP), private, parameter :: B2 = 15.0_RP
  real(RP), private            :: C1
  real(RP), private, parameter :: C2 = 0.75_RP
  real(RP), private, parameter :: C3 = 0.352_RP
  real(RP), private, parameter :: C5 = 0.2_RP
  real(RP), private, parameter :: G1 = 0.235_RP
  real(RP), private            :: G2
  real(RP), private            :: F1
  real(RP), private            :: F2
  real(RP), private            :: Rf1
  real(RP), private            :: Rf2
  real(RP), private            :: Rfc
  real(RP), private            :: AF12 !< A1 F1 / A2 F2
  real(RP), private, parameter :: PrN = 0.74_RP

  real(RP), private            :: SQRT_2PI
  real(RP), private            :: RSQRT_2PI
  real(RP), private            :: RSQRT_2

  integer,  private            :: I_TKE

  integer,  private            :: KE_PBL
  logical,  private            :: ATMOS_PHY_TB_MYNN_TKE_INIT = .false.    !< set tke with that of level 2 at the first time if .true.
  real(RP), private            :: ATMOS_PHY_TB_MYNN_N2_MAX   =   1.E+3_RP
  real(RP), private            :: ATMOS_PHY_TB_MYNN_NU_MIN   =   1.E-6_RP
  real(RP), private            :: ATMOS_PHY_TB_MYNN_NU_MAX   = 10000.0_RP
  real(RP), private            :: ATMOS_PHY_TB_MYNN_KH_MIN   =   1.E-6_RP
  real(RP), private            :: ATMOS_PHY_TB_MYNN_KH_MAX   = 10000.0_RP
  real(RP), private            :: ATMOS_PHY_TB_MYNN_Lt_MAX   =   700.0_RP ! ~ 0.23 * 3 km

  !-----------------------------------------------------------------------------
contains
  !-----------------------------------------------------------------------------
  !> Config
  subroutine ATMOS_PHY_TB_mynn_config( &
       TYPE_TB,  &
       I_TKE_out )
    use scale_process, only: &
       PRC_MPIstop
    use scale_tracer, only: &
       TRACER_regist
    implicit none

    character(len=*), intent(in)  :: TYPE_TB
    integer,          intent(out) :: I_TKE_out
    !---------------------------------------------------------------------------

    if( IO_L ) write(IO_FID_LOG,*)
    if( IO_L ) write(IO_FID_LOG,*) '++++++ Module[Turbulence Tracer] / Categ[ATMOS PHYSICS] / Origin[SCALElib]'
    if( IO_L ) write(IO_FID_LOG,*) '*** Tracers for Mellor-Yamada Nakanishi-Niino scheme'

    if ( TYPE_TB /= 'MYNN' ) then
       write(*,*) 'xxx ATMOS_PHY_TB_TYPE is not MYNN. Check!'
       call PRC_MPIstop
    endif

    call TRACER_regist( I_TKE,                                   & ! [OUT]
                        1,                                       & ! [IN]
                        (/ 'TKE_MYNN' /),                        & ! [IN]
                        (/ 'turbulent kinetic energy (MYNN)' /), & ! [IN]
                        (/ 'm2/s2' /)                            ) ! [IN]

    I_TKE_out = I_TKE

    return
  end subroutine ATMOS_PHY_TB_mynn_config

  !-----------------------------------------------------------------------------
  !> Setup
  subroutine ATMOS_PHY_TB_mynn_setup( &
       CDZ, CDX, CDY, CZ )
    use scale_process, only: &
       PRC_MPIstop
    use scale_const, only: &
       PI => CONST_PI
    implicit none

    real(RP), intent(in) :: CDZ(KA)
    real(RP), intent(in) :: CDX(IA)
    real(RP), intent(in) :: CDY(JA)
    real(RP), intent(in) :: CZ (KA,IA,JA)

    real(RP) :: ATMOS_PHY_TB_MYNN_PBL_MAX = 1.E+10_RP !< maximum height of the PBL

    NAMELIST / PARAM_ATMOS_PHY_TB_MYNN / &
       ATMOS_PHY_TB_MYNN_TKE_INIT, &
       ATMOS_PHY_TB_MYNN_PBL_MAX,  &
       ATMOS_PHY_TB_MYNN_N2_MAX,   &
       ATMOS_PHY_TB_MYNN_NU_MIN,   &
       ATMOS_PHY_TB_MYNN_NU_MAX,   &
       ATMOS_PHY_TB_MYNN_KH_MIN,   &
       ATMOS_PHY_TB_MYNN_KH_MAX,   &
       ATMOS_PHY_TB_MYNN_Lt_MAX

    integer :: ierr
    integer :: k, i, j
    !---------------------------------------------------------------------------

    if( IO_L ) write(IO_FID_LOG,*)
    if( IO_L ) write(IO_FID_LOG,*) '++++++ Module[Turbulence] / Categ[ATMOS PHYSICS] / Origin[SCALElib]'
    if( IO_L ) write(IO_FID_LOG,*) '*** Mellor-Yamada Nakanishi-Niino scheme'

    !--- read namelist
    rewind(IO_FID_CONF)
    read(IO_FID_CONF,nml=PARAM_ATMOS_PHY_TB_MYNN,iostat=ierr)
    if( ierr < 0 ) then !--- missing
       if( IO_L ) write(IO_FID_LOG,*) '*** Not found namelist. Default used.'
    elseif( ierr > 0 ) then !--- fatal error
       write(*,*) 'xxx Not appropriate names in namelist PARAM_ATMOS_PHY_TB_MYNN. Check!'
       call PRC_MPIstop
    endif
    if( IO_NML ) write(IO_FID_NML,nml=PARAM_ATMOS_PHY_TB_MYNN)

    do k = KS, KE-1
       do j = JS, JE
       do i = IS, IE
          if ( ATMOS_PHY_TB_MYNN_PBL_MAX >= CZ(k,i,j) ) then
             KE_PBL = k
          end if
       end do
       end do
    end do

    A1        = B1 * (1.0_RP - 3.0_RP * G1) / 6.0_RP
    A2        = 1.0_RP / (3.0_RP * G1 * B1**(1.0_RP/3.0_RP) * PrN )
    C1        = G1 - 1.0_RP / ( 3.0_RP * A1 * B1**(1.0_RP/3.0_RP) )
    G2        = ( 2.0_RP * A1 * (3.0_RP - 2.0_RP * C2) + B2 * (1.0_RP - C3) ) / B1
    F1        = B1 * (G1 - C1) + 2.0_RP * A1 * (3.0_RP - 2.0_RP * C2) + 3.0_RP * A2 * (1.0_RP - C2) * (1.0_RP - C5)
    F2        = B1 * (G1 + G2) - 3.0_RP * A1 * (1.0_RP - C2)

    Rf1       = B1 * (G1 - C1) / F1
    Rf2       = B1 * G1 / F2
    Rfc       = G1 / (G1 + G2)

    AF12      = A1 * F1 / ( A2 * F2 )

    SQRT_2PI  = sqrt( 2.0_RP * PI )
    RSQRT_2PI = 1.0_RP / SQRT_2PI
    RSQRT_2   = 1.0_RP / sqrt( 2.0_RP )

    return
  end subroutine ATMOS_PHY_TB_mynn_setup

  !-----------------------------------------------------------------------------
  subroutine ATMOS_PHY_TB_mynn( &
       qflx_sgs_momz, qflx_sgs_momx, qflx_sgs_momy, &
       qflx_sgs_rhot, qflx_sgs_rhoq,                &
       RHOQ_t,                                      &
       Nu, Ri, Pr,                                  &
       MOMZ, MOMX, MOMY, RHOT, DENS, QTRC, N2_in,   &
       SFLX_MW, SFLX_MU, SFLX_MV, SFLX_SH, SFLX_Q,  &
       GSQRT, J13G, J23G, J33G, MAPF, dt            )
    use scale_precision
    use scale_grid_index
    use scale_tracer
    use scale_const, only: &
       GRAV    => CONST_GRAV,  &
       R       => CONST_Rdry,  &
       Rvap    => CONST_Rvap,  &
       CPdry   => CONST_CPdry, &
       CPvap   => CONST_CPvap, &
       LHV0    => CONST_LHV0,  &
       EPSTvap => CONST_EPSTvap
    use scale_grid, only: &
       RCDZ => GRID_RCDZ, &
       RFDZ => GRID_RFDZ
    use scale_grid_real, only: &
       CZ => REAL_CZ
    use scale_gridtrans, only: &
       I_XYZ, &
       I_XYW, &
       I_XVW, &
       I_UYW
    use scale_comm, only: &
       COMM_vars, &
       COMM_wait
    use scale_atmos_phy_tb_common, only: &
       diffusion_solver => ATMOS_PHY_TB_diffusion_solver
    use scale_atmos_thermodyn, only: &
       ATMOS_THERMODYN_temp_pres
    use scale_atmos_hydrometeor, only: &
       HYDROMETEOR_LHV => ATMOS_HYDROMETEOR_LHV, &
       HYDROMETEOR_LHS => ATMOS_HYDROMETEOR_LHS, &
       I_QV, &
       I_QC, &
       I_QI
    use scale_atmos_saturation, only: &
       ATMOS_SATURATION_dens2qsat => ATMOS_SATURATION_dens2qsat_all
#ifdef MORE_HIST
    use scale_history, only: &
       HIST_in
#endif
    implicit none

    real(RP), intent(out)   :: qflx_sgs_momz(KA,IA,JA,3)
    real(RP), intent(out)   :: qflx_sgs_momx(KA,IA,JA,3)
    real(RP), intent(out)   :: qflx_sgs_momy(KA,IA,JA,3)
    real(RP), intent(out)   :: qflx_sgs_rhot(KA,IA,JA,3)
    real(RP), intent(out)   :: qflx_sgs_rhoq(KA,IA,JA,3,QA)

    real(RP), intent(inout) :: RHOQ_t       (KA,IA,JA,QA) ! tendency of rho * QTRC

    real(RP), intent(out)   :: Nu           (KA,IA,JA)    ! eddy viscosity (center)
    real(RP), intent(out)   :: Ri           (KA,IA,JA)    ! Richardson number
    real(RP), intent(out)   :: Pr           (KA,IA,JA)    ! Plandtle number

    real(RP), intent(in)    :: MOMZ         (KA,IA,JA)
    real(RP), intent(in)    :: MOMX         (KA,IA,JA)
    real(RP), intent(in)    :: MOMY         (KA,IA,JA)
    real(RP), intent(in)    :: RHOT         (KA,IA,JA)
    real(RP), intent(in)    :: DENS         (KA,IA,JA)
    real(RP), intent(in)    :: QTRC         (KA,IA,JA,QA)
    real(RP), intent(in)    :: N2_in        (KA,IA,JA)

    real(RP), intent(in)    :: SFLX_MW      (IA,JA)
    real(RP), intent(in)    :: SFLX_MU      (IA,JA)
    real(RP), intent(in)    :: SFLX_MV      (IA,JA)
    real(RP), intent(in)    :: SFLX_SH      (IA,JA)
    real(RP), intent(in)    :: SFLX_Q       (IA,JA,QA)

    real(RP), intent(in)    :: GSQRT        (KA,IA,JA,7)  !< vertical metrics {G}^1/2
    real(RP), intent(in)    :: J13G         (KA,IA,JA,7)  !< (1,3) element of Jacobian matrix
    real(RP), intent(in)    :: J23G         (KA,IA,JA,7)  !< (1,3) element of Jacobian matrix
    real(RP), intent(in)    :: J33G                       !< (3,3) element of Jacobian matrix
    real(RP), intent(in)    :: MAPF         (IA,JA,2,4)   !< map factor
    real(DP), intent(in)    :: dt

    real(RP) :: U    (KA,IA,JA) !< velocity in x-direction (full level)
    real(RP) :: V    (KA,IA,JA) !< velocity in y-direction (full level)
    real(RP) :: N2   (KA,IA,JA) ! squared Brunt-Vaisala frequency
    real(RP) :: phiN (KA,IA,JA)

    real(RP) :: sm   (KA,IA,JA) !< stability function for velocity
    real(RP) :: sh   (KA,IA,JA) !< stability function for scalars
    real(RP) :: l    (KA,IA,JA) !< length scale L
    real(RP) :: q    (KA,IA,JA) !< q
    real(RP) :: dudz2(KA,IA,JA) !< (dudz)^2 + (dvdz)^2
    real(RP) :: q2_2 (KA,IA,JA) !< q^2 for level 2
    real(RP) :: Kh              !< eddy diffusion coefficient
    real(RP) :: RHOKh(KA,IA,JA) !< mass-weighted eddy diffusion coefficient

    real(RP) :: SFLX_PT(IA,JA)  ! surface potential temperature flux

    real(RP) :: a(KA,IA,JA)
    real(RP) :: b(KA,IA,JA)
    real(RP) :: c(KA,IA,JA)
    real(RP) :: d(KA,IA,JA)
    real(RP) :: ap
    real(RP) :: tke_N(KA,IA,JA)
    real(RP) :: tke

    real(RP) :: POTT(KA,IA,JA)  !< potential temperature
    real(RP) :: POTV(KA,IA,JA)  !< virtual potential temperature
    real(RP) :: POTL(KA,IA,JA)  !< liquid water potential temperature
    real(RP) :: TEML(KA,IA,JA)  !< liquid water temperature

    real(RP) :: Qw(KA,IA,JA)    !< total water
    real(RP) :: qdry(KA,IA,JA)  !< dry air
    real(RP) :: qv              !< water vapor
    real(RP) :: ql              !< liquid water
    real(RP) :: qs              !< solid water

    real(RP) :: temp(KA,IA,JA)  !< temperature
    real(RP) :: pres(KA,IA,JA)  !< pressure

    real(RP) :: LHV (KA,IA,JA)
    real(RP) :: LHS (KA,IA,JA)

    real(RP) :: CPtot

    real(RP) :: ac              !< \alpha_c

    real(RP) :: Q1
    real(RP) :: Qsl(KA)
    real(RP) :: LHVL(KA)
    real(RP) :: dQsl
    real(RP) :: sigma_s
    real(RP) :: RR
    real(RP) :: Rt
    real(RP) :: betat
    real(RP) :: betaq
    real(RP) :: aa
    real(RP) :: bb
    real(RP) :: cc

#ifdef MORE_HIST
    real(RP) :: gen(KA,IA,JA)
#endif

    integer :: IIS, IIE
    integer :: JJS, JJE

    integer :: k, i, j, iq
    !---------------------------------------------------------------------------

    if( IO_L ) write(IO_FID_LOG, *) "*** Atmos physics  step: Turbulence (MYNN)"

#ifdef DEBUG
    POTT(:,:,:) = UNDEF
    POTL(:,:,:) = UNDEF
    temp(:,:,:) = UNDEF
#endif

#if defined DEBUG || defined QUICKDEBUG
    qflx_sgs_momz(KS:KE,   1:IS-1,    :    ,:) = UNDEF
    qflx_sgs_momz(KS:KE,IE+1:IA  ,    :    ,:) = UNDEF
    qflx_sgs_momz(KS:KE,    :    ,   1:JS-1,:) = UNDEF
    qflx_sgs_momz(KS:KE,    :    ,JE+1:JA  ,:) = UNDEF
    qflx_sgs_momx(KS:KE,   1:IS-1,    :    ,:) = UNDEF
    qflx_sgs_momx(KS:KE,IE+1:IA  ,    :    ,:) = UNDEF
    qflx_sgs_momx(KS:KE,    :    ,   1:JS-1,:) = UNDEF
    qflx_sgs_momx(KS:KE,    :    ,JE+1:JA  ,:) = UNDEF
    qflx_sgs_momy(KS:KE,   1:IS-1,    :    ,:) = UNDEF
    qflx_sgs_momy(KS:KE,IE+1:IA  ,    :    ,:) = UNDEF
    qflx_sgs_momy(KS:KE,    :    ,   1:JS-1,:) = UNDEF
    qflx_sgs_momy(KS:KE,    :    ,JE+1:JA  ,:) = UNDEF
#endif

!OCL XFILL
    do j = JS  , JE
    do i = IS-1, IE
    do k = KS-1, KE
       qflx_sgs_momz(k,i,j,XDIR) = 0.0_RP
    end do
    end do
    end do
!OCL XFILL
    do j = JS  , JE
    do i = IS  , IE+1
    do k = KS-1, KE+1
       qflx_sgs_momx(k,i,j,XDIR) = 0.0_RP
    end do
    end do
    end do

!OCL XFILL
    do j = JS  , JE
    do i = IS-1, IE
    do k = KS-1, KE+1
       qflx_sgs_momy(k,i,j,XDIR) = 0.0_RP
    end do
    end do
    end do
!OCL XFILL
    do j = JS  , JE
    do i = IS-1, IE
    do k = KS-1, KE+1
       qflx_sgs_rhot(k,i,j,XDIR) = 0.0_RP
    end do
    end do
    end do
!OCL XFILL
    do iq = 1, QA
    do j = JS  , JE
    do i = IS-1, IE
    do k = KS-1, KE+1
       qflx_sgs_rhoq(k,i,j,XDIR,iq) = 0.0_RP
    end do
    end do
    end do
    end do

!OCL XFILL
    do j = JS-1, JE
    do i = IS  , IE
    do k = KS-1, KE
       qflx_sgs_momz(k,i,j,YDIR) = 0.0_RP
    end do
    end do
    end do
!OCL XFILL
    do j = JS-1, JE
    do i = IS  , IE
    do k = KS-1, KE+1
       qflx_sgs_momx(k,i,j,YDIR) = 0.0_RP
    end do
    end do
    end do
!OCL XFILL
    do j = JS  , JE+1
    do i = IS  , IE
    do k = KS-1, KE+1
       qflx_sgs_momy(k,i,j,YDIR) = 0.0_RP
    end do
    end do
    end do
!OCL XFILL
    do j = JS-1, JE
    do i = IS  , IE
    do k = KS-1, KE+1
       qflx_sgs_rhot(k,i,j,YDIR) = 0.0_RP
    end do
    end do
    end do
!OCL XFILL
    do iq = 1, QA
    do j = JS-1, JE
    do i = IS  , IE
    do k = KS-1, KE+1
       qflx_sgs_rhoq(k,i,j,YDIR,iq) = 0.0_RP
    end do
    end do
    end do
    end do
!OCL XFILL
    do j = JS, JE
    do i = IS, IE
    do k = KS-1, KE+1
       qflx_sgs_momz(k,i,j,ZDIR) = 0.0_RP
    end do
    end do
    end do



    do JJS = JS, JE, JBLOCK
    JJE = JJS+JBLOCK-1
    do IIS = IS, IE, IBLOCK
    IIE = IIS+IBLOCK-1

!OCL XFILL
       do j = JJS  , JJE+1
       do i = IIS-1, IIE+1
       do k = KS, KE_PBL+1
          U(k,i,j) = 0.5_RP * ( MOMX(k,i,j) + MOMX(k,i-1,j) ) / DENS(k,i,j)
       end do
       end do
       end do

!OCL XFILL
       do j = JJS-1, JJE+1
       do i = IIS  , IIE+1
       do k = KS, KE_PBL+1
          V(k,i,j) = 0.5_RP * ( MOMY(k,i,j) + MOMY(k,i,j-1) ) / DENS(k,i,j)
       end do
       end do
       end do

    end do
    end do

    call ATMOS_THERMODYN_temp_pres( temp, pres, & ! (out)
                                    DENS, RHOT, QTRC, & ! (in)
                                    TRACER_CV, TRACER_R, TRACER_MASS ) ! (in)


    call HYDROMETEOR_LHV( LHV(:,:,:), temp(:,:,:) )
    call HYDROMETEOR_LHS( LHS(:,:,:), temp(:,:,:) )

!OCL LOOP_NOFUSION,PREFETCH_SEQUENTIAL(SOFT),SWP
    !$omp parallel do default(none) OMP_SCHEDULE_ collapse(2) &
    !$omp shared(JS,JE,IS,IE,KS,KE_PBL,QA,I_QV,I_QC,I_QI) &
    !$omp shared(GRAV,CPdry,EPSTvap,ATMOS_PHY_TB_MYNN_N2_MAX,CZ) &
    !$omp shared(QTRC,TRACER_MASS,RHOT,DENS,N2_in,SFLX_PT,SFLX_SH) &
    !$omp shared(Qdry,Qw,LHV,LHS,POTT,POTL,temp,TEML,POTV,n2,U,V,Ri,dudz2) &
    !$omp private(i,j,k,iq) &
    !$omp private(qv,ql,qs,CPtot)
    do j = JS, JE
    do i = IS, IE

       do k = KS, KE_PBL+1

          qv = 0.0_RP
          if ( I_QV > 0 ) qv = QTRC(k,i,j,I_QV)

          ql = 0.0_RP
          if ( I_QC > 0 ) ql = QTRC(k,i,j,I_QC)
!          do iq = QWS, QWE
!             ql = ql + QTRC(k,i,j,iq)
!          end do
          qs = 0.0_RP
          if ( I_QI > 0 ) qs = QTRC(k,i,j,I_QI)
!          do iq = QIS, QIE
!             qs = qs + QTRC(k,i,j,iq)
!          end do
          CALC_QDRY(qdry(k,i,j), QTRC, TRACER_MASS, k, i, j, iq)

          Qw(k,i,j) = qv + ql + qs

          CPtot = CPdry * qdry(k,i,j) + CPvap * qv

          POTT(k,i,j) = RHOT(k,i,j) / DENS(k,i,j)
          ! liquid water potential temperature
          POTL(k,i,j) = POTT(k,i,j) * (1.0_RP - 1.0_RP * (LHV(k,i,j) * ql + LHS(k,i,j) * qs) / ( temp(k,i,j) * CPtot ) )
          TEML(k,i,j) = POTL(k,i,j) * temp(k,i,j) / POTT(k,i,j)

          ! virtual potential temperature for derivertive
!          POTV(k,i,j) = ( 1.0_RP + EPSTvap * Qw(k,i,j) ) * POTL(k,i,j)
          POTV(k,i,j) = ( qdry(k,i,j) + (EPSTvap+1.0_RP) * qv ) * POTT(k,i,j)

       end do

       SFLX_PT(i,j) = SFLX_SH(i,j) / ( CPdry * DENS(KS,i,j) ) &
                    * POTT(KS,i,j) / TEMP(KS,i,j)

       do k = KS, KE_PBL
          n2(k,i,j) = min( ATMOS_PHY_TB_MYNN_N2_MAX, N2_in(k,i,j) )
       end do

       dudz2(KS,i,j) = ( ( U(KS+1,i,j) - U(KS,i,j) )**2 + ( V(KS+1,i,j) - V(KS,i,j) )**2 ) &
                     / ( CZ(KS+1,i,j) - CZ(KS,i,j) )**2
       do k = KS+1, KE_PBL
          dudz2(k,i,j) = ( ( U(k+1,i,j) - U(k-1,i,j) )**2 + ( V(k+1,i,j) - V(k-1,i,j) )**2 ) &
                       / ( CZ(k+1,i,j) - CZ(k-1,i,j) )**2
       end do

       do k = KS, KE_PBL
          Ri(k,i,j) = n2(k,i,j) / max(dudz2(k,i,j), 1E-10_RP)
       end do

    end do
    end do

    if ( ATMOS_PHY_TB_MYNN_TKE_INIT ) then
!OCL XFILL
       do j = JS, JE
       do i = IS, IE
       do k = KS, KE_PBL
          q(k,i,j) = sqrt( TKE_MIN*2.0_RP )
       end do
       end do
       end do
    else
!OCL XFILL
       do j = JS, JE
       do i = IS, IE
       do k = KS, KE_PBL
          q(k,i,j) = sqrt( max(QTRC(k,i,j,I_TKE), TKE_MIN)*2.0_RP )
       end do
       end do
       end do
    end if

    ! length
    call get_length( &
         l, & ! (out)
         DENS, & ! (in)
         q, n2, & ! (in)
         SFLX_MU, SFLX_MV, SFLX_PT, & ! (in)
         POTT ) ! (in)

    call get_q2_level2( &
         q2_2, & ! (out)
         dudz2, Ri, l ) ! (in)

    if ( ATMOS_PHY_TB_MYNN_TKE_INIT ) then
!OCL XFILL
       do j = JS, JE
       do i = IS, IE
       do k = KS, KE_PBL
          tke = max(q2_2(k,i,j) * 0.5_RP, TKE_MIN)
          q(k,i,j) = sqrt( tke * 2.0_RP )
       end do
       end do
       end do

       ATMOS_PHY_TB_MYNN_TKE_INIT = .false.
    end if

    call get_smsh( sm, sh, & ! (out)
                   q, q2_2, & ! (in)
                   l, n2, dudz2 ) ! (in)

#if defined DEBUG || defined QUICKDEBUG
    do j = 1, JS-1
    do i = 1, IA
    do k = KS, KE
       TEML(k,i,j) = 300.0_RP
    end do
    end do
    end do
    do j = JE+1, JA
    do i = 1, IA
    do k = KS, KE
       TEML(k,i,j) = 300.0_RP
    end do
    end do
    end do
    do j = 1, JA
       do i = 1, IS-1
       do k = KS, KE
          TEML(k,i,j) = 300.0_RP
       end do
       end do
       do i = IE+1, IA
       do k = KS, KE
          TEML(k,i,j) = 300.0_RP
       end do
       end do
    end do
#endif

!OCL LOOP_NOFUSION,PREFETCH_SEQUENTIAL(SOFT),SWP
    !$omp parallel do default(none) OMP_SCHEDULE_ collapse(2) &
    !$omp private(i,j,k) &
    !$omp private(CPtot,Qsl,dQsl,aa,bb,ac,sigma_s,Q1,RR,Ql,cc,Rt,betat,betaq,LHVL) &
    !$omp shared(JS,JE,IS,IE,KS,KE,KE_PBL) &
    !$omp shared(CZ,rsqrt_2,rsqrt_2pi,sqrt_2pi,GRAV,CPdry,EPSTvap,ATMOS_PHY_TB_MYNN_N2_MAX) &
    !$omp shared(DENS,l,Qdry,TEMP,TEML,POTT,POTL,POTV,q2_2,Qw,q,dudz2,Ri,n2,sh)
    do j = JS, JE
    do i = IS, IE

       call ATMOS_SATURATION_dens2qsat( Qsl(:), & ! (out)
                                        TEML(:,i,j), DENS(:,i,j) ) ! (in)

       call HYDROMETEOR_LHV( LHVL(:), TEML(:,i,j) )

       do k = KS+1, KE_PBL

          dQsl = ( Qsl(k) * LHVL(k) / ( Rvap * TEML(k,i,j) ) - Qsl(k) ) / TEML(k,i,j)
          CPtot = Qdry(k,i,j) * CPdry + Qsl(k) * CPvap
          aa = 1.0_RP / ( 1.0_RP + LHVL(k)/CPtot * dQsl )
          bb = TEMP(k,i,j) / POTT(k,i,j) * dQsl
          ac = min( q(k,i,j)/sqrt(q2_2(k,i,j)), 1.0_RP )
          sigma_s = max( sqrt( 0.25_RP * aa**2 * l(k,i,j)**2 * ac * B2 * sh(k,i,j) ) &
                       * abs( Qw(k+1,i,j) - Qw(k-1,i,j) - bb * ( POTL(k+1,i,j)-POTL(k-1,i,j) ) ) &
                       / ( CZ(k+1,i,j) - CZ(k-1,i,j) ), &
                       1e-10_RP )
          Q1 = aa * ( Qw(k,i,j) - Qsl(k) ) * 0.5_RP / sigma_s
          RR = min( max( 0.5_RP * ( 1.0_RP + erf(Q1*rsqrt_2) ), 0.0_RP ), 1.0_RP )
#if defined(PGI) || defined(SX)
          Ql = min( max( 2.0_RP * sigma_s * ( RR * Q1 + rsqrt_2pi * exp( -min( 0.5_RP*Q1**2, 1.E+3_RP ) ) ), & ! apply exp limiter
#else
          Ql = min( max( 2.0_RP * sigma_s * ( RR * Q1 + rsqrt_2pi * exp(-0.5_RP*Q1**2) ), &
#endif
                    0.0_RP ), &
                    Qw(k,i,j) * 0.5_RP )
          cc = ( 1.0_RP + EPSTvap * Qw(k,i,j) - (1.0_RP+EPSTvap) * Ql ) * POTT(k,i,j)/TEMP(k,i,j) * LHVL(k) / CPtot &
               - (1.0_RP+EPSTvap) * POTT(k,i,j)
#if defined(PGI) || defined(SX)
          Rt = min( max( RR - Ql / (2.0_RP*sigma_s*sqrt_2pi) * exp( -min( 0.5_RP*Q1**2, 1.E+3_RP ) ), 0.0_RP ), 1.0_RP ) ! apply exp limiter
#else
          Rt = min( max( RR - Ql / (2.0_RP*sigma_s*sqrt_2pi) * exp(-Q1**2 * 0.5_RP), 0.0_RP ), 1.0_RP )
#endif
          betat = 1.0_RP + EPSTvap * Qw(k,i,j) - (1.0_RP+EPSTvap) * Ql - Rt * aa * bb * cc
          betaq = EPSTvap * POTT(k,i,j) + Rt * aa * cc
          n2(k,i,j) = min(ATMOS_PHY_TB_MYNN_N2_MAX, &
                          GRAV * ( ( POTL(k+1,i,j) - POTL(k-1,i,j) ) * betat &
                                 + ( Qw  (k+1,i,j) - Qw  (k-1,i,j) ) * betaq ) &
                               / ( CZ(k+1,i,j) - CZ(k-1,i,j) ) / POTV(k,i,j) )
       end do
       n2(KS,i,j) = n2(KS+1,i,j)

       do k = KS, KE_PBL
          Ri(k,i,j) = n2(k,i,j) / max(dudz2(k,i,j), 1E-10_RP)
       end do
       do k = KE_PBL+1, KE
          Ri(k,i,j) = 0.0_RP
          n2(k,i,j) = 0.0_RP
       end do

    end do
    end do

    ! length
    call get_length( &
         l, & ! (out)
         DENS, & ! (in)
         q, n2, & ! (in)
         SFLX_MU, SFLX_MV, SFLX_PT, & ! (in)
         POTT ) ! (in)

    call get_q2_level2( &
         q2_2, & ! (out)
         dudz2, Ri, l ) ! (in)

    call get_smsh( &
         sm, sh, & ! (out)
         q, q2_2, & ! (in)
         l, n2, dudz2 ) ! (in)


    !$omp parallel do default(none) private(i,j,k,Kh) OMP_SCHEDULE_ collapse(2) &
    !$omp shared(JS,JE,IS,IE,Nu,l,KE_PBL,q,sm,ATMOS_PHY_TB_MYNN_NU_MAX,ATMOS_PHY_TB_MYNN_NU_MIN) &
    !$omp shared(KA,sh,ATMOS_PHY_TB_MYNN_KH_MAX,ATMOS_PHY_TB_MYNN_KH_MIN,RHOKh,DENS,Pr,KE,KS)
    do j = JS, JE
    do i = IS, IE
       do k = 1, KS-1
          Nu(k,i,j) = 0.0_RP
       end do
       do k = KS, KE_PBL
          Nu(k,i,j) = max( min( l(k,i,j) * q(k,i,j) * sm(k,i,j), &
                           ATMOS_PHY_TB_MYNN_NU_MAX ), &
                           ATMOS_PHY_TB_MYNN_NU_MIN )
       end do
       do k = KE_PBL+1, KA
          Nu(k,i,j) = 0.0_RP
       end do

       do k = KS, KE_PBL
          Kh = max( min( l(k,i,j) * q(k,i,j) * sh(k,i,j), &
                    ATMOS_PHY_TB_MYNN_KH_MAX ), &
                    ATMOS_PHY_TB_MYNN_KH_MIN )
          RHOKh(k,i,j) = DENS(k,i,j) * Kh
          Pr(k,i,j) = Nu(k,i,j) / Kh
       end do
       do k = KE_PBL+1, KE
          Pr(k,i,j) = 1.0_RP
       end do
    end do
    end do

    call COMM_vars( Nu,   1 )

    ! time integration

    !  for velocities
!OCL INDEPENDENT
    !$omp parallel do default(none)                                                              &
    !$omp shared(JS,JE,IS,IE,KS,KE_PBL,dt,DENS,Nu,RFDZ,GSQRT,I_XYW,a,c,b,d,RCDZ,I_XYZ,U,SFLX_MU) &
    !$omp shared(phiN)                                                                           &
    !$omp private(i,j,k,ap) OMP_SCHEDULE_ collapse(2)
    do j = JS, JE
    do i = IS, IE

       ap = - dt * 0.5_RP * ( DENS(KS  ,i,j)*Nu(KS  ,i,j) &
                            + DENS(KS+1,i,j)*Nu(KS+1,i,j) ) &
                          * RFDZ(KS) / GSQRT(KS,i,j,I_XYW)
       a(KS,i,j) = ap * RCDZ(KS) / ( DENS(KS,i,j) * GSQRT(KS,i,j,I_XYZ) )
       c(KS,i,j) = 0.0_RP
       b(KS,i,j) = - a(KS,i,j) + 1.0_RP
       do k = KS+1, KE_PBL-1
          c(k,i,j) = ap * RCDZ(k) / ( DENS(k,i,j) * GSQRT(k,i,j,I_XYZ) )
          ap = - dt * 0.5_RP * ( DENS(k  ,i,j)*Nu(k  ,i,j) &
                               + DENS(k+1,i,j)*Nu(k+1,i,j) ) &
                             * RFDZ(k) / GSQRT(k,i,j,I_XYW)
          a(k,i,j) = ap * RCDZ(k) / ( DENS(k,i,j) * GSQRT(k,i,j,I_XYZ) )
          b(k,i,j) = - a(k,i,j) - c(k,i,j) + 1.0_RP
       end do
       a(KE_PBL,i,j) = 0.0_RP
       c(KE_PBL,i,j) = ap * RCDZ(KE_PBL) / ( DENS(KE_PBL,i,j) * GSQRT(KE_PBL,i,j,I_XYZ) )
       b(KE_PBL,i,j) = - c(KE_PBL,i,j) + 1.0_RP

       d(KS,i,j) = U(KS,i,j) + dt * SFLX_MU(i,j) * RCDZ(KS) / ( DENS(KS,i,j) * GSQRT(KS,i,j,I_XYZ) )
       do k = KS+1, KE_PBL
          d(k,i,j) = U(k,i,j)
       end do
       call diffusion_solver( &
            phiN(:,i,j),                     & ! (out)
            a(:,i,j), b(:,i,j), c(:,i,j), d(:,i,j), & ! (in)
            KE_PBL                           ) ! (in)
    end do
    end do

    call COMM_vars( phiN, 2 )
    call COMM_wait( Nu,   1 )
    call COMM_wait( phiN, 2 )

!OCL INDEPENDENT
    do JJS = JS, JE, JBLOCK
    JJE = JJS+JBLOCK-1
    do IIS = IS, IE, IBLOCK
    IIE = IIS+IBLOCK-1

       do j = JJS, JJE
       do i = IIS, IIE
       do k = KS, KE_PBL-1
          qflx_sgs_momx(k,i,j,ZDIR) = - 0.03125_RP & ! 1/4/4/2
               * ( DENS(k,i,j) + DENS(k+1,i,j) + DENS(k,i+1,j) + DENS(k+1,i+1,j) ) &
               * ( Nu(k,i,j) + Nu(k+1,i,j) + Nu(k,i+1,j) + Nu(k+1,i+1,j) ) &
               * ( (phiN(k+1,i,j)+phiN(k+1,i+1,j)) - (phiN(k,i,j)+phiN(k,i+1,j)) ) &
               * J33G * RFDZ(k) / GSQRT(k,i,j,I_UYW)
       end do
       end do
       end do
       do j = JJS, JJE
       do i = IIS, IIE
          qflx_sgs_momx(KS-1,i,j,ZDIR) = 0.0_RP
       end do
       end do
       do j = JJS, JJE
       do i = IIS, IIE
       do k = KE_PBL, KE
          qflx_sgs_momx(k,i,j,ZDIR) = 0.0_RP
       end do
       end do
       end do


       ! integration V
!OCL INDEPENDENT
       !$omp parallel do default(none)                                                         &
       !$omp shared(JJS,JJE,IIS,IIE,KS,KE_PBL,V,dt,SFLX_MV,RCDZ,DENS,GSQRT,I_XYZ,phiN,a,b,c,d) &
       !$omp private(i,j,k) OMP_SCHEDULE_ collapse(2)
       do j = JJS, JJE
       do i = IIS, IIE
          d(KS,i,j) = V(KS,i,j) + dt * SFLX_MV(i,j) * RCDZ(KS) / ( DENS(KS,i,j) * GSQRT(KS,i,j,I_XYZ) )
          do k = KS+1, KE_PBL
             d(k,i,j) = V(k,i,j)
          end do
          call diffusion_solver( &
               phiN(:,i,j),                     & ! (out)
               a(:,i,j), b(:,i,j), c(:,i,j), d(:,i,j), & ! (in)
               KE_PBL                           ) ! (in)
       end do
       end do

    end do
    end do

    call COMM_vars( phiN, 1 )
    call COMM_wait( phiN, 1 )

    do JJS = JS, JE, JBLOCK
    JJE = JJS+JBLOCK-1
    do IIS = IS, IE, IBLOCK
    IIE = IIS+IBLOCK-1

       do j = JJS, JJE
       do i = IIS, IIE
          qflx_sgs_momy(KS-1,i,j,ZDIR) = 0.0_RP
          do k = KS, KE_PBL-1
             qflx_sgs_momy(k,i,j,ZDIR) = - 0.03125_RP & ! 1/4/4/2
               * ( DENS(k,i,j) + DENS(k+1,i,j) + DENS(k,i,j+1) + DENS(k+1,i,j+1) ) &
               * ( Nu(k,i,j) + Nu(k+1,i,j) + Nu(k,i,j+1) + Nu(k+1,i,j+1) ) &
               * ( (phiN(k+1,i,j)+phiN(k+1,i,j+1)) - (phiN(k,i,j)+phiN(k,i,j+1)) ) &
               * J33G * RFDZ(k) / GSQRT(k,i,j,I_XVW)
          end do
          do k = KE_PBL, KE
             qflx_sgs_momy(k,i,j,ZDIR) = 0.0_RP
          end do
       end do
       end do


       ! for scalars
       ! integration POTT
!OCL INDEPENDENT
       do j = JJS, JJE
       do i = IIS, IIE
          ap = - dt * 0.5_RP * ( RHOKh(KS,i,j) + RHOKh(KS+1,i,j) ) &
             * RFDZ(KS) / GSQRT(KS,i,j,I_XYW)
          a(KS,i,j) = ap * RCDZ(KS) / (DENS(KS,i,j) * GSQRT(KS,i,j,I_XYZ) )
          c(KS,i,j) = 0.0_RP
          b(KS,i,j) = - a(KS,i,j) + 1.0_RP
          do k = KS+1, KE_PBL-1
             c(k,i,j) = ap * RCDZ(k) / (DENS(k,i,j) * GSQRT(k,i,j,I_XYZ) )
             ap = - dt * 0.5_RP * ( RHOKh(k,i,j) + RHOKh(k+1,i,j) ) &
                * RFDZ(k) / GSQRT(k,i,j,I_XYW)
             a(k,i,j) = ap * RCDZ(k) / ( DENS(k,i,j) * GSQRT(k,i,j,I_XYZ) )
             b(k,i,j) = - a(k,i,j) - c(k,i,j) + 1.0_RP
          end do
          a(KE_PBL,i,j) = 0.0_RP
          c(KE_PBL,i,j) = ap * RCDZ(KE_PBL) / (DENS(KE_PBL,i,j) * GSQRT(KE_PBL,i,j,I_XYZ) )
          b(KE_PBL,i,j) = - c(KE_PBL,i,j) + 1.0_RP
          d(KS,i,j) = POTT(KS,i,j) + dt * SFLX_PT(i,j) * RCDZ(KS) / GSQRT(KS,i,j,I_XYZ)
          do k = KS+1, KE_PBL
             d(k,i,j) = POTT(k,i,j)
          end do
          call diffusion_solver( &
               phiN(:,i,j),                     & ! (out)
               a(:,i,j), b(:,i,j), c(:,i,j), d(:,i,j), & ! (in)
               KE_PBL                           ) ! (in)
       end do
       end do

       !$omp parallel do default(none)                                                           &
       !$omp shared(JJS,JJE,IIS,IIE,KS,KE_PBL,RHOKh,J33G,phiN,RFDZ,GSQRT,I_XYW,KE,qflx_sgs_rhot) &
       !$omp private(i,j,k) OMP_SCHEDULE_ collapse(2)
       do j = JJS, JJE
       do i = IIS, IIE
          qflx_sgs_rhot(KS-1,i,j,ZDIR) = 0.0_RP
          do k = KS, KE_PBL-1
             qflx_sgs_rhot(k,i,j,ZDIR) = - 0.5_RP & ! 1/2
               * ( RHOKh(k,i,j) + RHOKh(k+1,i,j) ) &
               * J33G * ( phiN(k+1,i,j) - PhiN(k,i,j) ) * RFDZ(k) / GSQRT(k,i,j,I_XYW)
          end do
          do k = KE_PBL, KE
             qflx_sgs_rhot(k,i,j,ZDIR) = 0.0_RP
          end do
       end do
       end do


       ! TRACER
       do iq = 1, QA

          if ( iq == I_TKE ) then
             qflx_sgs_rhoq(:,:,:,ZDIR,iq) = 0.0_RP
             cycle
          end if

          if( .NOT. TRACER_ADVC(iq) ) cycle

!OCL INDEPENDENT
          !$omp parallel do default(none) private(i,j,k) OMP_SCHEDULE_ collapse(2) &
          !$omp shared(JJS,JJE,IIS,IIE,iq,I_QV,d,QTRC,KS,dt,SFLX_Q,RCDZ,DENS,GSQRT,I_XYZ,KE_PBL) &
          !$omp shared(a,b,c,phiN)
          do j = JJS, JJE
          do i = IIS, IIE
             d(KS,i,j) = QTRC(KS,i,j,iq) &
                       + dt * SFLX_Q(i,j,iq) * RCDZ(KS) / ( DENS(KS,i,j) * GSQRT(KS,i,j,I_XYZ) )

             do k = KS+1, KE_PBL
                d(k,i,j) = QTRC(k,i,j,iq)
             end do

             call diffusion_solver( &
                  phiN(:,i,j),                            & ! (out)
                  a(:,i,j), b(:,i,j), c(:,i,j), d(:,i,j), & ! (in)
                  KE_PBL                                  ) ! (in)
          end do
          end do

          !$omp parallel do default(none)                                                &
          !$omp shared(JJS,JJE,IIS,IIE,KS,KE_PBL,iq,RHOKh,J33G,phiN,RFDZ,GSQRT,KE,I_XYW) &
          !$omp shared(qflx_sgs_rhoq)                                                    &
          !$omp private(i,j,k) OMP_SCHEDULE_ collapse(2)
          do j = JJS, JJE
          do i = IIS, IIE
             qflx_sgs_rhoq(KS-1,i,j,ZDIR,iq) = 0.0_RP
             do k = KS, KE_PBL-1
                qflx_sgs_rhoq(k,i,j,ZDIR,iq) = - 0.5_RP & ! 1/2
                     * ( RHOKh(k,i,j) + RHOKh(k+1,i,j) ) &
                     * J33G * ( phiN(k+1,i,j) - phiN(k,i,j) ) * RFDZ(k) / GSQRT(k,i,j,I_XYW)
             end do
             do k = KE_PBL, KE
                qflx_sgs_rhoq(k,i,j,ZDIR,iq) = 0.0_RP
             end do
          end do
          end do

       end do


       ! TKE
       !$omp parallel do default(none) private(i,j,k,tke) OMP_SCHEDULE_ collapse(2) &
       !$omp shared(JJS,JJE,IIS,IIE,KS,q,d,dt,Nu,dudz2,n2,Pr,KE_PBL)
       do j = JJS, JJE
       do i = IIS, IIE
          tke = q(KS,i,j)**2 * 0.5
          d(KS,i,j) = tke &
                    + dt * Nu(KS,i,j) * ( dudz2(KS,i,j) - n2(KS,i,j)/Pr(KS,i,j) )
#ifdef MORE_HIST
          gen(KS,i,j) = Nu(KS,i,j) * ( dudz2(KS,i,j) - n2(KS,i,j)/Pr(KS,i,j) )
#endif
          do k = KS+1, KE_PBL-1
             tke = q(k,i,j)**2 * 0.5
             d(k,i,j) = tke &
                      + dt * Nu(k,i,j) * ( dudz2(k,i,j) - n2(k,i,j)/Pr(k,i,j) )
#ifdef MORE_HIST
             gen(k,i,j) = Nu(k,i,j) * ( dudz2(k,i,j) - n2(k,i,j)/Pr(k,i,j) )
#endif
          end do
          tke = q(KE_PBL,i,j)**2 * 0.5
          d(KE_PBL,i,j) = tke &
               + dt * Nu(KE_PBL,i,j) * ( dudz2(KE_PBL,i,j) - n2(KE_PBL,i,j)/Pr(KE_PBL,i,j) )
#ifdef MORE_HIST
          gen(KE_PBL,i,j) = Nu(KE_PBL,i,j) * ( dudz2(KE_PBL,i,j) - n2(KE_PBL,i,j)/Pr(KE_PBL,i,j) )
#endif
       end do
       end do

!OCL INDEPENDENT
       !$omp parallel do default(none)                                                        &
       !$omp shared(JJS,JJE,IIS,IIE,KS,KE_PBL,dt,DENS,Nu,RFDZ,GSQRT,I_XYW,l,RCDZ,I_XYZ,I_TKE) &
       !$omp shared(tke_N,QTRC,KE,d,q,a,c,b,RHOQ_t)                                           &
       !$omp private(i,j,k,ap) OMP_SCHEDULE_ collapse(2)
       do j = JJS, JJE
       do i = IIS, IIE
          ap = - dt * 1.5_RP * ( DENS(KS  ,i,j)*Nu(KS  ,i,j) &
                               + DENS(KS+1,i,j)*Nu(KS+1,i,j) ) &
             * RFDZ(KS) / GSQRT(KS,i,j,I_XYW)
          a(KS,i,j) = ap * RCDZ(KS) / ( DENS(KS,i,j) * GSQRT(KS,i,j,I_XYZ) )
          c(KS,i,j) = 0.0_RP
          b(KS,i,j) = - a(KS,i,j) + 1.0_RP + 2.0_RP * dt * q(KS,i,j) / ( B1 * l(KS,i,j) )
          do k = KS+1, KE_PBL-1
             c(k,i,j) = ap * RCDZ(k) / ( DENS(k,i,j) * GSQRT(k,i,j,I_XYZ) )
             ap = - dt * 1.5_RP * ( DENS(k  ,i,j)*Nu(k  ,i,j) &
                                  + DENS(k+1,i,j)*Nu(k+1,i,j))  &
                * RFDZ(k) / GSQRT(k,i,j,I_XYW)
             a(k,i,j) = ap * RCDZ(k) / ( DENS(k,i,j) * GSQRT(k,i,j,I_XYZ) )
             b(k,i,j) = - a(k,i,j) - c(k,i,j) + 1.0_RP + 2.0_RP * dt * q(k,i,j) / ( B1 * l(k,i,j) )
          end do

          a(KE_PBL,i,j) = 0.0_RP
          c(KE_PBL,i,j) = ap * RCDZ(KE_PBL) / ( DENS(KE_PBL,i,j) * GSQRT(KE_PBL,i,j,I_XYZ) )
          b(KE_PBL,i,j) = - c(KE_PBL,i,j) + 1.0_RP + 2.0_RP * dt * q(KE_PBL,i,j) / ( B1 * l(KE_PBL,i,j) )
          call diffusion_solver( &
               tke_N(:,i,j),     & ! (out)
               a(:,i,j), b(:,i,j), c(:,i,j), d(:,i,j), & ! (in)
               KE_PBL                           ) ! (in)
          do k = KS, KE_PBL
             RHOQ_t(k,i,j,I_TKE) = ( max(tke_N(k,i,j), TKE_min) - QTRC(k,i,j,I_TKE) ) * DENS(k,i,j) / dt
          end do
          do k = KE_PBL+1, KE
             RHOQ_t(k,i,j,I_TKE) = 0.0_RP
          end do

       end do
       end do

    end do
    end do

#ifdef MORE_HIST
    gen(KE_PBL+1:KE,:,:) = 0.0_RP
    dudz2(KE_PBL+1:KE,:,:) = 0.0_RP
    l(KE_PBL+1:KE,:,:) = 0.0_RP
    POTV(KE_PBL+1:KE,:,:) = 0.0_RP
    POTL(KE_PBL+1:KE,:,:) = 0.0_RP
    call HIST_in(gen, 'TKE_gen', 'generation of TKE', 'm2/s3', nohalo=.true.)
    call HIST_in(dudz2, 'dUdZ2', 'dudz2', 'm2/s2', nohalo=.true.)
    call HIST_in(l, 'L_mix', 'minxing length', 'm', nohalo=.true.)
    call HIST_in(POTV, 'POTV', 'virtual potential temperature', 'K', nohalo=.true.)
    call HIST_in(POTL, 'POTL', 'liquid potential temperature', 'K', nohalo=.true.)
#endif

    return
  end subroutine ATMOS_PHY_TB_mynn

  subroutine get_length( &
       l, &
       DENS, &
       q, n2, &
       SFLX_MU, SFLX_MV, SFLX_PT, &
       PT0 )
    use scale_grid_real, only: &
       FZ => REAL_FZ
    use scale_const, only: &
       GRAV   => CONST_GRAV, &
       KARMAN => CONST_KARMAN, &
       CP     => CONST_CPdry, &
       EPS    => CONST_EPS
    implicit none

    real(RP), intent(out) :: l(KA,IA,JA)
    real(RP), intent(in) :: DENS(KA,IA,JA)
    real(RP), intent(in) :: q(KA,IA,JA)
    real(RP), intent(in) :: n2(KA,IA,JA)
    real(RP), intent(in) :: SFLX_MU(IA,JA)
    real(RP), intent(in) :: SFLX_MV(IA,JA)
    real(RP), intent(in) :: SFLX_PT(IA,JA)
    real(RP), intent(in) :: PT0(KA,IA,JA)

    real(RP) :: ls           !< L_S
    real(RP) :: lt           !< L_T
    real(RP) :: lb           !< L_B
    real(RP) :: rlm          !< 1/L_M
    real(RP) :: rlt          !< 1/L_T

    real(RP) :: qc           !< q_c
    real(RP) :: int_q        !< \int q dz
    real(RP) :: int_qz       !< \int qz dz
    real(RP) :: rn2sr         !< 1/N
    real(RP) :: us           !< friction velocity
    real(RP) :: zeta         !< height normalized by the Obukhov length

    real(RP) :: z
    real(RP) :: qdz

    real(RP) :: sw
    integer :: k, i, j

!OCL LOOP_NOFUSION,PREFETCH_SEQUENTIAL(SOFT),SWP
    !$omp parallel do default(none)                                                            &
    !$omp shared(JS,JE,IS,IE,KS,KE_PBL,q,FZ,EPS,ATMOS_PHY_TB_MYNN_Lt_MAX,SFLX_MU,SFLX_MV,DENS) &
    !$omp shared(SFLX_PT,PT0,n2,GRAV,l)                                                        &
    !$omp private(i,j,k,qdz,lt,rlt,us,rlm,qc,z,zeta,sw,ls,rn2sr,lb,int_qz,int_q)               &
    !$omp OMP_SCHEDULE_ collapse(2)
    do j = JS, JE
    do i = IS, IE
       int_qz = 0.0_RP
       int_q = 0.0_RP
       do k = KS, KE_PBL
          qdz = q(k,i,j) * ( FZ(k,i,j) - FZ(k-1,i,j) )
          int_qz = int_qz + ((FZ(k,i,j)+FZ(k-1,i,j))*0.5_RP-FZ(KS-1,i,j)) * qdz
          int_q  = int_q + qdz
       end do
       ! LT
       lt = min( max(0.23_RP * int_qz / (int_q + EPS), &
                    LT_min), &
                    ATMOS_PHY_TB_MYNN_Lt_MAX )
       rlt = 1.0_RP / lt

       us = sqrt( sqrt( SFLX_MU(i,j)**2 + SFLX_MV(i,j)**2 ) / DENS(KS,i,j) ) ! friction velocity
       us = max(us, Us_min)
       rlm = - KARMAN * GRAV * SFLX_PT(i,j) / (PT0(KS,i,j) * us**3 )

       qc = (GRAV/PT0(KS,i,j)*max(SFLX_PT(i,j),0.0_RP)*lt)**OneOverThree

       do k = KS, KE_PBL
          z = ( FZ(k,i,j)+FZ(k-1,i,j) )*0.5_RP - FZ(KS-1,i,j)
          zeta = z * rlm

          ! LS
          sw = sign(0.5_RP, zeta) + 0.5_RP ! 1 for zeta >= 0, 0 for zeta < 0
          ls = KARMAN * z &
             * ( sw / (1.0_RP + 2.7_RP*min(zeta,1.0_RP)*sw ) &
               + ( (1.0_RP - 100.0_RP*zeta)*(1.0_RP-sw) )**0.2_RP )

          ! LB
          sw  = sign(0.5_RP, n2(k,i,j)-EPS) + 0.5_RP ! 1 for dptdz >0, 0 for dptdz <= 0
          rn2sr = 1.0_RP / ( sqrt(n2(k,i,j)*sw) + 1.0_RP-sw)
          lb = (1.0_RP + 5.0_RP * sqrt(qc*rn2sr/lt)) * q(k,i,j) * rn2sr * sw & ! qc=0 when SFLX_PT < 0
             +  999.E10_RP * (1.0_RP-sw)

          ! L
          l(k,i,j) = 1.0_RP / ( 1.0_RP/ls + rlt + 1.0_RP/lb )
       end do
    end do
    end do

    return
  end subroutine get_length

  subroutine get_q2_level2( &
       q2_2,        &
       dudz2, Ri, l )
    implicit none

    real(RP), intent(out) :: q2_2(KA,IA,JA)
    real(RP), intent(in)  :: dudz2(KA,IA,JA)
    real(RP), intent(in)  :: Ri(KA,IA,JA)
    real(RP), intent(in)  :: l(KA,IA,JA)

    real(RP) :: rf           !< Rf
    real(RP) :: sm_2         !< sm for level 2
    real(RP) :: sh_2         !< sh for level 2

    real(RP) :: q2
    integer :: k, i, j

!OCL LOOP_NOFUSION,PREFETCH_SEQUENTIAL(SOFT),SWP
    !$omp parallel do default(none) &
    !$omp shared(JS,JE,IS,IE,KS,KE_PBL,AF12,Ri,Rf1,Rf2,Rfc,A2,G2,l,dudz2,q2_2) &
    !$omp private(i,j,k,rf,sh_2,sm_2,q2) OMP_SCHEDULE_ collapse(2)
    do j = JS, JE
    do i = IS, IE
    do k = KS, KE_PBL
       rf = min(0.5_RP / AF12 * ( Ri(k,i,j) &
                              + AF12*Rf1 &
                              - sqrt(Ri(k,i,j)**2 + 2.0_RP*AF12*(Rf1-2.0_RP*Rf2)*Ri(k,i,j) + (AF12*Rf1)**2) ), &
                Rfc)
       sh_2 = 3.0_RP * A2 * (G1+G2) * (Rfc-rf) / (1.0_RP-rf)
       sm_2 = sh_2 * AF12 * (Rf1-rf) / (Rf2-rf)
       q2 = B1 * l(k,i,j)**2 * sm_2 * (1.0_RP-rf) * dudz2(k,i,j)
       q2_2(k,i,j) = max( q2, 1.E-10_RP )
    end do
    end do
    end do

    return
  end subroutine get_q2_level2

  subroutine get_smsh( &
         sm, sh, & ! (out)
         q, q2_2, & ! (in)
         l, n2, dudz2 ) ! (in)
    implicit none
    real(RP), intent(out) :: sm(KA,IA,JA)
    real(RP), intent(out) :: sh(KA,IA,JA)
    real(RP), intent(in)  :: q(KA,IA,JA)
    real(RP), intent(in)  :: q2_2(KA,IA,JA)
    real(RP), intent(in)  :: l(KA,IA,JA)
    real(RP), intent(in)  :: n2(KA,IA,JA)
    real(RP), intent(in)  :: dudz2(KA,IA,JA)

    real(RP) :: l2q2         !< L^2/q^2
    real(RP) :: ac          !< \alpha_c
    real(RP) :: ac2          !< \alpha_c^2
    real(RP) :: p1           !< \Phi_1
    real(RP) :: p2           !< \Phi_2
    real(RP) :: p3           !< \Phi_3
    real(RP) :: p4           !< \Phi_4
    real(RP) :: p5           !< \Phi_5
    real(RP) :: rd25         !< 1/D_2.5
    real(RP) :: gh           !< G_H

    integer :: k, i, j

!OCL LOOP_NOFUSION,PREFETCH_SEQUENTIAL(SOFT),SWP
    !$omp parallel do default(none)                                      &
    !$omp shared(JS,JE,IS,IE,KS,KE_PBL,q,q2_2,l,n2,A2,A1,dudz2,C1,sm,sh) &
    !$omp private(i,j,k,ac,ac2,l2q2,gh,p1,p2,p3,p4,p5,rd25) OMP_SCHEDULE_ collapse(2)
    do j = JS, JE
    do i = IS, IE
    do k = KS, KE_PBL

       ! level 2.5
       ac = min(q(k,i,j)/sqrt(q2_2(k,i,j)), 1.0_RP)
       ac2 = ac**2
       l2q2 = ( l(k,i,j) / q(k,i,j) )**2
       gh = - n2(k,i,j) * l2q2

       p1 = 1.0_RP - 3.0_RP * ac2 * A2 * B2 * (1.0_RP-C3) * gh
       p2 = 1.0_RP - 9.0_RP * ac2 * A1 * A2 * (1.0_RP-C2) * gh
       p3 = p1 + 9.0_RP * ac2 * A2**2 * (1.0_RP-C2) * (1.0_RP-C5) * gh
       p4 = p1 - 12.0_RP * ac2 * A1 * A2 * (1.0_RP-C2) * gh
       p5 = 6.0_RP * ac2 * A1**2 * dudz2(k,i,j) * l2q2

       rd25 = 1.0_RP / max(p2 * p4 + p5 * p3, 1.E-20_RP)
       sm(k,i,j) = max( ac * A1 * (p3 - 3.0_RP * C1 * p4) * rd25, 0.0_RP )
       sh(k,i,j) = max( ac * A2 * (p2 + 3.0_RP * C1 * p5) * rd25, 0.0_RP )

    end do
    end do
    end do
    return
  end subroutine get_smsh

  function erf(x)
    real(RP), parameter :: a = 0.1400122886866665_RP     ! -8(pi-3)/(3pi(pi-4))
    real(RP), parameter :: fourpi = 1.2732395447351628_RP ! 4/pi

    real(RP), intent(in) :: x
    real(RP) :: erf

    real(RP) :: x2, tmp

    x2  = x*x

#if defined(PGI) || defined(SX)
    tmp = min( x2 * ( fourpi + a*x2 ) / ( 1.0_RP + a*x2 ), 1.E+3_RP ) ! apply exp limiter
    erf = sign( sqrt( 1.0_RP - exp(-tmp) ), x )
#else
    erf = sign( sqrt( 1.0_RP - exp(-x2 * (fourpi+a*x2)/(1.0_RP+a*x2) ) ), x )
#endif

    return
  end function erf

end module scale_atmos_phy_tb_mynn
