
!-------------------------------------------------------------------------------
!> module scale_atmos_dyn_fvm_flux_ud1
!!
!! @par Description
!!          FVM flux scheme with the ud1 order
!!
!! @author Team SCALE
!!
!<
!-------------------------------------------------------------------------------
! Warning: This file was generated from atmos-rm/dynamics/scale_atmos_dyn_fvm_flux_udcd.F90.erb.
!          Do not edit this file.
!-------------------------------------------------------------------------------
#include "scalelib.h"
module scale_atmos_dyn_fvm_flux_ud1
  !-----------------------------------------------------------------------------
  !
  !++ used modules
  !
  use scale_precision
  use scale_io
  use scale_prof
  use scale_atmos_grid_cartesC_index
  use scale_index
  use scale_tracer
  use scale_prc
#ifdef DEBUG
  use scale_debug, only: &
     CHECK
  use scale_const, only: &
     UNDEF  => CONST_UNDEF, &
     IUNDEF => CONST_UNDEF2
#endif
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedure
  !
  public :: ATMOS_DYN_FVM_flux_valueW_Z_ud1

  public :: ATMOS_DYN_FVM_fluxZ_XYZ_ud1
  public :: ATMOS_DYN_FVM_fluxX_XYZ_ud1
  public :: ATMOS_DYN_FVM_fluxY_XYZ_ud1

  public :: ATMOS_DYN_FVM_fluxZ_XYW_ud1
  public :: ATMOS_DYN_FVM_fluxJ13_XYW_ud1
  public :: ATMOS_DYN_FVM_fluxJ23_XYW_ud1
  public :: ATMOS_DYN_FVM_fluxX_XYW_ud1
  public :: ATMOS_DYN_FVM_fluxY_XYW_ud1

  public :: ATMOS_DYN_FVM_fluxZ_UYZ_ud1
  public :: ATMOS_DYN_FVM_fluxJ13_UYZ_ud1
  public :: ATMOS_DYN_FVM_fluxJ23_UYZ_ud1
  public :: ATMOS_DYN_FVM_fluxX_UYZ_ud1
  public :: ATMOS_DYN_FVM_fluxY_UYZ_ud1

  public :: ATMOS_DYN_FVM_fluxZ_XVZ_ud1
  public :: ATMOS_DYN_FVM_fluxJ13_XVZ_ud1
  public :: ATMOS_DYN_FVM_fluxJ23_XVZ_ud1
  public :: ATMOS_DYN_FVM_fluxX_XVZ_ud1
  public :: ATMOS_DYN_FVM_fluxY_XVZ_ud1

  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private procedure
  !
#if 1
#define F2H(k,p,q) (CDZ(k+p-1)*GSQRT(k+p-1,i,j)/(CDZ(k)*GSQRT(k,i,j)+CDZ(k+1)*GSQRT(k+1,i,j)))
#else
#define F2H(k,p,q) 0.5_RP
#endif
  !-----------------------------------------------------------------------------
  !
  !++ Private parameters & variables
  !

  real(RP), parameter :: F1  =  0.5_RP

  real(RP), parameter :: F2  =  0.5_RP          ! F2 is always used to calculate flux near boundary.





contains
  !-----------------------------------------------------------------------------
  !> value at XYW
!OCL SERIAL
  subroutine ATMOS_DYN_FVM_flux_valueW_Z_ud1( &
       valW,             &
       mflx, val, GSQRT, &
       CDZ               )
    implicit none

    real(RP), intent(out) :: valW (KA)
    real(RP), intent(in)  :: mflx (KA)
    real(RP), intent(in)  :: val  (KA)
    real(RP), intent(in)  :: GSQRT(KA)
    real(RP), intent(in)  :: CDZ  (KA)

    integer  :: k
    !---------------------------------------------------------------------------

    do k = KS, KE-1
#ifdef DEBUG
       call CHECK( __LINE__, mflx(k) )

       call CHECK( __LINE__, val(k) )
       call CHECK( __LINE__, val(k+1) )

#endif
       valW(k)       = F1 * ( val(k+1)+val(k) ) - sign(F1,mflx(k)) * ( val(k+1)-val(k) )
    enddo
#ifdef DEBUG
    k = IUNDEF
#endif

#ifdef DEBUG

#endif


    return
  end subroutine ATMOS_DYN_FVM_flux_ValueW_Z_ud1

  !-----------------------------------------------------------------------------
  !> calculation z-flux at XYZ
  subroutine ATMOS_DYN_FVM_fluxZ_XYZ_ud1( &
       flux,              &
       mflx, val, GSQRT,  &
       num_diff,          &
       CDZ,               &
       IIS, IIE, JJS, JJE )
    use scale_const, only: &
      EPS => CONST_EPS
    implicit none

    real(RP), intent(inout) :: flux    (KA,IA,JA)
    real(RP), intent(in)  :: mflx    (KA,IA,JA)
    real(RP), intent(in)  :: val     (KA,IA,JA)
    real(RP), intent(in)  :: GSQRT   (KA,IA,JA)
    real(RP), intent(in)  :: num_diff(KA,IA,JA)
    real(RP), intent(in)  :: CDZ     (KA)
    integer,  intent(in)  :: IIS, IIE, JJS, JJE

    real(RP) :: vel
    integer  :: k, i, j
    !---------------------------------------------------------------------------

    !$omp parallel default(none) private(i,j,k, vel)                    &
    !$omp shared(JJS,JJE,IIS,IIE,KS,KE,mflx,val,flux,GSQRT,num_diff,EPS)
    
    !$omp do OMP_SCHEDULE_ collapse(2)
    do j = JJS, JJE
    do i = IIS, IIE
    do k = KS, KE-1
#ifdef DEBUG
       call CHECK( __LINE__, mflx(k,i,j) )

       call CHECK( __LINE__, val(k,i,j) )
       call CHECK( __LINE__, val(k+1,i,j) )

#endif
       vel = mflx(k,i,j)
       flux(k,i,j) = vel &
                   * ( F1 * ( val(k+1,i,j)+val(k,i,j) ) - sign(F1,vel) * ( val(k+1,i,j)-val(k,i,j) ) ) 
    enddo
    enddo
    enddo
    !$omp end do nowait
#ifdef DEBUG
    k = IUNDEF; i = IUNDEF; j = IUNDEF
#endif

    !$omp do OMP_SCHEDULE_ collapse(2)
    do j = JJS, JJE
    do i = IIS, IIE
#ifdef DEBUG

#endif
       flux(KS-1,i,j) = 0.0_RP

       flux(KE  ,i,j) = 0.0_RP
    enddo
    enddo
    !$omp end do
    
    !$omp end parallel    
#ifdef DEBUG
    k = IUNDEF; i = IUNDEF; j = IUNDEF
#endif

    return
  end subroutine ATMOS_DYN_FVM_fluxZ_XYZ_ud1

  !-----------------------------------------------------------------------------
  !> calculation X-flux at XYZ
  subroutine ATMOS_DYN_FVM_fluxX_XYZ_ud1( &
       flux,              &
       mflx, val, GSQRT,  &
       num_diff,          &
       CDZ,               &
       IIS, IIE, JJS, JJE )
    implicit none

    real(RP), intent(inout) :: flux    (KA,IA,JA)
    real(RP), intent(in)  :: mflx    (KA,IA,JA)
    real(RP), intent(in)  :: val     (KA,IA,JA)
    real(RP), intent(in)  :: GSQRT   (KA,IA,JA)
    real(RP), intent(in)  :: num_diff(KA,IA,JA)
    real(RP), intent(in)  :: CDZ(KA)
    integer,  intent(in)  :: IIS, IIE, JJS, JJE

    real(RP) :: vel
    integer  :: k, i, j
    !---------------------------------------------------------------------------

    !$omp parallel do default(none) private(i,j,k) OMP_SCHEDULE_ collapse(2) &
    !$omp private(vel) &
    !$omp shared(JJS,JJE,IIS,IIE,KS,KE,mflx,val,flux,GSQRT,num_diff)
    do j = JJS, JJE
    do i = IIS-1, IIE
    do k = KS, KE
#ifdef DEBUG
       call CHECK( __LINE__, mflx(k,i,j) )

       call CHECK( __LINE__, val(k,i,j) )
       call CHECK( __LINE__, val(k,i+1,j) )

#endif
       vel = mflx(k,i,j)
       flux(k,i,j) = vel &
                   * ( F1 * ( val(k,i+1,j)+val(k,i,j) ) - sign(F1,vel) * ( val(k,i+1,j)-val(k,i,j) ) ) 
    enddo
    enddo
    enddo
#ifdef DEBUG
    k = IUNDEF; i = IUNDEF; j = IUNDEF
#endif

    return
  end subroutine ATMOS_DYN_FVM_fluxX_XYZ_ud1

  !-----------------------------------------------------------------------------
  !> calculation Y-flux at XYZ
  subroutine ATMOS_DYN_FVM_fluxY_XYZ_ud1( &
       flux,              &
       mflx, val, GSQRT,  &
       num_diff,          &
       CDZ,               &
       IIS, IIE, JJS, JJE )
    implicit none

    real(RP), intent(inout) :: flux    (KA,IA,JA)
    real(RP), intent(in)  :: mflx    (KA,IA,JA)
    real(RP), intent(in)  :: val     (KA,IA,JA)
    real(RP), intent(in)  :: GSQRT   (KA,IA,JA)
    real(RP), intent(in)  :: num_diff(KA,IA,JA)
    real(RP), intent(in)  :: CDZ(KA)
    integer,  intent(in)  :: IIS, IIE, JJS, JJE

    real(RP) :: vel
    integer  :: k, i, j
    !---------------------------------------------------------------------------

    !$omp parallel do default(none) private(i,j,k) OMP_SCHEDULE_ collapse(2) &
    !$omp private(vel) &
    !$omp shared(JJS,JJE,IIS,IIE,KS,KE,mflx,val,flux,GSQRT,num_diff)
    do j = JJS-1, JJE
    do i = IIS, IIE
    do k = KS, KE
#ifdef DEBUG
       call CHECK( __LINE__, mflx(k,i,j) )

       call CHECK( __LINE__, val(k,i,j) )
       call CHECK( __LINE__, val(k,i,j+1) )

#endif
       vel = mflx(k,i,j)
       flux(k,i,j) = vel &
                   * ( F1 * ( val(k,i,j+1)+val(k,i,j) ) - sign(F1,vel) * ( val(k,i,j+1)-val(k,i,j) ) ) 
    enddo
    enddo
    enddo
#ifdef DEBUG
    k = IUNDEF; i = IUNDEF; j = IUNDEF
#endif

    return
  end subroutine ATMOS_DYN_FVM_fluxY_XYZ_ud1


  !-----------------------------------------------------------------------------
  !> calculation z-flux at XYW
  subroutine ATMOS_DYN_FVM_fluxZ_XYW_ud1( &
       flux,              &
       mom, val, DENS,    &
       GSQRT, J33G,       &
       num_diff,          &
       CDZ, FDZ,          &
       dtrk,              &
       IIS, IIE, JJS, JJE )
    implicit none

    real(RP), intent(inout) :: flux    (KA,IA,JA)
    real(RP), intent(in)  :: mom     (KA,IA,JA)
    real(RP), intent(in)  :: val     (KA,IA,JA)
    real(RP), intent(in)  :: DENS    (KA,IA,JA)
    real(RP), intent(in)  :: GSQRT   (KA,IA,JA)
    real(RP), intent(in)  :: J33G
    real(RP), intent(in)  :: num_diff(KA,IA,JA)
    real(RP), intent(in)  :: CDZ     (KA)
    real(RP), intent(in)  :: FDZ     (KA-1)
    real(RP), intent(in)  :: dtrk
    integer,  intent(in)  :: IIS, IIE, JJS, JJE

    real(RP) :: vel
    integer  :: k, i, j
    !---------------------------------------------------------------------------

    ! note than z-index is added by -1

    !$omp parallel default(none) private(i,j,k,vel)  &
    !$omp shared(JJS,JJE,IIS,IIE,KS,KE,mom,val,flux,J33G,GSQRT,num_diff,DENS,FDZ,dtrk)

    !$omp do OMP_SCHEDULE_ collapse(2)
    do j = JJS, JJE
    do i = IIS, IIE
    do k = KS+1, KE-1
#ifdef DEBUG
       call CHECK( __LINE__, mom(k-1,i,j) )
       call CHECK( __LINE__, mom(k  ,i,j) )

       call CHECK( __LINE__, val(k-1,i,j) )
       call CHECK( __LINE__, val(k,i,j) )

#endif
       vel = ( 0.5_RP * ( mom(k-1,i,j) &
                        + mom(k,i,j) ) ) &
           / DENS(k,i,j)
       flux(k-1,i,j) = J33G * vel &
                   * ( F1 * ( val(k,i,j)+val(k-1,i,j) ) - sign(F1,vel) * ( val(k,i,j)-val(k-1,i,j) ) ) 
    enddo
    enddo
    enddo
    !$omp end do nowait
#ifdef DEBUG
    k = IUNDEF; i = IUNDEF; j = IUNDEF
#endif

    !$omp do OMP_SCHEDULE_ collapse(2)
    do j = JJS, JJE
    do i = IIS, IIE
#ifdef DEBUG


#endif
       ! The boundary condition is qflx_hi + qflxJ13 + qfluxJ23 = 0 at KS.
       ! The flux at KS can be non-zero.
       ! To reduce calculations, all the fluxes are set to zero.
       flux(KS-1,i,j) = 0.0_RP ! k = KS



       flux(KE-1,i,j) = 0.0_RP ! k = KE
       flux(KE  ,i,j) = 0.0_RP ! k = KE+1
    enddo
    enddo
    !$omp end do
    
    !$omp end parallel

    return
  end subroutine ATMOS_DYN_FVM_fluxZ_XYW_ud1


  !-----------------------------------------------------------------------------
  !> calculation J13-flux at XYW
  subroutine ATMOS_DYN_FVM_fluxJ13_XYW_ud1( &
       flux,              &
       mom, val, DENS,    &
       GSQRT, J13G, MAPF, &
       CDZ,               &
       IIS, IIE, JJS, JJE )
    implicit none

    real(RP), intent(inout) :: flux    (KA,IA,JA)
    real(RP), intent(in)  :: mom     (KA,IA,JA)
    real(RP), intent(in)  :: val     (KA,IA,JA)
    real(RP), intent(in)  :: DENS    (KA,IA,JA)
    real(RP), intent(in)  :: GSQRT   (KA,IA,JA)
    real(RP), intent(in)  :: J13G    (KA,IA,JA)
    real(RP), intent(in)  :: MAPF    (   IA,JA,2)
    real(RP), intent(in)  :: CDZ     (KA)
    integer,  intent(in)  :: IIS, IIE, JJS, JJE

    real(RP) :: vel
    integer  :: k, i, j
    !---------------------------------------------------------------------------

    !$omp parallel default(none) private(i,j,k,vel) &
    !$omp shared(JJS,JJE,IIS,IIE,KS,KE,mom,val,DENS,flux,J13G,MAPF)

    !$omp do OMP_SCHEDULE_ collapse(2)
    do j = JJS, JJE
    do i = IIS, IIE
    do k = KS+2, KE-1
       vel = ( 0.5_RP * ( mom(k,i,j)+mom(k,i-1,j) ) ) &
           / DENS(k,i,j)
       vel = vel * J13G(k,i,j)
       flux(k-1,i,j) = vel / MAPF(i,j,+2) &
                   * ( F1 * ( val(k,i,j)+val(k-1,i,j) ) - sign(F1,vel) * ( val(k,i,j)-val(k-1,i,j) ) )
    enddo
    enddo
    enddo
    !$omp end do nowait
    
    !$omp do OMP_SCHEDULE_ collapse(2)
    do j = JJS, JJE
    do i = IIS, IIE
       ! The boundary condition is qflx_hi + qflxJ13 + qfluxJ23 = 0 at KS.
       ! The flux at KS can be non-zero.
       ! To reduce calculations, all the fluxes are set to zero.
       flux(KS-1,i,j) = 0.0_RP ! k = KS

       ! physically incorrect but for numerical stability
       vel = ( ( 0.5_RP * ( mom(KS+1,i,j)+mom(KS+1,i-1,j) ) ) / DENS(KS+1,i,j) &
             + ( 0.5_RP * ( mom(KS,i,j)+mom(KS,i-1,j) ) ) / DENS(KS  ,i,j) ) * 0.5_RP
!       vel = ( 0.5_RP * ( mom(KS+1,i,j)+mom(KS+1,i-1,j) ) ) &
!           / DENS(KS+1,i,j)
       vel = vel * J13G(KS+1,i,j)
       flux(KS,i,j) =  vel / MAPF(i,j,+2) &
                   * ( val(KS,i,j) &
                     * ( 0.5_RP + sign(0.5_RP,vel) ) &
                + ( 2.0_RP * val(KS,i,j) + 5.0_RP * val(KS+1,i,j) - val(KS+2,i,j) ) / 6.0_RP &
                     * ( 0.5_RP - sign(0.5_RP,vel) ) ) ! k = KS+1


       flux(KE-1,i,j) = 0.0_RP
    enddo
    enddo
    !$omp end do
    
    !$omp end parallel

    return
  end subroutine ATMOS_DYN_FVM_fluxJ13_XYW_ud1

  !-----------------------------------------------------------------------------
  !> calculation J23-flux at XYW
  subroutine ATMOS_DYN_FVM_fluxJ23_XYW_ud1( &
       flux,              &
       mom, val, DENS,    &
       GSQRT, J23G, MAPF, &
       CDZ,               &
       IIS, IIE, JJS, JJE )
    implicit none

    real(RP), intent(inout) :: flux    (KA,IA,JA)
    real(RP), intent(in)  :: mom     (KA,IA,JA)
    real(RP), intent(in)  :: val     (KA,IA,JA)
    real(RP), intent(in)  :: DENS    (KA,IA,JA)
    real(RP), intent(in)  :: GSQRT   (KA,IA,JA)
    real(RP), intent(in)  :: J23G    (KA,IA,JA)
    real(RP), intent(in)  :: MAPF    (   IA,JA,2)
    real(RP), intent(in)  :: CDZ     (KA)
    integer,  intent(in)  :: IIS, IIE, JJS, JJE

    real(RP) :: vel
    integer  :: k, i, j
    !---------------------------------------------------------------------------

    !$omp parallel default(none) private(i,j,k,vel) &
    !$omp shared(JJS,JJE,IIS,IIE,KS,KE,mom,val,DENS,flux,J23G,MAPF)

    !$omp do OMP_SCHEDULE_ collapse(2)
    do j = JJS, JJE
    do i = IIS, IIE
    do k = KS+2, KE-1
       vel = ( 0.5_RP * ( mom(k,i,j)+mom(k,i,j-1) ) ) &
           / DENS(k,i,j)
       vel = vel * J23G(k,i,j)
       flux(k-1,i,j) = vel / MAPF(i,j,+1) &
                   * ( F1 * ( val(k,i,j)+val(k-1,i,j) ) - sign(F1,vel) * ( val(k,i,j)-val(k-1,i,j) ) )
    enddo
    enddo
    enddo
    !$omp end do nowait
    
    !$omp do OMP_SCHEDULE_ collapse(2)
    do j = JJS, JJE
    do i = IIS, IIE
       ! The boundary condition is qflx_hi + qflxJ13 + qfluxJ23 = 0 at KS.
       ! The flux at KS can be non-zero.
       ! To reduce calculations, all the fluxes are set to zero.
       flux(KS-1,i,j) = 0.0_RP ! k = KS

       ! physically incorrect but for numerical stability
       vel = ( ( 0.5_RP * ( mom(KS+1,i,j)+mom(KS+1,i,j-1) ) ) / DENS(KS+1,i,j) &
             + ( 0.5_RP * ( mom(KS,i,j)+mom(KS,i,j-1) ) ) / DENS(KS  ,i,j) ) * 0.5_RP
!       vel = ( 0.5_RP * ( mom(KS+1,i,j)+mom(KS+1,i,j-1) ) ) &
!           / DENS(KS+1,i,j)
       vel = vel * J23G(KS+1,i,j)
       flux(KS,i,j) =  vel / MAPF(i,j,+1) &
                   * ( val(KS,i,j) &
                     * ( 0.5_RP + sign(0.5_RP,vel) ) &
                + ( 2.0_RP * val(KS,i,j) + 5.0_RP * val(KS+1,i,j) - val(KS+2,i,j) ) / 6.0_RP &
                     * ( 0.5_RP - sign(0.5_RP,vel) ) ) ! k = KS+1


       flux(KE-1,i,j) = 0.0_RP
    enddo
    enddo
    !$omp end do
    
    !$omp end parallel

    return
  end subroutine ATMOS_DYN_FVM_fluxJ23_XYW_ud1


  !-----------------------------------------------------------------------------
  !> calculation X-flux at XYW
  subroutine ATMOS_DYN_FVM_fluxX_XYW_ud1( &
       flux,              &
       mom, val, DENS,    &
       GSQRT, MAPF,       &
       num_diff,          &
       CDZ,               &
       IIS, IIE, JJS, JJE )
    implicit none

    real(RP), intent(inout) :: flux    (KA,IA,JA)
    real(RP), intent(in)  :: mom     (KA,IA,JA)
    real(RP), intent(in)  :: val     (KA,IA,JA)
    real(RP), intent(in)  :: DENS    (KA,IA,JA)
    real(RP), intent(in)  :: GSQRT   (KA,IA,JA)
    real(RP), intent(in)  :: MAPF    (   IA,JA,2)
    real(RP), intent(in)  :: num_diff(KA,IA,JA)
    real(RP), intent(in)  :: CDZ     (KA)
    integer,  intent(in)  :: IIS, IIE, JJS, JJE

    real(RP) :: vel
    integer  :: k, i, j
    !---------------------------------------------------------------------------

    !$omp parallel default(none) private(i,j,k,vel)                           &
    !$omp shared(JJS,JJE,IIS,IIE,KS,KE,mom,val,DENS,flux,GSQRT,MAPF,num_diff) &
    !$omp shared(CDZ)

    !$omp do OMP_SCHEDULE_ collapse(2)
    do j = JJS, JJE
    do i = IIS-1, IIE
    do k = KS, KE-1
#ifdef DEBUG
       call CHECK( __LINE__, mom(k  ,i,j) )
       call CHECK( __LINE__, mom(k+1,i,j) )

       call CHECK( __LINE__, val(k,i,j) )
       call CHECK( __LINE__, val(k,i+1,j) )

#endif
       vel = ( F2H(k,1,I_UYZ) &
             * mom(k+1,i,j) &
             + F2H(k,2,I_UYZ) &
             * mom(k,i,j) ) &
           / ( F2H(k,1,I_UYZ) &
             * 0.5_RP * ( DENS(k+1,i,j)+DENS(k+1,i+1,j) ) &
             + F2H(k,2,I_UYZ) &
             * 0.5_RP * ( DENS(k,i,j)+DENS(k,i+1,j) ) )
       flux(k,i,j) = GSQRT(k,i,j) / MAPF(i,j,+2) * vel &
                   * ( F1 * ( val(k,i+1,j)+val(k,i,j) ) - sign(F1,vel) * ( val(k,i+1,j)-val(k,i,j) ) ) 
    enddo
    enddo
    enddo
    !$omp end do nowait
#ifdef DEBUG
    k = IUNDEF; i = IUNDEF; j = IUNDEF
#endif

    !$omp do OMP_SCHEDULE_ collapse(2)
    do j = JJS, JJE
    do i = IIS-1, IIE
       flux(KE,i,j) = 0.0_RP
    enddo
    enddo
    !$omp end do
    
    !$omp end parallel
#ifdef DEBUG
    k = IUNDEF; i = IUNDEF; j = IUNDEF
#endif

    return
  end subroutine ATMOS_DYN_FVM_fluxX_XYW_ud1

  !-----------------------------------------------------------------------------
  !> calculation Y-flux at XYW
  subroutine ATMOS_DYN_FVM_fluxY_XYW_ud1( &
       flux,              &
       mom, val, DENS,    &
       GSQRT, MAPF,       &
       num_diff,          &
       CDZ,               &
       IIS, IIE, JJS, JJE )
    implicit none

    real(RP), intent(inout) :: flux    (KA,IA,JA)
    real(RP), intent(in)  :: mom     (KA,IA,JA)
    real(RP), intent(in)  :: val     (KA,IA,JA)
    real(RP), intent(in)  :: DENS    (KA,IA,JA)
    real(RP), intent(in)  :: GSQRT   (KA,IA,JA)
    real(RP), intent(in)  :: MAPF    (   IA,JA,2)
    real(RP), intent(in)  :: num_diff(KA,IA,JA)
    real(RP), intent(in)  :: CDZ     (KA)
    integer,  intent(in)  :: IIS, IIE, JJS, JJE

    real(RP) :: vel
    integer  :: k, i, j
    !---------------------------------------------------------------------------

    !$omp parallel default(none) private(i,j,k,vel)                           &
    !$omp shared(JJS,JJE,IIS,IIE,KS,KE,mom,val,DENS,flux,GSQRT,MAPF,num_diff) &
    !$omp shared(CDZ)

    !$omp do OMP_SCHEDULE_ collapse(2)
    do j = JJS-1, JJE
    do i = IIS, IIE
    do k = KS, KE-1
#ifdef DEBUG
       call CHECK( __LINE__, mom(k  ,i,j) )
       call CHECK( __LINE__, mom(k+1,i,j) )

       call CHECK( __LINE__, val(k,i,j) )
       call CHECK( __LINE__, val(k,i,j+1) )

#endif
       vel = ( F2H(k,1,I_XVZ) &
             * mom(k+1,i,j) &
             + F2H(k,2,I_XVZ) &
             * mom(k,i,j) ) &
           / ( F2H(k,1,I_XVZ) &
             * 0.5_RP * ( DENS(k+1,i,j)+DENS(k+1,i,j+1) ) &
             + F2H(k,2,I_XVZ) &
             * 0.5_RP * ( DENS(k,i,j)+DENS(k,i,j+1) ) )
       flux(k,i,j) = GSQRT(k,i,j) / MAPF(i,j,+1) * vel &
                   * ( F1 * ( val(k,i,j+1)+val(k,i,j) ) - sign(F1,vel) * ( val(k,i,j+1)-val(k,i,j) ) ) 
    enddo
    enddo
    enddo
    !$omp end do nowait
#ifdef DEBUG
    k = IUNDEF; i = IUNDEF; j = IUNDEF
#endif

    !$omp do OMP_SCHEDULE_ collapse(2)
    do j = JJS-1, JJE
    do i = IIS, IIE
       flux(KE,i,j) = 0.0_RP
    enddo
    enddo
    !$omp end do
    
    !$omp end parallel
#ifdef DEBUG
    k = IUNDEF; i = IUNDEF; j = IUNDEF
#endif

    return
  end subroutine ATMOS_DYN_FVM_fluxY_XYW_ud1


  !-----------------------------------------------------------------------------
  !> calculation z-flux at UY
  subroutine ATMOS_DYN_FVM_fluxZ_UYZ_ud1( &
       flux,              &
       mom, val, DENS,    &
       GSQRT, J33G,       &
       num_diff,          &
       CDZ,               &
       IIS, IIE, JJS, JJE )
    implicit none

    real(RP), intent(inout) :: flux    (KA,IA,JA)
    real(RP), intent(in)  :: mom     (KA,IA,JA)
    real(RP), intent(in)  :: val     (KA,IA,JA)
    real(RP), intent(in)  :: DENS    (KA,IA,JA)
    real(RP), intent(in)  :: GSQRT   (KA,IA,JA)
    real(RP), intent(in)  :: J33G
    real(RP), intent(in)  :: num_diff(KA,IA,JA)
    real(RP), intent(in)  :: CDZ     (KA)
    integer,  intent(in)  :: IIS, IIE, JJS, JJE

    real(RP) :: vel
    integer  :: k, i, j
    !---------------------------------------------------------------------------

    !$omp parallel default(none) private(i,j,k,vel)                           &
    !$omp shared(JJS,JJE,IIS,IIE,KS,KE,mom,val,DENS,flux,J33G,GSQRT,num_diff) &
    !$omp shared(CDZ)

    !$omp do OMP_SCHEDULE_ collapse(2) 
    do j = JJS, JJE
    do i = IIS, IIE
    do k = KS, KE-1
#ifdef DEBUG
       call CHECK( __LINE__, mom(k,i,j) )
       call CHECK( __LINE__, mom(k,i+1,j) )

       call CHECK( __LINE__, val(k,i,j) )
       call CHECK( __LINE__, val(k+1,i,j) )

#endif
       vel = ( 0.5_RP * ( mom(k,i,j)+mom(k,i+1,j) ) ) &
           / ( F2H(k,1,I_UYZ) &
             * 0.5_RP * ( DENS(k+1,i,j)+DENS(k+1,i+1,j) ) &
             + F2H(k,2,I_UYZ) &
             * 0.5_RP * ( DENS(k,i,j)+DENS(k,i+1,j) ) )
       flux(k,i,j) = J33G * vel &
                   * ( F1 * ( val(k+1,i,j)+val(k,i,j) ) - sign(F1,vel) * ( val(k+1,i,j)-val(k,i,j) ) ) 
    enddo
    enddo
    enddo
    !$omp end do nowait
#ifdef DEBUG
    k = IUNDEF; i = IUNDEF; j = IUNDEF
#endif

    !$omp do OMP_SCHEDULE_ collapse(2) 
    do j = JJS, JJE
    do i = IIS, IIE
#ifdef DEBUG

#endif
       ! The boundary condition is qflx_hi + qflxJ13 + qfluxJ23 = 0 at KS-1.
       ! The flux at KS-1 can be non-zero.
       ! To reduce calculations, all the fluxes are set to zero.
       flux(KS-1,i,j) = 0.0_RP

       flux(KE,i,j) = 0.0_RP
    enddo
    enddo
    !$omp end do
    
    !$omp end parallel
#ifdef DEBUG
    k = IUNDEF; i = IUNDEF; j = IUNDEF
#endif

    return
  end subroutine ATMOS_DYN_FVM_fluxZ_UYZ_ud1

  !-----------------------------------------------------------------------------
  !> calculation J13-flux at UYZ
  subroutine ATMOS_DYN_FVM_fluxJ13_UYZ_ud1( &
       flux,              &
       mom, val, DENS,    &
       GSQRT, J13G, MAPF, &
       CDZ,               &
       IIS, IIE, JJS, JJE )
    implicit none

    real(RP), intent(inout) :: flux    (KA,IA,JA)
    real(RP), intent(in)  :: mom     (KA,IA,JA)
    real(RP), intent(in)  :: val     (KA,IA,JA)
    real(RP), intent(in)  :: DENS    (KA,IA,JA)
    real(RP), intent(in)  :: GSQRT   (KA,IA,JA)
    real(RP), intent(in)  :: J13G    (KA,IA,JA)
    real(RP), intent(in)  :: MAPF    (   IA,JA,2)
    real(RP), intent(in)  :: CDZ     (KA)
    integer,  intent(in)  :: IIS, IIE, JJS, JJE

    real(RP) :: vel
    integer  :: k, i, j
    !---------------------------------------------------------------------------

    !$omp parallel default(none) private(i,j,k,vel)                      &
    !$omp shared(JJS,JJE,IIS,IIE,KS,KE,mom,val,DENS,flux,J13G,MAPF) &
    !$omp shared(GSQRT,CDZ)
  
    !$omp do OMP_SCHEDULE_ collapse(2)
    do j = JJS, JJE
    do i = IIS, IIE
    do k = KS, KE-1
       vel = ( F2H(k,1,I_UYZ) &
             * mom(k+1,i,j) &
             + F2H(k,2,I_UYZ) &
             * mom(k,i,j) ) &
           / ( F2H(k,1,I_UYZ) &
             * 0.5_RP * ( DENS(k+1,i,j)+DENS(k+1,i+1,j) ) &
             + F2H(k,2,I_UYZ) &
             * 0.5_RP * ( DENS(k,i,j)+DENS(k,i+1,j) ) )
       vel = vel * J13G(k,i,j)
       flux(k,i,j) = vel / MAPF(i,j,+2) &
                   * ( F1 * ( val(k+1,i,j)+val(k,i,j) ) - sign(F1,vel) * ( val(k+1,i,j)-val(k,i,j) ) )
    enddo
    enddo
    enddo
    !$omp end do nowait

    !$omp do OMP_SCHEDULE_ collapse(2) 
    do j = JJS, JJE
    do i = IIS, IIE
       ! The boundary condition is qflx_hi + qflxJ13 + qfluxJ23 = 0 at KS-1.
       ! The flux at KS-1 can be non-zero.
       ! To reduce calculations, all the fluxes are set to zero.
       flux(KS-1,i,j) = 0.0_RP

       flux(KE  ,i,j) = 0.0_RP
    enddo
    enddo
    !$omp end do
    
    !$omp end parallel
    return
  end subroutine ATMOS_DYN_FVM_fluxJ13_UYZ_ud1

  !-----------------------------------------------------------------------------
  !> calculation J23-flux at UYZ
  subroutine ATMOS_DYN_FVM_fluxJ23_UYZ_ud1( &
       flux,              &
       mom, val, DENS,    &
       GSQRT, J23G, MAPF, &
       CDZ,               &
       IIS, IIE, JJS, JJE )
    implicit none

    real(RP), intent(inout) :: flux    (KA,IA,JA)
    real(RP), intent(in)  :: mom     (KA,IA,JA)
    real(RP), intent(in)  :: val     (KA,IA,JA)
    real(RP), intent(in)  :: DENS    (KA,IA,JA)
    real(RP), intent(in)  :: GSQRT   (KA,IA,JA)
    real(RP), intent(in)  :: J23G    (KA,IA,JA)
    real(RP), intent(in)  :: MAPF    (   IA,JA,2)
    real(RP), intent(in)  :: CDZ     (KA)
    integer,  intent(in)  :: IIS, IIE, JJS, JJE

    real(RP) :: vel
    integer  :: k, i, j
    !---------------------------------------------------------------------------

    !$omp parallel default(none) private(i,j,k,vel)                      &
    !$omp shared(JJS,JJE,IIS,IIE,KS,KE,mom,val,DENS,flux,J23G,MAPF) &
    !$omp shared(GSQRT,CDZ)
  
    !$omp do OMP_SCHEDULE_ collapse(2)
    do j = JJS, JJE
    do i = IIS, IIE
    do k = KS, KE-1
       vel = ( F2H(k,1,I_UYZ) &
             * 0.25_RP * ( mom(k+1,i,j)+mom(k+1,i+1,j)+mom(k+1,i,j-1)+mom(k+1,i+1,j-1) ) &
             + F2H(k,2,I_UYZ) &
             * 0.25_RP * ( mom(k,i,j)+mom(k,i+1,j)+mom(k,i,j-1)+mom(k,i+1,j-1) ) ) &
           / ( F2H(k,1,I_UYZ) &
             * 0.5_RP * ( DENS(k+1,i,j)+DENS(k+1,i+1,j) ) &
             + F2H(k,2,I_UYZ) &
             * 0.5_RP * ( DENS(k,i,j)+DENS(k,i+1,j) ) )
       vel = vel * J23G(k,i,j)
       flux(k,i,j) = vel / MAPF(i,j,+1) &
                   * ( F1 * ( val(k+1,i,j)+val(k,i,j) ) - sign(F1,vel) * ( val(k+1,i,j)-val(k,i,j) ) )
    enddo
    enddo
    enddo
    !$omp end do nowait

    !$omp do OMP_SCHEDULE_ collapse(2) 
    do j = JJS, JJE
    do i = IIS, IIE
       ! The boundary condition is qflx_hi + qflxJ13 + qfluxJ23 = 0 at KS-1.
       ! The flux at KS-1 can be non-zero.
       ! To reduce calculations, all the fluxes are set to zero.
       flux(KS-1,i,j) = 0.0_RP

       flux(KE  ,i,j) = 0.0_RP
    enddo
    enddo
    !$omp end do
    
    !$omp end parallel
    return
  end subroutine ATMOS_DYN_FVM_fluxJ23_UYZ_ud1

  !-----------------------------------------------------------------------------
  !> calculation X-flux at UY
  subroutine ATMOS_DYN_FVM_fluxX_UYZ_ud1( &
       flux,              &
       mom, val, DENS,    &
       GSQRT, MAPF,       &
       num_diff,          &
       CDZ,               &
       IIS, IIE, JJS, JJE )
    implicit none

    real(RP), intent(inout) :: flux    (KA,IA,JA)
    real(RP), intent(in)  :: mom     (KA,IA,JA)
    real(RP), intent(in)  :: val     (KA,IA,JA)
    real(RP), intent(in)  :: DENS    (KA,IA,JA)
    real(RP), intent(in)  :: GSQRT   (KA,IA,JA)
    real(RP), intent(in)  :: MAPF    (   IA,JA,2)
    real(RP), intent(in)  :: num_diff(KA,IA,JA)
    real(RP), intent(in)  :: CDZ     (KA)
    integer,  intent(in)  :: IIS, IIE, JJS, JJE

    real(RP) :: vel
    integer  :: k, i, j
    !---------------------------------------------------------------------------

    ! note that x-index is added by -1

    !$omp parallel do default(none) private(i,j,k) OMP_SCHEDULE_ collapse(2) &
    !$omp private(vel) &
    !$omp shared(JJS,JJE,IIS,IIE,KS,KE,mom,val,DENS,flux,GSQRT,MAPF,num_diff)
    do j = JJS, JJE
    do i = IIS, IIE+1
    do k = KS, KE
#ifdef DEBUG
       call CHECK( __LINE__, mom(k,i  ,j) )
       call CHECK( __LINE__, mom(k,i-1,j) )

       call CHECK( __LINE__, val(k,i-1,j) )
       call CHECK( __LINE__, val(k,i,j) )

#endif
       vel = ( 0.5_RP * ( mom(k,i,j)+mom(k,i-1,j) ) ) &
           / ( DENS(k,i,j) )
       flux(k,i-1,j) = GSQRT(k,i,j) / MAPF(i,j,+2) * vel &
                   * ( F1 * ( val(k,i,j)+val(k,i-1,j) ) - sign(F1,vel) * ( val(k,i,j)-val(k,i-1,j) ) ) 
    enddo
    enddo
    enddo
#ifdef DEBUG
    k = IUNDEF; i = IUNDEF; j = IUNDEF
#endif

    return
  end subroutine ATMOS_DYN_FVM_fluxX_UYZ_ud1

  !-----------------------------------------------------------------------------
  !> calculation Y-flux at UY
  subroutine ATMOS_DYN_FVM_fluxY_UYZ_ud1( &
       flux,              &
       mom, val, DENS,    &
       GSQRT, MAPF,       &
       num_diff,          &
       CDZ,               &
       IIS, IIE, JJS, JJE )
    implicit none

    real(RP), intent(inout) :: flux    (KA,IA,JA)
    real(RP), intent(in)  :: mom     (KA,IA,JA)
    real(RP), intent(in)  :: val     (KA,IA,JA)
    real(RP), intent(in)  :: DENS    (KA,IA,JA)
    real(RP), intent(in)  :: GSQRT   (KA,IA,JA)
    real(RP), intent(in)  :: MAPF    (   IA,JA,2)
    real(RP), intent(in)  :: num_diff(KA,IA,JA)
    real(RP), intent(in)  :: CDZ     (KA)
    integer,  intent(in)  :: IIS, IIE, JJS, JJE

    real(RP) :: vel
    integer  :: k, i, j
    !---------------------------------------------------------------------------

    !$omp parallel do default(none) private(i,j,k) OMP_SCHEDULE_ collapse(2) &
    !$omp private(vel) &
    !$omp shared(JJS,JJE,IIS,IIE,KS,KE,mom,val,DENS,flux,GSQRT,MAPF,num_diff)
    do j = JJS-1, JJE
    do i = IIS, IIE
    do k = KS, KE
#ifdef DEBUG
       call CHECK( __LINE__, mom(k,i  ,j) )
       call CHECK( __LINE__, mom(k,i-1,j) )

       call CHECK( __LINE__, val(k,i,j) )
       call CHECK( __LINE__, val(k,i,j+1) )

#endif
       vel = ( 0.5_RP * ( mom(k,i,j)+mom(k,i+1,j) ) ) &
           / ( 0.25_RP * ( DENS(k,i,j)+DENS(k,i+1,j)+DENS(k,i,j+1)+DENS(k,i+1,j+1) ) )
       flux(k,i,j) = GSQRT(k,i,j) / MAPF(i,j,+1) * vel &
                   * ( F1 * ( val(k,i,j+1)+val(k,i,j) ) - sign(F1,vel) * ( val(k,i,j+1)-val(k,i,j) ) ) 
    enddo
    enddo
    enddo
#ifdef DEBUG
    k = IUNDEF; i = IUNDEF; j = IUNDEF
#endif

    return
  end subroutine ATMOS_DYN_FVM_fluxY_UYZ_ud1



  !-----------------------------------------------------------------------------
  !> calculation z-flux at XV
  subroutine ATMOS_DYN_FVM_fluxZ_XVZ_ud1( &
       flux,              &
       mom, val, DENS,    &
       GSQRT, J33G,       &
       num_diff,          &
       CDZ,               &
       IIS, IIE, JJS, JJE )
    implicit none

    real(RP), intent(inout) :: flux    (KA,IA,JA)
    real(RP), intent(in)  :: mom     (KA,IA,JA)
    real(RP), intent(in)  :: val     (KA,IA,JA)
    real(RP), intent(in)  :: DENS    (KA,IA,JA)
    real(RP), intent(in)  :: GSQRT   (KA,IA,JA)
    real(RP), intent(in)  :: J33G
    real(RP), intent(in)  :: num_diff(KA,IA,JA)
    real(RP), intent(in)  :: CDZ     (KA)
    integer,  intent(in)  :: IIS, IIE, JJS, JJE

    real(RP) :: vel
    integer  :: k, i, j
    !---------------------------------------------------------------------------

    !$omp parallel default(none) private(i,j,k,vel)                           &
    !$omp shared(JJS,JJE,IIS,IIE,KS,KE,mom,val,DENS,flux,J33G,GSQRT,num_diff) &
    !$omp shared(CDZ)

    !$omp do OMP_SCHEDULE_ collapse(2) 
    do j = JJS, JJE
    do i = IIS, IIE
    do k = KS, KE-1
#ifdef DEBUG
       call CHECK( __LINE__, mom(k,i,j) )
       call CHECK( __LINE__, mom(k,i,j+1) )

       call CHECK( __LINE__, val(k,i,j) )
       call CHECK( __LINE__, val(k+1,i,j) )

#endif
       vel = ( 0.5_RP * ( mom(k,i,j)+mom(k,i,j+1) ) ) &
           / ( F2H(k,1,I_XVZ) &
             * 0.5_RP * ( DENS(k+1,i,j)+DENS(k+1,i,j+1) ) &
             + F2H(k,2,I_XVZ) &
             * 0.5_RP * ( DENS(k,i,j)+DENS(k,i,j+1) ) )
       flux(k,i,j) = J33G * vel &
                   * ( F1 * ( val(k+1,i,j)+val(k,i,j) ) - sign(F1,vel) * ( val(k+1,i,j)-val(k,i,j) ) ) 
    enddo
    enddo
    enddo
    !$omp end do nowait
#ifdef DEBUG
    k = IUNDEF; i = IUNDEF; j = IUNDEF
#endif

    !$omp do OMP_SCHEDULE_ collapse(2) 
    do j = JJS, JJE
    do i = IIS, IIE
#ifdef DEBUG

#endif
       ! The boundary condition is qflx_hi + qflxJ13 + qfluxJ23 = 0 at KS-1.
       ! The flux at KS-1 can be non-zero.
       ! To reduce calculations, all the fluxes are set to zero.
       flux(KS-1,i,j) = 0.0_RP

       flux(KE,i,j) = 0.0_RP
    enddo
    enddo
    !$omp end do
    
    !$omp end parallel
#ifdef DEBUG
    k = IUNDEF; i = IUNDEF; j = IUNDEF
#endif

    return
  end subroutine ATMOS_DYN_FVM_fluxZ_XVZ_ud1

  !-----------------------------------------------------------------------------
  !> calculation J13-flux at XVZ
  subroutine ATMOS_DYN_FVM_fluxJ13_XVZ_ud1( &
       flux,              &
       mom, val, DENS,    &
       GSQRT, J13G, MAPF, &
       CDZ,               &
       IIS, IIE, JJS, JJE )
    implicit none

    real(RP), intent(inout) :: flux    (KA,IA,JA)
    real(RP), intent(in)  :: mom     (KA,IA,JA)
    real(RP), intent(in)  :: val     (KA,IA,JA)
    real(RP), intent(in)  :: DENS    (KA,IA,JA)
    real(RP), intent(in)  :: GSQRT   (KA,IA,JA)
    real(RP), intent(in)  :: J13G    (KA,IA,JA)
    real(RP), intent(in)  :: MAPF    (   IA,JA,2)
    real(RP), intent(in)  :: CDZ     (KA)
    integer,  intent(in)  :: IIS, IIE, JJS, JJE

    real(RP) :: vel
    integer  :: k, i, j
    !---------------------------------------------------------------------------

    !$omp parallel default(none) private(i,j,k,vel)                      &
    !$omp shared(JJS,JJE,IIS,IIE,KS,KE,mom,val,DENS,flux,J13G,MAPF) &
    !$omp shared(GSQRT,CDZ)
  
    !$omp do OMP_SCHEDULE_ collapse(2)
    do j = JJS, JJE
    do i = IIS, IIE
    do k = KS, KE-1
       vel = ( F2H(k,1,I_XVZ) &
             * 0.25_RP * ( mom(k+1,i,j)+mom(k+1,i-1,j)+mom(k+1,i,j+1)+mom(k+1,i-1,j+1) ) &
             + F2H(k,2,I_XVZ) &
             * 0.25_RP * ( mom(k,i,j)+mom(k,i-1,j)+mom(k,i,j+1)+mom(k,i-1,j+1) ) ) &
           / ( F2H(k,1,I_XVZ) &
             * 0.5_RP * ( DENS(k+1,i,j)+DENS(k+1,i,j+1) ) &
             + F2H(k,2,I_XVZ) &
             * 0.5_RP * ( DENS(k,i,j)+DENS(k,i,j+1) ) )
       vel = vel * J13G(k,i,j)
       flux(k,i,j) = vel / MAPF(i,j,+2) &
                   * ( F1 * ( val(k+1,i,j)+val(k,i,j) ) - sign(F1,vel) * ( val(k+1,i,j)-val(k,i,j) ) )
    enddo
    enddo
    enddo
    !$omp end do nowait

    !$omp do OMP_SCHEDULE_ collapse(2) 
    do j = JJS, JJE
    do i = IIS, IIE
       ! The boundary condition is qflx_hi + qflxJ13 + qfluxJ23 = 0 at KS-1.
       ! The flux at KS-1 can be non-zero.
       ! To reduce calculations, all the fluxes are set to zero.
       flux(KS-1,i,j) = 0.0_RP

       flux(KE  ,i,j) = 0.0_RP
    enddo
    enddo
    !$omp end do
    
    !$omp end parallel
    return
  end subroutine ATMOS_DYN_FVM_fluxJ13_XVZ_ud1

  !-----------------------------------------------------------------------------
  !> calculation J23-flux at XVZ
  subroutine ATMOS_DYN_FVM_fluxJ23_XVZ_ud1( &
       flux,              &
       mom, val, DENS,    &
       GSQRT, J23G, MAPF, &
       CDZ,               &
       IIS, IIE, JJS, JJE )
    implicit none

    real(RP), intent(inout) :: flux    (KA,IA,JA)
    real(RP), intent(in)  :: mom     (KA,IA,JA)
    real(RP), intent(in)  :: val     (KA,IA,JA)
    real(RP), intent(in)  :: DENS    (KA,IA,JA)
    real(RP), intent(in)  :: GSQRT   (KA,IA,JA)
    real(RP), intent(in)  :: J23G    (KA,IA,JA)
    real(RP), intent(in)  :: MAPF    (   IA,JA,2)
    real(RP), intent(in)  :: CDZ     (KA)
    integer,  intent(in)  :: IIS, IIE, JJS, JJE

    real(RP) :: vel
    integer  :: k, i, j
    !---------------------------------------------------------------------------

    !$omp parallel default(none) private(i,j,k,vel)                      &
    !$omp shared(JJS,JJE,IIS,IIE,KS,KE,mom,val,DENS,flux,J23G,MAPF) &
    !$omp shared(GSQRT,CDZ)
  
    !$omp do OMP_SCHEDULE_ collapse(2)
    do j = JJS, JJE
    do i = IIS, IIE
    do k = KS, KE-1
       vel = ( F2H(k,1,I_XVZ) &
             * mom(k+1,i,j) &
             + F2H(k,2,I_XVZ) &
             * mom(k,i,j) ) &
           / ( F2H(k,1,I_XVZ) &
             * 0.5_RP * ( DENS(k+1,i,j)+DENS(k+1,i,j+1) ) &
             + F2H(k,2,I_XVZ) &
             * 0.5_RP * ( DENS(k,i,j)+DENS(k,i,j+1) ) )
       vel = vel * J23G(k,i,j)
       flux(k,i,j) = vel / MAPF(i,j,+1) &
                   * ( F1 * ( val(k+1,i,j)+val(k,i,j) ) - sign(F1,vel) * ( val(k+1,i,j)-val(k,i,j) ) )
    enddo
    enddo
    enddo
    !$omp end do nowait

    !$omp do OMP_SCHEDULE_ collapse(2) 
    do j = JJS, JJE
    do i = IIS, IIE
       ! The boundary condition is qflx_hi + qflxJ13 + qfluxJ23 = 0 at KS-1.
       ! The flux at KS-1 can be non-zero.
       ! To reduce calculations, all the fluxes are set to zero.
       flux(KS-1,i,j) = 0.0_RP

       flux(KE  ,i,j) = 0.0_RP
    enddo
    enddo
    !$omp end do
    
    !$omp end parallel
    return
  end subroutine ATMOS_DYN_FVM_fluxJ23_XVZ_ud1

  !-----------------------------------------------------------------------------
  !> calculation X-flux at XV
  subroutine ATMOS_DYN_FVM_fluxX_XVZ_ud1( &
       flux,              &
       mom, val, DENS,    &
       GSQRT, MAPF,       &
       num_diff,          &
       CDZ,               &
       IIS, IIE, JJS, JJE )
    implicit none

    real(RP), intent(inout) :: flux    (KA,IA,JA)
    real(RP), intent(in)  :: mom     (KA,IA,JA)
    real(RP), intent(in)  :: val     (KA,IA,JA)
    real(RP), intent(in)  :: DENS    (KA,IA,JA)
    real(RP), intent(in)  :: GSQRT   (KA,IA,JA)
    real(RP), intent(in)  :: MAPF    (   IA,JA,2)
    real(RP), intent(in)  :: num_diff(KA,IA,JA)
    real(RP), intent(in)  :: CDZ     (KA)
    integer,  intent(in)  :: IIS, IIE, JJS, JJE

    real(RP) :: vel
    integer  :: k, i, j
    !---------------------------------------------------------------------------

    !$omp parallel do default(none) private(i,j,k) OMP_SCHEDULE_ collapse(2) &
    !$omp private(vel) &
    !$omp shared(JJS,JJE,IIS,IIE,KS,KE,mom,val,DENS,flux,GSQRT,MAPF,num_diff)
    do j = JJS, JJE
    do i = IIS-1, IIE
    do k = KS, KE
#ifdef DEBUG
       call CHECK( __LINE__, mom(k,i  ,j) )
       call CHECK( __LINE__, mom(k,i,j-1) )

       call CHECK( __LINE__, val(k,i,j) )
       call CHECK( __LINE__, val(k,i+1,j) )

#endif
       vel = ( 0.5_RP * ( mom(k,i,j)+mom(k,i,j+1) ) ) &
           / ( 0.25_RP * ( DENS(k,i,j)+DENS(k,i+1,j)+DENS(k,i,j+1)+DENS(k,i+1,j+1) ) )
       flux(k,i,j) = GSQRT(k,i,j) / MAPF(i,j,+2) * vel &
                   * ( F1 * ( val(k,i+1,j)+val(k,i,j) ) - sign(F1,vel) * ( val(k,i+1,j)-val(k,i,j) ) ) 
    enddo
    enddo
    enddo
#ifdef DEBUG
    k = IUNDEF; i = IUNDEF; j = IUNDEF
#endif

    return
  end subroutine ATMOS_DYN_FVM_fluxX_XVZ_ud1

  !-----------------------------------------------------------------------------
  !> calculation Y-flux at XV
  subroutine ATMOS_DYN_FVM_fluxY_XVZ_ud1( &
       flux,              &
       mom, val, DENS,    &
       GSQRT, MAPF,       &
       num_diff,          &
       CDZ,               &
       IIS, IIE, JJS, JJE )
    implicit none

    real(RP), intent(inout) :: flux    (KA,IA,JA)
    real(RP), intent(in)  :: mom     (KA,IA,JA)
    real(RP), intent(in)  :: val     (KA,IA,JA)
    real(RP), intent(in)  :: DENS    (KA,IA,JA)
    real(RP), intent(in)  :: GSQRT   (KA,IA,JA)
    real(RP), intent(in)  :: MAPF    (   IA,JA,2)
    real(RP), intent(in)  :: num_diff(KA,IA,JA)
    real(RP), intent(in)  :: CDZ     (KA)
    integer,  intent(in)  :: IIS, IIE, JJS, JJE

    real(RP) :: vel
    integer  :: k, i, j
    !---------------------------------------------------------------------------

    ! note that y-index is added by -1

    !$omp parallel do default(none) private(i,j,k) OMP_SCHEDULE_ collapse(2) &
    !$omp private(vel) &
    !$omp shared(JJS,JJE,IIS,IIE,KS,KE,mom,val,DENS,flux,GSQRT,MAPF,num_diff)
    do j = JJS, JJE+1
    do i = IIS, IIE
    do k = KS, KE
#ifdef DEBUG
       call CHECK( __LINE__, mom(k,i  ,j) )
       call CHECK( __LINE__, mom(k,i,j-1) )

       call CHECK( __LINE__, val(k,i,j-1) )
       call CHECK( __LINE__, val(k,i,j) )

#endif
       vel = ( 0.5_RP * ( mom(k,i,j)+mom(k,i,j-1) ) ) &
           / ( DENS(k,i,j) )
       flux(k,i,j-1) = GSQRT(k,i,j) / MAPF(i,j,+1) * vel &
                   * ( F1 * ( val(k,i,j)+val(k,i,j-1) ) - sign(F1,vel) * ( val(k,i,j)-val(k,i,j-1) ) ) 
    enddo
    enddo
    enddo
#ifdef DEBUG
    k = IUNDEF; i = IUNDEF; j = IUNDEF
#endif

    return
  end subroutine ATMOS_DYN_FVM_fluxY_XVZ_ud1







end module scale_atmos_dyn_fvm_flux_ud1

!--
! vi:set readonly sw=4 ts=8
!
!Local Variables:
!mode: f90
!buffer-read-only: t
!End:
!
!++
