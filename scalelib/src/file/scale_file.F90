!-------------------------------------------------------------------------------
!> module file
!!
!! @par Description
!!          file I/O hundring
!!
!! @author Team SCALE
!!
!<
!-------------------------------------------------------------------------------
! Warning: This file was generated from file/scale_file.F90.erb.
!          Do not edit this file.
!-------------------------------------------------------------------------------
module scale_file
  !-----------------------------------------------------------------------------
  !
  !++ Used modules
  !
  use scale_stdio
  use scale_precision
  use scale_file_h
  use scale_process, only: &
     PRC_abort
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedures
  !
  public :: FILE_setup
  public :: FILE_open
  public :: FILE_create
  public :: FILE_get_dimLength
  public :: FILE_set_option
  public :: FILE_def_axis
  public :: FILE_put_axis
  public :: FILE_write_axis
  public :: FILE_def_associatedCoordinate
  public :: FILE_put_associatedCoordinate
  public :: FILE_write_associatedCoordinate
  public :: FILE_add_variable
  public :: FILE_def_variable
  public :: FILE_get_shape
  public :: FILE_get_commonInfo
  public :: FILE_get_dataInfo
  public :: FILE_get_all_dataInfo
  public :: FILE_read
  public :: FILE_write
  public :: FILE_get_attribute
  public :: FILE_set_attribute
  public :: FILE_add_associatedVariable
  public :: FILE_enddef
  public :: FILE_flush
  public :: FILE_close
  public :: FILE_close_all
  public :: FILE_make_fname
  public :: FILE_attach_buffer
  public :: FILE_detach_buffer
  public :: FILE_get_CFtunits
  public :: FILE_get_aggregate

  interface FILE_get_commonInfo
     module procedure FILE_get_commonInfo_fid
     module procedure FILE_get_commonInfo_fname
  end interface FILE_get_commonInfo

  interface FILE_get_shape
     module procedure FILE_get_shape_fid
     module procedure FILE_get_shape_fname
  end interface FILE_get_shape

  interface FILE_get_datainfo
     module procedure FILE_get_datainfo_fid
     module procedure FILE_get_datainfo_fname
  end interface FILE_get_datainfo

  interface FILE_get_all_datainfo
     module procedure FILE_get_all_datainfo_fid
     module procedure FILE_get_all_datainfo_fname
  end interface FILE_get_all_datainfo

  interface FILE_put_axis
     module procedure FILE_put_axis_realSP
     module procedure FILE_put_axis_realDP
  end interface FILE_put_axis
  interface FILE_write_axis
     module procedure FILE_write_axis_realSP
     module procedure FILE_write_axis_realDP
  end interface FILE_write_axis
  interface FILE_put_associatedCoordinate
    module procedure FILE_put_associatedCoordinate_realSP_1D
    module procedure FILE_put_associatedCoordinate_realDP_1D
    module procedure FILE_put_associatedCoordinate_realSP_2D
    module procedure FILE_put_associatedCoordinate_realDP_2D
    module procedure FILE_put_associatedCoordinate_realSP_3D
    module procedure FILE_put_associatedCoordinate_realDP_3D
    module procedure FILE_put_associatedCoordinate_realSP_4D
    module procedure FILE_put_associatedCoordinate_realDP_4D
  end interface FILE_put_associatedCoordinate
  interface FILE_write_associatedCoordinate
    module procedure FILE_write_associatedCoordinate_RealSP_1D
    module procedure FILE_write_associatedCoordinate_RealDP_1D
    module procedure FILE_write_associatedCoordinate_RealSP_2D
    module procedure FILE_write_associatedCoordinate_RealDP_2D
    module procedure FILE_write_associatedCoordinate_RealSP_3D
    module procedure FILE_write_associatedCoordinate_RealDP_3D
    module procedure FILE_write_associatedCoordinate_RealSP_4D
    module procedure FILE_write_associatedCoordinate_RealDP_4D
  end interface FILE_write_associatedCoordinate
  interface FILE_add_variable
     module procedure FILE_add_variable_no_time
     module procedure FILE_add_variable_realSP
     module procedure FILE_add_variable_realDP
  end interface FILE_add_variable
  interface FILE_read
    module procedure FILE_read_realSP_1D
    module procedure FILE_read_realDP_1D
    module procedure FILE_read_realSP_2D
    module procedure FILE_read_realDP_2D
    module procedure FILE_read_realSP_3D
    module procedure FILE_read_realDP_3D
    module procedure FILE_read_realSP_4D
    module procedure FILE_read_realDP_4D
    module procedure FILE_read_var_realSP_1D
    module procedure FILE_read_var_realDP_1D
    module procedure FILE_read_var_realSP_2D
    module procedure FILE_read_var_realDP_2D
    module procedure FILE_read_var_realSP_3D
    module procedure FILE_read_var_realDP_3D
    module procedure FILE_read_var_realSP_4D
    module procedure FILE_read_var_realDP_4D
  end interface FILE_read
  interface FILE_write
    module procedure FILE_write_realSP_1D
    module procedure FILE_write_realDP_1D
    module procedure FILE_write_realSP_2D
    module procedure FILE_write_realDP_2D
    module procedure FILE_write_realSP_3D
    module procedure FILE_write_realDP_3D
    module procedure FILE_write_realSP_4D
    module procedure FILE_write_realDP_4D
  end interface FILE_write
  interface FILE_get_attribute
     module procedure FILE_get_attribute_text_fname
     module procedure FILE_get_attribute_int_fname
     module procedure FILE_get_attribute_float_fname
     module procedure FILE_get_attribute_double_fname
     module procedure FILE_get_attribute_text_fid
     module procedure FILE_get_attribute_int_fid
     module procedure FILE_get_attribute_float_fid
     module procedure FILE_get_attribute_double_fid
  end interface FILE_get_attribute
  interface FILE_set_attribute
     module procedure FILE_set_attribute_text
     module procedure FILE_set_attribute_int
     module procedure FILE_set_attribute_float
     module procedure FILE_set_attribute_double
  end interface FILE_set_attribute

  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  logical, public :: FILE_AGGREGATE = .false. !> do parallel I/O through PnetCDF (default setting)

  !-----------------------------------------------------------------------------
  !
  !++ Private procedures
  !
  private :: FILE_get_fid

  !-----------------------------------------------------------------------------
  !
  !++ Private parameters & variables
  !
  type file
     character(len=FILE_HLONG) :: name
     integer                   :: fid
     logical                   :: aggregate
  end type file
  type(file) :: FILE_files(FILE_FILE_MAX)
  integer    :: FILE_nfiles = 0

  type var
  character(len=FILE_HLONG) :: name
  integer                   :: fid
  integer                   :: vid
  end type var
  type(var) :: FILE_vars(FILE_VAR_MAX)
  integer   :: FILE_nvars = 0

  integer                   :: mpi_myrank

  !-----------------------------------------------------------------------------
contains
  !-----------------------------------------------------------------------------
  !> setup
  !-----------------------------------------------------------------------------
  subroutine FILE_setup( &
       myrank )
    use scale_process, only: &
       PRC_set_file_closer
    implicit none

    integer, intent(in) :: myrank

    NAMELIST / PARAM_FILE / &
         FILE_AGGREGATE

    integer :: ierr

       !--- read namelist
    rewind(IO_FID_CONF)
    read(IO_FID_CONF,nml=PARAM_FILE,iostat=ierr)
    if( ierr < 0 ) then !--- missing
       if( IO_L ) write(IO_FID_LOG,*) '*** Not found namelist. Default used.'
    elseif( ierr > 0 ) then !--- fatal error
       write(*,*) 'xxx Not appropriate names in namelist PARAM_FILE. Check!'
       call PRC_abort
    endif
    if( IO_NML ) write(IO_FID_NML,nml=PARAM_FILE)

    mpi_myrank = myrank

    call PRC_set_file_closer( FILE_CLOSE_ALL )

    return
  end subroutine FILE_setup

  !-----------------------------------------------------------------------------
  subroutine FILE_create( &
       basename,    &
       title,       &
       source,      &
       institution, &
       grid_name,   &
       fid,         &
       existed,     &
       rankid,      &
       single,      &
       time_units,  &
       append,      &
       mpi_comm     )
    use mpi, only: &
       MPI_COMM_NULL
    implicit none

    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: title
    character(len=*), intent(in)  :: source
    character(len=*), intent(in)  :: institution
    character(len=*), intent(in)  :: grid_name

    integer,          intent(out) :: fid
    logical,          intent(out) :: existed

    integer,          intent(in), optional :: rankid
    logical,          intent(in), optional :: single
    character(len=*), intent(in), optional :: time_units
    logical,          intent(in), optional :: append
    integer,          intent(in), optional :: mpi_comm !> MPI communicator. If this is set, files are aggregated used by PnetCDF

    character(len=FILE_HMID) :: time_units_
    integer :: rankid_
    logical :: single_
    integer :: mode

    integer :: error
    !---------------------------------------------------------------------------


    if ( present(rankid) ) then
       rankid_ = rankid
    else
       rankid_ = mpi_myrank
    end if

    single_ = .false.
    if ( present(single) ) then
       single_ = single
    endif

    if ( present(time_units) ) then
       time_units_ = time_units
    else
       time_units_ = 'seconds'
    endif

    mode = FILE_FWRITE
    if ( present(append) ) then
       if( append ) mode = FILE_FAPPEND
    endif

    if ( single_ .and. rankid_ /= 0 ) return

    call FILE_get_fid( basename, mode,   & ! [IN]
                       rankid_, single_, & ! [IN]
                       fid, existed,     & ! [OUT]
                       mpi_comm=mpi_comm ) ! [IN]

    if( existed ) return

    !--- append package header to the file
    call FILE_set_attribute( fid, "global", "title"      , title       ) ! [IN]
    call FILE_set_attribute( fid, "global", "source"     , source      ) ! [IN]
    call FILE_set_attribute( fid, "global", "institution", institution ) ! [IN]
    call FILE_set_attribute( fid, "global", "grid_name",   grid_name   ) ! [IN]

    if ( ( .not. present(mpi_comm) ) .or. mpi_comm == MPI_COMM_NULL ) then
       ! for shared-file parallel I/O, skip attributes related to MPI processes
       call FILE_set_attribute( fid, "global", "rankid"  , (/rankid/)  ) ! [IN]
    endif

    call file_set_tunits_c( FILE_files(fid)%fid, & ! [IN]
                            time_units_,         & ! [IN]
                            error                ) ! [OUT]

    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx [FILE_create] failed to set time units'
       call PRC_abort
    endif

    return
  end subroutine FILE_create

  !-----------------------------------------------------------------------------
  subroutine FILE_get_var_num( &
       fid, nvars_limit, &
       nvars             )
    implicit none

    integer, intent(in)  :: fid
    integer, intent(in)  :: nvars_limit
    integer, intent(out) :: nvars

    integer :: error
    !---------------------------------------------------------------------------

    call file_get_nvars_c( FILE_files(fid)%fid, & ! (in)
                           nvars, error         ) ! (out)

    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx [FILE_get_var_num] failed to get varnum. fid = ', fid
       call PRC_abort
    end if

    if ( nvars > nvars_limit ) then
       write(*,*) 'xxx [FILE_get_var_num] number of variables exceeds the requested size.', nvars, nvars_limit
       call PRC_abort
    endif

    return
  end subroutine FILE_get_var_num

  !-----------------------------------------------------------------------------
  subroutine FILE_get_var_name( &
       fid, cvid, &
       varname    )
    implicit none

    integer,          intent(in)  :: fid
    integer,          intent(in)  :: cvid
    character(len=*), intent(out) :: varname

    integer :: error
    !---------------------------------------------------------------------------

    call file_get_varname_c( FILE_files(fid)%fid, cvid, & ! (in)
                             varname, error             ) ! (out)

    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx [FILE_get_var_name] failed to get varname. cvid = ', cvid
       call PRC_abort
    end if

    return
  end subroutine FILE_get_var_name

  !-----------------------------------------------------------------------------
  subroutine FILE_add_associatedvariable( fid, vname, existed )
    integer,           intent(in)  :: fid
    character(len=*),  intent(in)  :: vname
    logical, optional, intent(out) :: existed

    integer :: error

    call file_add_associatedvariable_c( FILE_files(fid)%fid, vname , & ! (in)
                                        error                        ) ! (out)

    if ( present(existed) ) then
       if ( error == FILE_ALREADY_EXISTED_CODE ) then
          existed = .true.
          return
       end if
       existed = .false.
    end if

    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to add associated variable: '//trim(vname)
       call PRC_abort
    end if

    return
  end subroutine FILE_add_associatedvariable

  !-----------------------------------------------------------------------------
  subroutine FILE_set_option( &
       fid,               &
       filetype, key, val )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: filetype
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer :: error

    call file_set_option_c( FILE_files(fid)%fid, filetype, key, val, & ! (in)
                            error                                    ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to set option'
       call PRC_abort
    end if

    return
  end subroutine FILE_set_option

  !-----------------------------------------------------------------------------
  subroutine FILE_open( &
      basename,  &
      fid,       &
      mode,      &
      single,    &
      mpi_comm,  &
      rankid,    &
      postfix    )
    implicit none

    character(len=*), intent( in) :: basename
    integer,          intent(out) :: fid
    integer,          intent( in), optional :: mode
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: mpi_comm
    integer,          intent( in), optional :: rankid
    character(len=*), intent( in), optional :: postfix

    integer :: mode_
    integer :: rankid_
    logical :: existed
    logical :: single_

    single_ = .false.

    if ( present(mode) ) then
       mode_ = mode
    else
       mode_ = FILE_FREAD
    end if

    if ( present(single) ) single_ = single
    if ( present(rankid) ) then
       rankid_ = rankid
    else
       rankid_ = mpi_myrank
    end if

    call FILE_get_fid( basename, mode_, rankid_, single_,   & ! (in)
                       fid, existed,                        & ! (out)
                       mpi_comm = mpi_comm, postfix=postfix ) ! (in)

    return
  end subroutine FILE_open

  !-----------------------------------------------------------------------------
  !> get length of dimension
  !-----------------------------------------------------------------------------
  subroutine FILE_get_dimLength( &
       fid, dimname, &
       len,          &
       error         )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: dimname

    integer, intent(out) :: len

    logical, intent(out), optional :: error

    integer :: ierror

    call file_get_dim_length_c( FILE_files(fid)%fid, dimname, & ! (in)
                                len, ierror                   ) ! (out)
    if ( ierror /= FILE_SUCCESS_CODE .and. ierror /= FILE_ALREADY_EXISTED_CODE ) then
       if ( present(error) ) then
          error = .true.
       else
          write(*,*) 'xxx failed to get dimension length'
          call PRC_abort
       end if
    else
       if ( present(error) ) error = .false.
    end if

    return
  end subroutine FILE_get_dimLength

  !-----------------------------------------------------------------------------
  ! interface FILE_PutAxis
  !-----------------------------------------------------------------------------
  subroutine FILE_put_axis_realSP( &
       fid,               &
       name, desc, units, &
       dim_name, dtype,   &
       val                )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_name
    integer,          intent(in) :: dtype
    real(SP),    intent(in) :: val(:)

    integer :: error
    intrinsic size

    call file_put_axis_c( FILE_files(fid)%fid,                        & ! (in)
         name, desc, units, dim_name, dtype, val, size(val), SP, & ! (in)
         error                                                        ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put axis'
       call PRC_abort
    end if

    return
  end subroutine FILE_put_axis_realSP
  subroutine FILE_put_axis_realDP( &
       fid,               &
       name, desc, units, &
       dim_name, dtype,   &
       val                )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_name
    integer,          intent(in) :: dtype
    real(DP),    intent(in) :: val(:)

    integer :: error
    intrinsic size

    call file_put_axis_c( FILE_files(fid)%fid,                        & ! (in)
         name, desc, units, dim_name, dtype, val, size(val), DP, & ! (in)
         error                                                        ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put axis'
       call PRC_abort
    end if

    return
  end subroutine FILE_put_axis_realDP

  subroutine FILE_def_axis( &
       fid,                       &
       name, desc, units,         &
       dim_name, dtype, dim_size  )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_name
    integer,          intent(in) :: dtype
    integer,          intent(in) :: dim_size

    integer :: error

    call file_def_axis_c( FILE_files(fid)%fid, &
         name, desc, units, dim_name, dtype, dim_size, & ! (in)
         error                                         ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to define axis'
       call PRC_abort
    end if

    return
  end subroutine FILE_def_axis

  !-----------------------------------------------------------------------------
  ! interface FILE_WriteAxis
  !-----------------------------------------------------------------------------
  subroutine FILE_write_axis_realSP( &
       fid,  &
       name, &
       val,  &
       start )
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(SP),    intent(in)           :: val(:)
    integer,          intent(in), optional :: start(:)

    integer :: error
    intrinsic shape

    if ( present(start) ) then
       call file_write_axis_c( FILE_files(fid)%fid, & ! (in)
            name, val, SP, start, shape(val),  & ! (in)
            error                                   ) ! (out)
    else
       call file_write_axis_c( FILE_files(fid)%fid, & ! (in)
            name, val, SP, (/1/), shape(val),  & ! (in)
            error                                   ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to write axis: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_write_axis_realSP
  subroutine FILE_write_axis_realDP( &
       fid,  &
       name, &
       val,  &
       start )
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(DP),    intent(in)           :: val(:)
    integer,          intent(in), optional :: start(:)

    integer :: error
    intrinsic shape

    if ( present(start) ) then
       call file_write_axis_c( FILE_files(fid)%fid, & ! (in)
            name, val, DP, start, shape(val),  & ! (in)
            error                                   ) ! (out)
    else
       call file_write_axis_c( FILE_files(fid)%fid, & ! (in)
            name, val, DP, (/1/), shape(val),  & ! (in)
            error                                   ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to write axis: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_write_axis_realDP

  !-----------------------------------------------------------------------------
  ! interface FILE_put_associatedCoordinate
  !-----------------------------------------------------------------------------
  subroutine FILE_put_associatedCoordinate_realSP_1D( &
       fid,                &
       name, desc,  units, &
       dim_names, dtype,   &
       val                 )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(SP),    intent(in) :: val(:)

    integer :: error
    intrinsic size

    call file_put_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, SP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_put_associatedCoordinate_realSP_1D
  subroutine FILE_put_associatedCoordinate_realDP_1D( &
       fid,                &
       name, desc,  units, &
       dim_names, dtype,   &
       val                 )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(DP),    intent(in) :: val(:)

    integer :: error
    intrinsic size

    call file_put_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, DP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_put_associatedCoordinate_realDP_1D
  subroutine FILE_put_associatedCoordinate_realSP_2D( &
       fid,                &
       name, desc,  units, &
       dim_names, dtype,   &
       val                 )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(SP),    intent(in) :: val(:,:)

    integer :: error
    intrinsic size

    call file_put_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, SP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_put_associatedCoordinate_realSP_2D
  subroutine FILE_put_associatedCoordinate_realDP_2D( &
       fid,                &
       name, desc,  units, &
       dim_names, dtype,   &
       val                 )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(DP),    intent(in) :: val(:,:)

    integer :: error
    intrinsic size

    call file_put_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, DP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_put_associatedCoordinate_realDP_2D
  subroutine FILE_put_associatedCoordinate_realSP_3D( &
       fid,                &
       name, desc,  units, &
       dim_names, dtype,   &
       val                 )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(SP),    intent(in) :: val(:,:,:)

    integer :: error
    intrinsic size

    call file_put_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, SP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_put_associatedCoordinate_realSP_3D
  subroutine FILE_put_associatedCoordinate_realDP_3D( &
       fid,                &
       name, desc,  units, &
       dim_names, dtype,   &
       val                 )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(DP),    intent(in) :: val(:,:,:)

    integer :: error
    intrinsic size

    call file_put_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, DP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_put_associatedCoordinate_realDP_3D
  subroutine FILE_put_associatedCoordinate_realSP_4D( &
       fid,                &
       name, desc,  units, &
       dim_names, dtype,   &
       val                 )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(SP),    intent(in) :: val(:,:,:,:)

    integer :: error
    intrinsic size

    call file_put_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, SP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_put_associatedCoordinate_realSP_4D
  subroutine FILE_put_associatedCoordinate_realDP_4D( &
       fid,                &
       name, desc,  units, &
       dim_names, dtype,   &
       val                 )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(DP),    intent(in) :: val(:,:,:,:)

    integer :: error
    intrinsic size

    call file_put_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, DP,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_put_associatedCoordinate_realDP_4D

  subroutine FILE_def_associatedCoordinate( &
       fid,               &
       name, desc, units, &
       dim_names, dtype   )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype

    integer :: error
    intrinsic size

    call file_def_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_def_associatedCoordinate

  !-----------------------------------------------------------------------------
  ! interface FILE_write_associatedCoordinate
  !-----------------------------------------------------------------------------
  subroutine FILE_write_associatedCoordinate_realSP_1D( &
       fid,          &
       name,         &
       val,          &
       start, count, &
       ndims         )
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(SP),    intent(in)           :: val(:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer :: error
    intrinsic shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, SP,                                     & ! (in)
            ndims, start, count,                                    & ! (in)
            error                                                   ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, SP,                                     & ! (in)
            1, start, shape(val),                              & ! (in)
            error                                                   ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, SP,                                     & ! (in)
            1, (/1/), shape(val),         & ! (in)
            error                                                   ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_write_associatedCoordinate_realSP_1D
  subroutine FILE_write_associatedCoordinate_realDP_1D( &
       fid,          &
       name,         &
       val,          &
       start, count, &
       ndims         )
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(DP),    intent(in)           :: val(:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer :: error
    intrinsic shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, DP,                                     & ! (in)
            ndims, start, count,                                    & ! (in)
            error                                                   ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, DP,                                     & ! (in)
            1, start, shape(val),                              & ! (in)
            error                                                   ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, DP,                                     & ! (in)
            1, (/1/), shape(val),         & ! (in)
            error                                                   ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_write_associatedCoordinate_realDP_1D
  subroutine FILE_write_associatedCoordinate_realSP_2D( &
       fid,          &
       name,         &
       val,          &
       start, count, &
       ndims         )
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(SP),    intent(in)           :: val(:,:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer :: error
    intrinsic shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, SP,                                     & ! (in)
            ndims, start, count,                                    & ! (in)
            error                                                   ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, SP,                                     & ! (in)
            2, start, shape(val),                              & ! (in)
            error                                                   ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, SP,                                     & ! (in)
            2, (/1,1/), shape(val),         & ! (in)
            error                                                   ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_write_associatedCoordinate_realSP_2D
  subroutine FILE_write_associatedCoordinate_realDP_2D( &
       fid,          &
       name,         &
       val,          &
       start, count, &
       ndims         )
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(DP),    intent(in)           :: val(:,:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer :: error
    intrinsic shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, DP,                                     & ! (in)
            ndims, start, count,                                    & ! (in)
            error                                                   ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, DP,                                     & ! (in)
            2, start, shape(val),                              & ! (in)
            error                                                   ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, DP,                                     & ! (in)
            2, (/1,1/), shape(val),         & ! (in)
            error                                                   ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_write_associatedCoordinate_realDP_2D
  subroutine FILE_write_associatedCoordinate_realSP_3D( &
       fid,          &
       name,         &
       val,          &
       start, count, &
       ndims         )
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(SP),    intent(in)           :: val(:,:,:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer :: error
    intrinsic shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, SP,                                     & ! (in)
            ndims, start, count,                                    & ! (in)
            error                                                   ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, SP,                                     & ! (in)
            3, start, shape(val),                              & ! (in)
            error                                                   ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, SP,                                     & ! (in)
            3, (/1,1,1/), shape(val),         & ! (in)
            error                                                   ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_write_associatedCoordinate_realSP_3D
  subroutine FILE_write_associatedCoordinate_realDP_3D( &
       fid,          &
       name,         &
       val,          &
       start, count, &
       ndims         )
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(DP),    intent(in)           :: val(:,:,:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer :: error
    intrinsic shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, DP,                                     & ! (in)
            ndims, start, count,                                    & ! (in)
            error                                                   ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, DP,                                     & ! (in)
            3, start, shape(val),                              & ! (in)
            error                                                   ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, DP,                                     & ! (in)
            3, (/1,1,1/), shape(val),         & ! (in)
            error                                                   ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_write_associatedCoordinate_realDP_3D
  subroutine FILE_write_associatedCoordinate_realSP_4D( &
       fid,          &
       name,         &
       val,          &
       start, count, &
       ndims         )
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(SP),    intent(in)           :: val(:,:,:,:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer :: error
    intrinsic shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, SP,                                     & ! (in)
            ndims, start, count,                                    & ! (in)
            error                                                   ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, SP,                                     & ! (in)
            4, start, shape(val),                              & ! (in)
            error                                                   ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, SP,                                     & ! (in)
            4, (/1,1,1,1/), shape(val),         & ! (in)
            error                                                   ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_write_associatedCoordinate_realSP_4D
  subroutine FILE_write_associatedCoordinate_realDP_4D( &
       fid,          &
       name,         &
       val,          &
       start, count, &
       ndims         )
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(DP),    intent(in)           :: val(:,:,:,:)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer :: error
    intrinsic shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, DP,                                     & ! (in)
            ndims, start, count,                                    & ! (in)
            error                                                   ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, DP,                                     & ! (in)
            4, start, shape(val),                              & ! (in)
            error                                                   ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, DP,                                     & ! (in)
            4, (/1,1,1,1/), shape(val),         & ! (in)
            error                                                   ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_write_associatedCoordinate_realDP_4D

  !-----------------------------------------------------------------------------
  ! interface FILE_add_variable
  !-----------------------------------------------------------------------------
  subroutine FILE_add_variable_no_time( &
       fid,                  &
       varname, desc, units, &
       dims, dtype,          &
       vid,                  &
       time_avg              )
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    integer,          intent(out) :: vid
    logical,          intent( in), optional :: time_avg

    call FILE_add_variable_realDP( fid,              & ! (in)
         varname, desc, units, dims, dtype, -1.0_DP, & ! (in)
         vid,                                        & ! (out)
         time_avg = time_avg                         ) ! (in)

    return
  end subroutine FILE_add_variable_no_time

  !-----------------------------------------------------------------------------
  subroutine FILE_add_variable_realSP( &
       fid,                  &
       varname, desc, units, &
       dims, dtype,          &
       time_int,             &
       vid,                  &
       time_avg              )
    implicit none
    integer,          intent(in)  :: fid
    character(len=*), intent(in)  :: varname
    character(len=*), intent(in)  :: desc
    character(len=*), intent(in)  :: units
    character(len=*), intent(in)  :: dims(:)
    integer,          intent(in)  :: dtype
    real(SP),    intent(in)  :: time_int

    integer,          intent(out) :: vid

    logical,          intent(in), optional :: time_avg

    real(DP) :: tint8
    integer  :: cvid
    integer  :: ndims
    integer  :: itavg
    integer  :: error
    integer  :: n

    intrinsic size
    !---------------------------------------------------------------------------

    vid = -1
    do n = 1, FILE_nvars
       if ( FILE_vars(n)%fid == fid .and. FILE_vars(n)%name == varname ) then
          vid = FILE_vars(n)%vid
          exit
       endif
    enddo

    if ( vid < 0 ) then ! variable registration

       tint8 = real(time_int,DP)
       ndims = size(dims)
       itavg = 0

       if ( present(time_avg) ) then
          if( time_avg ) itavg = 1
       endif

       call file_add_variable_c( cvid,                              & ! [OUT]
                                 FILE_files(fid)%fid,              & ! [IN]
                                 varname, desc, units,             & ! [IN]
                                 dims, ndims, dtype, tint8, itavg, & ! [IN]
                                 error                             ) ! [OUT]

       if ( error /= FILE_SUCCESS_CODE ) then
          write(*,*) 'xxx failed to add variable: '//trim(varname)
          call PRC_abort
       endif

       FILE_nvars = FILE_nvars + 1
       vid = FILE_nvars
       FILE_vars(vid)%name = varname
       FILE_vars(vid)%vid  = cvid
       FILE_vars(vid)%fid  = fid

       if (IO_L) write(IO_FID_LOG,'(A,I3.3,A,I4.4,2A)') &
       '###### FILE variable registration : NO.', fid, ', vid = ', vid, ', name = ', trim(varname)
    endif

    return
  end subroutine FILE_add_variable_realSP

  !-----------------------------------------------------------------------------
  subroutine FILE_add_variable_realDP( &
       fid,                  &
       varname, desc, units, &
       dims, dtype,          &
       time_int,             &
       vid,                  &
       time_avg              )
    implicit none
    integer,          intent(in)  :: fid
    character(len=*), intent(in)  :: varname
    character(len=*), intent(in)  :: desc
    character(len=*), intent(in)  :: units
    character(len=*), intent(in)  :: dims(:)
    integer,          intent(in)  :: dtype
    real(DP),    intent(in)  :: time_int

    integer,          intent(out) :: vid

    logical,          intent(in), optional :: time_avg

    real(DP) :: tint8
    integer  :: cvid
    integer  :: ndims
    integer  :: itavg
    integer  :: error
    integer  :: n

    intrinsic size
    !---------------------------------------------------------------------------

    vid = -1
    do n = 1, FILE_nvars
       if ( FILE_vars(n)%fid == fid .and. FILE_vars(n)%name == varname ) then
          vid = FILE_vars(n)%vid
          exit
       endif
    enddo

    if ( vid < 0 ) then ! variable registration

       tint8 = real(time_int,DP)
       ndims = size(dims)
       itavg = 0

       if ( present(time_avg) ) then
          if( time_avg ) itavg = 1
       endif

       call file_add_variable_c( cvid,                              & ! [OUT]
                                 FILE_files(fid)%fid,              & ! [IN]
                                 varname, desc, units,             & ! [IN]
                                 dims, ndims, dtype, tint8, itavg, & ! [IN]
                                 error                             ) ! [OUT]

       if ( error /= FILE_SUCCESS_CODE ) then
          write(*,*) 'xxx failed to add variable: '//trim(varname)
          call PRC_abort
       endif

       FILE_nvars = FILE_nvars + 1
       vid = FILE_nvars
       FILE_vars(vid)%name = varname
       FILE_vars(vid)%vid  = cvid
       FILE_vars(vid)%fid  = fid

       if (IO_L) write(IO_FID_LOG,'(A,I3.3,A,I4.4,2A)') &
       '###### FILE variable registration : NO.', fid, ', vid = ', vid, ', name = ', trim(varname)
    endif

    return
  end subroutine FILE_add_variable_realDP

  subroutine FILE_def_variable( &
       fid,                  &
       varname, desc, units, &
       ndims, dims,          &
       dtype,                &
       vid,                  &
       time_int, time_avg,   &
       existed               )
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    integer,          intent( in) :: ndims
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    integer,          intent(out) :: vid
    real(DP),         intent( in), optional :: time_int
    logical,          intent( in), optional :: time_avg
    logical,          intent(out), optional :: existed

    real(DP) :: tint_
    integer  :: itavg
    integer  :: cvid
    integer  :: error
    integer  :: n

    !---------------------------------------------------------------------------

    vid = -1
    do n = 1, FILE_nvars
       if ( FILE_vars(n)%fid == fid .and. FILE_vars(n)%name == varname ) then
          vid = n
       end if
    enddo

    if ( vid < 0 ) then ! variable registration

       if ( present(time_int) ) then
          tint_ = time_int
       else
          tint_ = -1.0_DP
       endif

       if ( present(time_avg) ) then
          if ( time_avg ) then
             itavg = 1
          else
             itavg = 0
          end if
       else
          itavg = 0
       end if

       call file_add_variable_c( cvid,                & ! (out)
            FILE_files(fid)%fid,                      & ! (in)
            varname, desc, units, dims, ndims, dtype, & ! (in)
            tint_, itavg,                             & ! (in)
            error                                     ) ! (out)
       if ( error /= FILE_SUCCESS_CODE ) then
          write(*,*) 'xxx failed to add variable: '//trim(varname)
          call PRC_abort
       end if

       FILE_nvars = FILE_nvars + 1
       vid = FILE_nvars
       FILE_vars(vid)%name = varname
       FILE_vars(vid)%vid  = cvid
       FILE_vars(vid)%fid  = fid

       if (IO_L) write(IO_FID_LOG,'(A,I3.3,A,I4.4,2A)') &
       '###### FILE variable registration : NO.', fid, ', vid = ', vid, ', name = ', trim(varname)

       if ( present(existed) ) existed = .false.
    else
       if ( present(existed) ) existed = .true.
    endif

    return
  end subroutine FILE_def_variable

  !-----------------------------------------------------------------------------
  ! FILE_Get_Attribute
  !-----------------------------------------------------------------------------
  subroutine FILE_get_attribute_text_fid( &
       fid,        &
       vname, key, &
       val,        &
       existed     )
    integer,          intent(in ) :: fid
    character(len=*), intent(in ) :: vname
    character(len=*), intent(in ) :: key
    character(len=*), intent(out) :: val

    logical, intent(out), optional :: existed

    integer :: error

    call file_get_attribute_text_c( &
         FILE_files(fid)%fid, vname, & ! (in)
         key,                        & ! (in)
         val, error                  ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(existed) ) then
          existed = .false.
       else
          write(*,*) 'xxx failed to get text attribute for '//trim(vname)//': '//trim(key)
          call PRC_abort
       end if
    else
       if ( present(existed) ) existed = .true.
    end if

    return
  end subroutine FILE_get_attribute_text_fid
  subroutine FILE_get_attribute_text_fname( &
      basename, vname, key,     &
      val,                      &
      single, mpi_comm, rankid, &
      existed                   )
    implicit none

    character(len=*), intent(in) :: basename
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key

    character(len=*), intent(out) :: val

    logical, intent(in), optional :: single
    integer, intent(in), optional :: mpi_comm
    integer, intent(in), optional :: rankid

    logical, intent(out), optional :: existed
    integer :: fid

    call FILE_open( basename, & ! (in)
         fid,                 & ! (out)
         single = single,     & ! (in)
         mpi_comm = mpi_comm, & ! (in)
         rankid = rankid      ) ! (in)

    call FILE_get_attribute_text_fid( &
         fid, vname, key, & ! (in)
         val,             & ! (out)
         existed          ) ! (out)

    return
  end subroutine FILE_get_attribute_text_fname

  !-----------------------------------------------------------------------------
  subroutine FILE_get_attribute_int_fid( &
       fid, vname, key, &
       val,             &
       existed          )
    integer,          intent(in ) :: fid
    character(len=*), intent(in ) :: vname
    character(len=*), intent(in ) :: key
    integer,          intent(out) :: val(:)

    logical, intent(out), optional :: existed

    integer :: error

    intrinsic size

    call file_get_attribute_int_c( &
         FILE_files(fid)%fid, vname, & ! (in)
         key, size(val),             & ! (in)
         val, error                  ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(existed) ) then
          existed = .false.
       else
          write(*,*) 'xxx failed to get integer attribute for '//trim(vname)//': '//trim(key)
          call PRC_abort
       end if
    else
       if ( present(existed) ) existed = .true.
    end if

    return
  end subroutine FILE_get_attribute_int_fid
  subroutine FILE_get_attribute_int_fname( &
      basename, vname, key,     &
      val,                      &
      single, mpi_comm, rankid, &
      existed                   )
    implicit none

    character(len=*), intent(in) :: basename
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key

    integer, intent(out) :: val(:)

    logical, intent(in), optional :: single
    integer, intent(in), optional :: mpi_comm
    integer, intent(in), optional :: rankid

    logical, intent(out), optional :: existed

    integer :: fid

    call FILE_open( basename, & ! (in)
         fid,                 & ! (out)
         single = single,     & ! (in)
         mpi_comm = mpi_comm, & ! (in)
         rankid = rankid      ) ! (in)

    call FILE_get_attribute_int_fid( &
         fid, vname, key, & ! (in)
         val,             & ! (out)
         existed          ) ! (out)

    return
  end subroutine FILE_get_attribute_int_fname
  !-----------------------------------------------------------------------------

  subroutine FILE_get_attribute_float_fid( &
       fid, vname, key, &
       val,             &
       existed          )
    integer,          intent(in ) :: fid
    character(len=*), intent(in ) :: vname
    character(len=*), intent(in ) :: key
    real(SP),    intent(out) :: val(:)

    logical, intent(out), optional :: existed

    integer :: error

    intrinsic size

    call file_get_attribute_float_c( &
         FILE_files(fid)%fid, vname, & ! (in)
         key, size(val),             & ! (in)
         val, error                  ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(existed) ) then
          existed = .false.
       else
          write(*,*) 'xxx failed to get float attribute for '//trim(vname)//': '//trim(key)
          call PRC_abort
       end if
    else
       if ( present(existed) ) existed = .true.
    end if

    return
  end subroutine FILE_get_attribute_float_fid
  subroutine FILE_get_attribute_float_fname( &
      basename, vname, key,     &
      val,                      &
      single, mpi_comm, rankid, &
      existed                   )
    implicit none

    character(len=*), intent(in) :: basename
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key

    real(SP), intent(out) :: val(:)

    logical, intent(in), optional :: single
    integer, intent(in), optional :: mpi_comm
    integer, intent(in), optional :: rankid

    logical, intent(out), optional :: existed

    integer :: fid

    call FILE_open( basename, & ! (in)
         fid,                 & ! (out)
         single = single,     & ! (in)
         mpi_comm = mpi_comm, & ! (in)
         rankid = rankid      ) ! (in)

    call FILE_get_attribute_float_fid( &
         fid, vname, key, & ! (in)
         val,             & ! (out)
         existed          ) ! (out)

    return
  end subroutine FILE_get_attribute_float_fname
  subroutine FILE_get_attribute_double_fid( &
       fid, vname, key, &
       val,             &
       existed          )
    integer,          intent(in ) :: fid
    character(len=*), intent(in ) :: vname
    character(len=*), intent(in ) :: key
    real(DP),    intent(out) :: val(:)

    logical, intent(out), optional :: existed

    integer :: error

    intrinsic size

    call file_get_attribute_double_c( &
         FILE_files(fid)%fid, vname, & ! (in)
         key, size(val),             & ! (in)
         val, error                  ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(existed) ) then
          existed = .false.
       else
          write(*,*) 'xxx failed to get double attribute for '//trim(vname)//': '//trim(key)
          call PRC_abort
       end if
    else
       if ( present(existed) ) existed = .true.
    end if

    return
  end subroutine FILE_get_attribute_double_fid
  subroutine FILE_get_attribute_double_fname( &
      basename, vname, key,     &
      val,                      &
      single, mpi_comm, rankid, &
      existed                   )
    implicit none

    character(len=*), intent(in) :: basename
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key

    real(DP), intent(out) :: val(:)

    logical, intent(in), optional :: single
    integer, intent(in), optional :: mpi_comm
    integer, intent(in), optional :: rankid

    logical, intent(out), optional :: existed

    integer :: fid

    call FILE_open( basename, & ! (in)
         fid,                 & ! (out)
         single = single,     & ! (in)
         mpi_comm = mpi_comm, & ! (in)
         rankid = rankid      ) ! (in)

    call FILE_get_attribute_double_fid( &
         fid, vname, key, & ! (in)
         val,             & ! (out)
         existed          ) ! (out)

    return
  end subroutine FILE_get_attribute_double_fname

  !-----------------------------------------------------------------------------
  ! FILE_set_attribute
  !-----------------------------------------------------------------------------
  subroutine FILE_set_attribute_text( &
     fid, vname, &
     key, val    )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer :: error

    call file_set_attribute_text_c( &
         FILE_files(fid)%fid, vname, & ! (in)
         key, val,                   & ! (in)
         error                       ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to set text attribute for '//trim(vname)//': '//trim(key)
       call PRC_abort
    end if

    return
  end subroutine FILE_set_attribute_text

  !-----------------------------------------------------------------------------
  subroutine FILE_set_attribute_int( &
     fid, vname, &
     key, val    )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key
    integer,          intent(in) :: val(:)

    integer :: error

    intrinsic size

    call file_set_attribute_int_c( &
         FILE_files(fid)%fid, vname, & ! (in)
         key, val(:), size(val(:)),  & ! (in)
         error                       ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to set integer attribute for '//trim(vname)//': '//trim(key)
       call PRC_abort
    end if

    return
  end subroutine FILE_set_attribute_int

  !-----------------------------------------------------------------------------
  subroutine FILE_set_attribute_float( &
     fid, vname, &
     key, val    )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key
    real(SP),    intent(in) :: val(:)

    integer :: error

    intrinsic size

    call file_set_attribute_float_c( &
         FILE_files(fid)%fid, vname, & ! (in)
         key, val(:), size(val(:)),  & ! (in)
         error                       ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to set float attribute for '//trim(vname)//': '//trim(key)
       call PRC_abort
    end if

    return
  end subroutine FILE_set_attribute_float
  !-----------------------------------------------------------------------------
  subroutine FILE_set_attribute_double( &
     fid, vname, &
     key, val    )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key
    real(DP),    intent(in) :: val(:)

    integer :: error

    intrinsic size

    call file_set_attribute_double_c( &
         FILE_files(fid)%fid, vname, & ! (in)
         key, val(:), size(val(:)),  & ! (in)
         error                       ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to set double attribute for '//trim(vname)//': '//trim(key)
       call PRC_abort
    end if

    return
  end subroutine FILE_set_attribute_double
  !-----------------------------------------------------------------------------
  ! FILE_get_shape
  !-----------------------------------------------------------------------------
  subroutine FILE_get_shape_fname( &
      basename, varname, &
      dims,              &
      rankid, single,    &
      error              )
    implicit none

    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent(out)           :: dims(:)
    integer,          intent( in), optional :: rankid
    logical,          intent( in), optional :: single
    logical,          intent(out), optional :: error

    integer :: fid
    !---------------------------------------------------------------------------

    !--- search/register file
    call FILE_open( basename,                    & ! (in)
                    fid,                         & ! (out)
                    rankid=rankid, single=single ) ! (in)

    call FILE_get_shape_fid( fid, varname, & ! (in)
                             dims(:),      & ! (out)
                             error = error ) ! (out)

    return
  end subroutine FILE_get_shape_fname

  subroutine FILE_get_shape_fid( &
       fid, varname, &
       dims,         &
       error         )
    implicit none
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname

    integer,          intent(out)           :: dims(:)

    logical,          intent(out), optional :: error

    type(datainfo) :: dinfo
    integer :: ierror
    integer :: n

    logical :: suppress

    intrinsic size
    !---------------------------------------------------------------------------

    if ( present(error) ) then
       suppress = .true.
    else
       suppress = .false.
    end if

    !--- get data information
    call file_get_datainfo_c( dinfo,   & ! (out)
         FILE_files(fid)%fid, varname, & ! (in)
         1, suppress,                  & ! (in)
         ierror                        ) ! (out)

    !--- verify
    if ( ierror /= FILE_SUCCESS_CODE ) then
       if ( present(error) ) then
          error = .true.
          return
       else
          write(*,*) 'xxx failed to get data information :'//trim(varname)
          call PRC_abort
       end if
    end if

    if ( dinfo%rank /= size(dims) ) then
       write(*,*) 'xxx rank is different, ', size(dims), dinfo%rank
       call PRC_abort
    end if
    do n = 1, size(dims)
       dims(n) = dinfo%dim_size(n)
    end do

    if ( present(error) ) error = .false.

    return
  end subroutine FILE_get_shape_fid

  !-----------------------------------------------------------------------------
  ! FILE_get_commonInfo
  !-----------------------------------------------------------------------------
  subroutine FILE_get_commonInfo_fname( &
       basename,    &
       rankid,      &
       nvars_limit, &
       title,       &
       source,      &
       institution, &
       grid_name,   &
       nvars,       &
       varname      )
    implicit none

    character(len=*),           intent(in)  :: basename
    integer,                    intent(in)  :: rankid
    integer,                    intent(in)  :: nvars_limit
    character(len=FILE_HMID),   intent(out) :: title                ! title of the file
    character(len=FILE_HMID),   intent(out) :: source               ! for file header
    character(len=FILE_HMID),   intent(out) :: institution          ! for file header
    character(len=FILE_HSHORT), intent(out) :: grid_name            ! for file header
    integer,                    intent(out) :: nvars                ! number of variables
    character(len=FILE_HSHORT), intent(out) :: varname(nvars_limit) ! name of variables

    integer :: fid
    !---------------------------------------------------------------------------

    call FILE_open( basename,             & ! [IN]
                    fid,                  & ! [OUT]
                    rankid=rankid         ) ! [IN]

    call FILE_get_commonInfo_fid( fid,         & ! [IN]
                                  nvars_limit, & ! [IN]
                                  title,       & ! [OUT]
                                  source,      & ! [OUT]
                                  institution, & ! [OUT]
                                  grid_name,   & ! [OUT]
                                  nvars,       & ! [OUT]
                                  varname(:)   ) ! [OUT]

    return
  end subroutine FILE_get_commonInfo_fname

  subroutine FILE_get_commonInfo_fid( &
       fid,         &
       nvars_limit, &
       title,       &
       source,      &
       institution, &
       grid_name,   &
       nvars,       &
       varname      )
    implicit none

    integer,                    intent(in)  :: fid
    integer,                    intent(in)  :: nvars_limit
    character(len=FILE_HMID),   intent(out) :: title                ! title of the file
    character(len=FILE_HMID),   intent(out) :: source               ! for file header
    character(len=FILE_HMID),   intent(out) :: institution          ! for file header
    character(len=FILE_HSHORT), intent(out) :: grid_name            ! for file header
    integer,                    intent(out) :: nvars                ! number of variables
    character(len=FILE_HSHORT), intent(out) :: varname(nvars_limit) ! name of variables

    integer :: v
    !---------------------------------------------------------------------------

    call FILE_get_attribute( fid, 'global', 'title',       title       )
    call FILE_get_attribute( fid, 'global', 'source',      source      )
    call FILE_get_attribute( fid, 'global', 'institution', institution )
    call FILE_get_attribute( fid, 'global', 'grid_name',   grid_name   )

    call FILE_get_var_num( fid, nvars_limit, nvars )

    do v = 1, nvars
       call FILE_get_var_name( fid, v, varname(v) )
    enddo

    return
  end subroutine FILE_get_commonInfo_fid

  !-----------------------------------------------------------------------------
  ! FILE_get_dataInfo
  !-----------------------------------------------------------------------------
  subroutine FILE_get_dataInfo_fname( &
       basename, varname,               &
       rankid, istep, single,           &
       description, units,              &
       datatype,                        &
       dim_rank, dim_name, dim_size,    &
       time_start, time_end, time_units )
    implicit none

    character(len=*),           intent(in)  :: basename
    character(len=*),           intent(in)  :: varname

    integer,                    intent(in),  optional :: rankid
    integer,                    intent(in),  optional :: istep
    logical,                    intent(in),  optional :: single
    character(len=FILE_HMID),   intent(out), optional :: description
    character(len=FILE_HSHORT), intent(out), optional :: units
    integer,                    intent(out), optional :: datatype
    integer,                    intent(out), optional :: dim_rank
    character(len=FILE_HSHORT), intent(out), optional :: dim_name(:)
    integer,                    intent(out), optional :: dim_size(:)
    real(DP),                   intent(out), optional :: time_start
    real(DP),                   intent(out), optional :: time_end
    character(len=FILE_HMID),   intent(out), optional :: time_units

    logical :: single_
    integer :: fid
    !---------------------------------------------------------------------------

    if ( present(single) ) then
       single_ = single
    else
       single_ = .false.
    endif

    !--- search/register file
    call FILE_open( basename,                     & ! [IN]
                    fid,                          & ! [OUT]
                    rankid=rankid, single=single_ ) ! [IN]

    call FILE_get_dataInfo_fid( fid,         & ! [IN]
                                varname,     & ! [IN]
                                istep,       & ! [IN] , optional
                                description, & ! [OUT], optional
                                units,       & ! [OUT], optional
                                datatype,    & ! [OUT], optional
                                dim_rank,    & ! [OUT], optional
                                dim_name,    & ! [OUT], optional
                                dim_size,    & ! [OUT], optional
                                time_start,  & ! [OUT], optional
                                time_end,    & ! [OUT], optional
                                time_units   ) ! [OUT], optional

    return
  end subroutine FILE_get_dataInfo_fname

  subroutine FILE_get_dataInfo_fid( &
       fid, varname,                    &
       istep,                           &
       description, units,              &
       datatype,                        &
       dim_rank, dim_name, dim_size,    &
       time_start, time_end, time_units )
    implicit none

    integer,          intent(in)  :: fid
    character(len=*), intent(in)  :: varname

    integer,                    intent(in),  optional :: istep
    character(len=FILE_HMID),   intent(out), optional :: description
    character(len=FILE_HSHORT), intent(out), optional :: units
    integer,                    intent(out), optional :: datatype
    integer,                    intent(out), optional :: dim_rank
    character(len=FILE_HSHORT), intent(out), optional :: dim_name(:)
    integer,                    intent(out), optional :: dim_size(:)
    real(DP),                   intent(out), optional :: time_start
    real(DP),                   intent(out), optional :: time_end
    character(len=FILE_HMID),   intent(out), optional :: time_units

    type(datainfo) :: dinfo

    integer  :: istep_
    real(DP) :: time(1)
    integer  :: ndim, idim
    integer  :: error

    intrinsic size
    !---------------------------------------------------------------------------

    if ( present(istep) ) then
       istep_ = istep
    else
       istep_ = 1
    end if


    !--- get data information
    call file_get_datainfo_c( dinfo,               & ! [OUT]
                              FILE_files(fid)%fid, & ! [IN]
                              varname,             & ! [IN]
                              istep_,              & ! [IN]
                              .false.,             & ! [IN]
                              error                ) ! [OUT]

    !--- verify and exit
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx data info not found'
       call PRC_abort
    endif

    if( present(description) ) description = dinfo%description
    if( present(units)       ) units       = dinfo%units
    if( present(datatype)    ) datatype    = dinfo%datatype
    if( present(dim_rank)    ) dim_rank    = dinfo%rank

    if ( present(dim_name) ) then
       ndim = min( dinfo%rank, size(dim_name) ) ! limit dimension rank
       do idim = 1, ndim
          dim_name(idim) = dinfo%dim_name(idim)
       enddo
    endif

    if ( present(dim_size) ) then
       ndim = min( dinfo%rank, size(dim_size) ) ! limit dimension rank
       do idim = 1, ndim
          dim_size(idim) = dinfo%dim_size(idim)
       enddo
    endif

    if ( present(time_units)  ) then
       if ( dinfo%time_units == "" ) then
          call FILE_get_attribute( fid, "global", "time_units", time_units )
       else
          time_units = dinfo%time_units
       endif
    endif

    if ( present(time_start)  ) then
       if ( dinfo%time_units == "" ) then
          call FILE_get_Attribute( fid, "global", "time_start", time )
          time_start = time(1)
       else
          time_start = dinfo%time_start
       endif
    endif

    if ( present(time_end)  ) then
       if ( dinfo%time_units == "" ) then
          call FILE_get_Attribute( fid, "global", "time_start", time )
          time_end = time(1)
       else
          time_end = dinfo%time_end
       end if
    endif

    return
  end subroutine FILE_get_dataInfo_fid

  !-----------------------------------------------------------------------------
  ! FILE_get_data_all_dataInfo
  !-----------------------------------------------------------------------------
  subroutine FILE_get_all_dataInfo_fname( &
       step_limit, dim_limit,            &
       basename, varname,                &
       step_nmax,                        &
       description, units, datatype,     &
       dim_rank, dim_name, dim_size,     &
       time_start, time_end, time_units, &
       rankid, single                    )
    implicit none

    integer,                    intent(in)  :: step_limit
    integer,                    intent(in)  :: dim_limit
    character(len=*),           intent(in)  :: basename
    character(len=*),           intent(in)  :: varname
    integer,                    intent(out) :: step_nmax
    character(len=FILE_HMID),   intent(out) :: description
    character(len=FILE_HSHORT), intent(out) :: units
    integer,                    intent(out) :: datatype
    integer,                    intent(out) :: dim_rank
    character(len=FILE_HSHORT), intent(out) :: dim_name  (dim_limit)
    integer,                    intent(out) :: dim_size  (dim_limit)
    real(DP),                   intent(out) :: time_start(step_limit)
    real(DP),                   intent(out) :: time_end  (step_limit)
    character(len=FILE_HMID),   intent(out) :: time_units

    integer,                    intent(in), optional :: rankid
    logical,                    intent(in), optional :: single

    integer :: fid
    logical :: single_
    !---------------------------------------------------------------------------

    if ( present(single) ) then
       single_ = single
    else
       single_ = .false.
    endif

    !--- search/register file
    call FILE_open( basename,                     & ! [IN]
                    fid,                          & ! [OUT]
                    rankid=rankid, single=single_ ) ! [IN]

    call FILE_get_all_datainfo_fid( step_limit, dim_limit,           & ! [IN]
                                    fid, varname,                    & ! [IN]
                                    step_nmax,                       & ! [OUT]
                                    description, units, datatype,    & ! [OUT]
                                    dim_rank, dim_name, dim_size,    & ! [OUT]
                                    time_start, time_end, time_units ) ! [OUT]

    return
  end subroutine FILE_get_all_dataInfo_fname

  subroutine FILE_get_all_dataInfo_fid( &
       step_limit, dim_limit,           &
       fid, varname,                    &
       step_nmax,                       &
       description, units, datatype,    &
       dim_rank, dim_name, dim_size,    &
       time_start, time_end, time_units )
    implicit none

    integer,                    intent(in)  :: step_limit
    integer,                    intent(in)  :: dim_limit
    integer,                    intent(in)  :: fid
    character(len=*),           intent(in)  :: varname
    integer,                    intent(out) :: step_nmax
    character(len=FILE_HMID),   intent(out) :: description
    character(len=FILE_HSHORT), intent(out) :: units
    integer,                    intent(out) :: datatype
    integer,                    intent(out) :: dim_rank
    character(len=FILE_HSHORT), intent(out) :: dim_name  (dim_limit)
    integer,                    intent(out) :: dim_size  (dim_limit)
    real(DP),                   intent(out) :: time_start(step_limit)
    real(DP),                   intent(out) :: time_end  (step_limit)
    character(len=FILE_HMID),   intent(out) :: time_units

    type(datainfo) :: dinfo

    real(DP) :: time(1)
    integer  :: ndim, idim
    integer  :: error

    integer  :: istep
    !---------------------------------------------------------------------------

    ! initialize
    description   = ""
    units         = ""
    datatype      = -1
    dim_rank      = -1
    dim_name  (:) = ""
    dim_size  (:) = -1
    time_start(:) = FILE_RMISS
    time_end  (:) = FILE_RMISS

    do istep = 1, step_limit
       !--- get data information
       call file_get_datainfo_c( dinfo,               & ! [OUT]
                                 FILE_files(fid)%fid, & ! [IN]
                                 varname,             & ! [IN]
                                 istep,               & ! [IN]
                                 .true.,              & ! [IN]
                                 error                ) ! [OUT]

       !--- verify and exit
       if ( error /= FILE_SUCCESS_CODE ) then
          step_nmax = istep - 1
          exit
       endif

       if ( istep == 1 ) then
          description = dinfo%description
          units       = dinfo%units
          datatype    = dinfo%datatype
          dim_rank    = dinfo%rank

          ndim = min( dinfo%rank, dim_limit ) ! limit dimension rank
          do idim = 1, ndim
             dim_name(idim) = dinfo%dim_name(idim)
             dim_size(idim) = dinfo%dim_size(idim)
          enddo

          if ( dinfo%time_units == "" ) then
             call FILE_get_attribute( fid, "global", "time_units", time_units )
             call FILE_get_attribute( fid, "global", "time_start", time )
             time_start(1) = time(1)
             time_end  (1) = time(1)
             step_nmax = 1
             exit
          else
             time_units    = dinfo%time_units
             time_start(1) = dinfo%time_start
             time_end  (1) = dinfo%time_end
          endif
       else
          time_start(istep) = dinfo%time_start
          time_end  (istep) = dinfo%time_end
       endif
    enddo

    return
  end subroutine FILE_get_all_dataInfo_fid

  !-----------------------------------------------------------------------------
  ! interface FILE_read
  !-----------------------------------------------------------------------------
  subroutine FILE_read_realSP_1D( &
      basename, varname,             &
      var,                           &
      step, rankid, single, postfix, &
      allow_missing, missing_value   )
    implicit none

    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    real(SP),    intent(out)           :: var(:)
    integer,          intent( in), optional :: step
    integer,          intent( in), optional :: rankid
    logical,          intent( in), optional :: single
    character(len=*), intent( in), optional :: postfix
    logical,          intent( in), optional :: allow_missing !> if data is missing, set value to missing_value
    real(SP),    intent( in), optional :: missing_value !> default is zero

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(1)
    integer :: error
    integer :: n

    intrinsic shape
    !---------------------------------------------------------------------------

    !--- search/register file
    call FILE_open( basename,                     & ! (in)
                    fid,                          & ! (out)
                    rankid=rankid, single=single, & ! (in)
                    postfix=postfix               ) ! (in)

    call FILE_read_var_realSP_1D( &
         fid, varname,                                            & ! (in)
         var(:),                                           & ! (out)
         step=step,                                               & ! (in)
         allow_missing=allow_missing, missing_value=missing_value ) ! (in)

    return
  end subroutine FILE_read_realSP_1D
  subroutine FILE_read_realDP_1D( &
      basename, varname,             &
      var,                           &
      step, rankid, single, postfix, &
      allow_missing, missing_value   )
    implicit none

    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    real(DP),    intent(out)           :: var(:)
    integer,          intent( in), optional :: step
    integer,          intent( in), optional :: rankid
    logical,          intent( in), optional :: single
    character(len=*), intent( in), optional :: postfix
    logical,          intent( in), optional :: allow_missing !> if data is missing, set value to missing_value
    real(DP),    intent( in), optional :: missing_value !> default is zero

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(1)
    integer :: error
    integer :: n

    intrinsic shape
    !---------------------------------------------------------------------------

    !--- search/register file
    call FILE_open( basename,                     & ! (in)
                    fid,                          & ! (out)
                    rankid=rankid, single=single, & ! (in)
                    postfix=postfix               ) ! (in)

    call FILE_read_var_realDP_1D( &
         fid, varname,                                            & ! (in)
         var(:),                                           & ! (out)
         step=step,                                               & ! (in)
         allow_missing=allow_missing, missing_value=missing_value ) ! (in)

    return
  end subroutine FILE_read_realDP_1D
  subroutine FILE_read_realSP_2D( &
      basename, varname,             &
      var,                           &
      step, rankid, single, postfix, &
      allow_missing, missing_value   )
    implicit none

    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    real(SP),    intent(out)           :: var(:,:)
    integer,          intent( in), optional :: step
    integer,          intent( in), optional :: rankid
    logical,          intent( in), optional :: single
    character(len=*), intent( in), optional :: postfix
    logical,          intent( in), optional :: allow_missing !> if data is missing, set value to missing_value
    real(SP),    intent( in), optional :: missing_value !> default is zero

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(2)
    integer :: error
    integer :: n

    intrinsic shape
    !---------------------------------------------------------------------------

    !--- search/register file
    call FILE_open( basename,                     & ! (in)
                    fid,                          & ! (out)
                    rankid=rankid, single=single, & ! (in)
                    postfix=postfix               ) ! (in)

    call FILE_read_var_realSP_2D( &
         fid, varname,                                            & ! (in)
         var(:,:),                                           & ! (out)
         step=step,                                               & ! (in)
         allow_missing=allow_missing, missing_value=missing_value ) ! (in)

    return
  end subroutine FILE_read_realSP_2D
  subroutine FILE_read_realDP_2D( &
      basename, varname,             &
      var,                           &
      step, rankid, single, postfix, &
      allow_missing, missing_value   )
    implicit none

    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    real(DP),    intent(out)           :: var(:,:)
    integer,          intent( in), optional :: step
    integer,          intent( in), optional :: rankid
    logical,          intent( in), optional :: single
    character(len=*), intent( in), optional :: postfix
    logical,          intent( in), optional :: allow_missing !> if data is missing, set value to missing_value
    real(DP),    intent( in), optional :: missing_value !> default is zero

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(2)
    integer :: error
    integer :: n

    intrinsic shape
    !---------------------------------------------------------------------------

    !--- search/register file
    call FILE_open( basename,                     & ! (in)
                    fid,                          & ! (out)
                    rankid=rankid, single=single, & ! (in)
                    postfix=postfix               ) ! (in)

    call FILE_read_var_realDP_2D( &
         fid, varname,                                            & ! (in)
         var(:,:),                                           & ! (out)
         step=step,                                               & ! (in)
         allow_missing=allow_missing, missing_value=missing_value ) ! (in)

    return
  end subroutine FILE_read_realDP_2D
  subroutine FILE_read_realSP_3D( &
      basename, varname,             &
      var,                           &
      step, rankid, single, postfix, &
      allow_missing, missing_value   )
    implicit none

    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    real(SP),    intent(out)           :: var(:,:,:)
    integer,          intent( in), optional :: step
    integer,          intent( in), optional :: rankid
    logical,          intent( in), optional :: single
    character(len=*), intent( in), optional :: postfix
    logical,          intent( in), optional :: allow_missing !> if data is missing, set value to missing_value
    real(SP),    intent( in), optional :: missing_value !> default is zero

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(3)
    integer :: error
    integer :: n

    intrinsic shape
    !---------------------------------------------------------------------------

    !--- search/register file
    call FILE_open( basename,                     & ! (in)
                    fid,                          & ! (out)
                    rankid=rankid, single=single, & ! (in)
                    postfix=postfix               ) ! (in)

    call FILE_read_var_realSP_3D( &
         fid, varname,                                            & ! (in)
         var(:,:,:),                                           & ! (out)
         step=step,                                               & ! (in)
         allow_missing=allow_missing, missing_value=missing_value ) ! (in)

    return
  end subroutine FILE_read_realSP_3D
  subroutine FILE_read_realDP_3D( &
      basename, varname,             &
      var,                           &
      step, rankid, single, postfix, &
      allow_missing, missing_value   )
    implicit none

    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    real(DP),    intent(out)           :: var(:,:,:)
    integer,          intent( in), optional :: step
    integer,          intent( in), optional :: rankid
    logical,          intent( in), optional :: single
    character(len=*), intent( in), optional :: postfix
    logical,          intent( in), optional :: allow_missing !> if data is missing, set value to missing_value
    real(DP),    intent( in), optional :: missing_value !> default is zero

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(3)
    integer :: error
    integer :: n

    intrinsic shape
    !---------------------------------------------------------------------------

    !--- search/register file
    call FILE_open( basename,                     & ! (in)
                    fid,                          & ! (out)
                    rankid=rankid, single=single, & ! (in)
                    postfix=postfix               ) ! (in)

    call FILE_read_var_realDP_3D( &
         fid, varname,                                            & ! (in)
         var(:,:,:),                                           & ! (out)
         step=step,                                               & ! (in)
         allow_missing=allow_missing, missing_value=missing_value ) ! (in)

    return
  end subroutine FILE_read_realDP_3D
  subroutine FILE_read_realSP_4D( &
      basename, varname,             &
      var,                           &
      step, rankid, single, postfix, &
      allow_missing, missing_value   )
    implicit none

    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    real(SP),    intent(out)           :: var(:,:,:,:)
    integer,          intent( in), optional :: step
    integer,          intent( in), optional :: rankid
    logical,          intent( in), optional :: single
    character(len=*), intent( in), optional :: postfix
    logical,          intent( in), optional :: allow_missing !> if data is missing, set value to missing_value
    real(SP),    intent( in), optional :: missing_value !> default is zero

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(4)
    integer :: error
    integer :: n

    intrinsic shape
    !---------------------------------------------------------------------------

    !--- search/register file
    call FILE_open( basename,                     & ! (in)
                    fid,                          & ! (out)
                    rankid=rankid, single=single, & ! (in)
                    postfix=postfix               ) ! (in)

    call FILE_read_var_realSP_4D( &
         fid, varname,                                            & ! (in)
         var(:,:,:,:),                                           & ! (out)
         step=step,                                               & ! (in)
         allow_missing=allow_missing, missing_value=missing_value ) ! (in)

    return
  end subroutine FILE_read_realSP_4D
  subroutine FILE_read_realDP_4D( &
      basename, varname,             &
      var,                           &
      step, rankid, single, postfix, &
      allow_missing, missing_value   )
    implicit none

    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    real(DP),    intent(out)           :: var(:,:,:,:)
    integer,          intent( in), optional :: step
    integer,          intent( in), optional :: rankid
    logical,          intent( in), optional :: single
    character(len=*), intent( in), optional :: postfix
    logical,          intent( in), optional :: allow_missing !> if data is missing, set value to missing_value
    real(DP),    intent( in), optional :: missing_value !> default is zero

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(4)
    integer :: error
    integer :: n

    intrinsic shape
    !---------------------------------------------------------------------------

    !--- search/register file
    call FILE_open( basename,                     & ! (in)
                    fid,                          & ! (out)
                    rankid=rankid, single=single, & ! (in)
                    postfix=postfix               ) ! (in)

    call FILE_read_var_realDP_4D( &
         fid, varname,                                            & ! (in)
         var(:,:,:,:),                                           & ! (out)
         step=step,                                               & ! (in)
         allow_missing=allow_missing, missing_value=missing_value ) ! (in)

    return
  end subroutine FILE_read_realDP_4D

  subroutine FILE_read_var_realSP_1D( &
      fid, varname,  &
      var,           &
      step,          &
      allow_missing, &
      missing_value, &
      ntypes, dtype, &
      start, count   )
    use MPI, only : MPI_COMM_NULL
    implicit none

    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    real(SP),    intent(out)           :: var(:)
    integer,          intent( in), optional :: step
    logical,          intent( in), optional :: allow_missing !> if data is missing, set value to missing_value
    real(SP),    intent( in), optional :: missing_value !> default is zero
    integer,          intent( in), optional :: ntypes      !> number of dtypes
    integer,          intent( in), optional :: dtype       !> MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    !> request starts to global variable
    integer,          intent( in), optional :: count(:)    !> request sizes to global variable

    integer :: step_
    real(SP) :: missing_value_

    type(datainfo) :: dinfo
    integer :: dim_size(1)
    integer :: error
    integer :: n

    intrinsic size, shape
    !---------------------------------------------------------------------------

    if ( fid < 0 ) then
       write(*,*) 'xxx [File_read_var_readSP_4D] fid is invalid'
       call PRC_abort
    end if

    if ( present(step) ) then
       step_ = step
    else
       step_ = 1
    end if

    if ( present(missing_value) ) then
       missing_value_ = missing_value
    else
       missing_value_ = 0.0_SP
    end if

    !--- get data information
    call file_get_datainfo_c( dinfo,                   & ! (out)
         FILE_files(fid)%fid, varname, step_, .false., & ! (in)
         error                                         ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             if (IO_L) write(IO_FID_LOG,*) 'xxx [INPUT]/[FILE] data not found! : ', &
                  'varname= ',trim(varname),', step=',step_
             if (IO_L) write(IO_FID_LOG,*) 'xxx [INPUT]/[FILE] Value is set to ', missing_value_
             var(:) = missing_value_
             return
          else
             write(*,*) 'xxx failed to get data information :'//trim(varname)
             call PRC_abort
          end if
       else
          write(*,*) 'xxx failed to get data information :'//trim(varname)
          call PRC_abort
       end if
    end if

    if ( dinfo%rank /= 1 ) then
       if ( (.not. present(start)) .and. (.not. present(count)) ) then
          write(*,*) 'xxx [FILE_read_var_realSP_1D] rank of '//trim(varname)//' is not 1', dinfo%rank
          call PRC_abort
       end if
    end if

    if (present(ntypes) ) then
       call file_read_data_c( var(:),             & ! (out)
            dinfo, SP, ntypes, dtype, start(:), count(:), & ! (in)
            error                                        ) ! (out)
    else
       if ( present(start) .and. present(count) ) then
          call file_read_data_c( var(:),          & ! (out)
               dinfo, SP, 0, 0, start(:), count(:), & ! (in)
               error                                     ) ! (out)
       else
          dim_size(:) = shape(var)
          do n = 1, 1
             if ( dinfo%dim_size(n) /= dim_size(n) ) then
                write(*,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
                call PRC_abort
             end if
          end do
          call file_read_data_c( var(:), & ! (out)
               dinfo, SP, 0, 0, -1, -1,    & ! (in)
               error                            ) ! (out)
       end if
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to get data value'
       call PRC_abort
    end if

    return
  end subroutine FILE_read_var_realSP_1D
  subroutine FILE_read_var_realDP_1D( &
      fid, varname,  &
      var,           &
      step,          &
      allow_missing, &
      missing_value, &
      ntypes, dtype, &
      start, count   )
    use MPI, only : MPI_COMM_NULL
    implicit none

    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    real(DP),    intent(out)           :: var(:)
    integer,          intent( in), optional :: step
    logical,          intent( in), optional :: allow_missing !> if data is missing, set value to missing_value
    real(DP),    intent( in), optional :: missing_value !> default is zero
    integer,          intent( in), optional :: ntypes      !> number of dtypes
    integer,          intent( in), optional :: dtype       !> MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    !> request starts to global variable
    integer,          intent( in), optional :: count(:)    !> request sizes to global variable

    integer :: step_
    real(DP) :: missing_value_

    type(datainfo) :: dinfo
    integer :: dim_size(1)
    integer :: error
    integer :: n

    intrinsic size, shape
    !---------------------------------------------------------------------------

    if ( fid < 0 ) then
       write(*,*) 'xxx [File_read_var_readDP_4D] fid is invalid'
       call PRC_abort
    end if

    if ( present(step) ) then
       step_ = step
    else
       step_ = 1
    end if

    if ( present(missing_value) ) then
       missing_value_ = missing_value
    else
       missing_value_ = 0.0_DP
    end if

    !--- get data information
    call file_get_datainfo_c( dinfo,                   & ! (out)
         FILE_files(fid)%fid, varname, step_, .false., & ! (in)
         error                                         ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             if (IO_L) write(IO_FID_LOG,*) 'xxx [INPUT]/[FILE] data not found! : ', &
                  'varname= ',trim(varname),', step=',step_
             if (IO_L) write(IO_FID_LOG,*) 'xxx [INPUT]/[FILE] Value is set to ', missing_value_
             var(:) = missing_value_
             return
          else
             write(*,*) 'xxx failed to get data information :'//trim(varname)
             call PRC_abort
          end if
       else
          write(*,*) 'xxx failed to get data information :'//trim(varname)
          call PRC_abort
       end if
    end if

    if ( dinfo%rank /= 1 ) then
       if ( (.not. present(start)) .and. (.not. present(count)) ) then
          write(*,*) 'xxx [FILE_read_var_realDP_1D] rank of '//trim(varname)//' is not 1', dinfo%rank
          call PRC_abort
       end if
    end if

    if (present(ntypes) ) then
       call file_read_data_c( var(:),             & ! (out)
            dinfo, DP, ntypes, dtype, start(:), count(:), & ! (in)
            error                                        ) ! (out)
    else
       if ( present(start) .and. present(count) ) then
          call file_read_data_c( var(:),          & ! (out)
               dinfo, DP, 0, 0, start(:), count(:), & ! (in)
               error                                     ) ! (out)
       else
          dim_size(:) = shape(var)
          do n = 1, 1
             if ( dinfo%dim_size(n) /= dim_size(n) ) then
                write(*,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
                call PRC_abort
             end if
          end do
          call file_read_data_c( var(:), & ! (out)
               dinfo, DP, 0, 0, -1, -1,    & ! (in)
               error                            ) ! (out)
       end if
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to get data value'
       call PRC_abort
    end if

    return
  end subroutine FILE_read_var_realDP_1D
  subroutine FILE_read_var_realSP_2D( &
      fid, varname,  &
      var,           &
      step,          &
      allow_missing, &
      missing_value, &
      ntypes, dtype, &
      start, count   )
    use MPI, only : MPI_COMM_NULL
    implicit none

    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    real(SP),    intent(out)           :: var(:,:)
    integer,          intent( in), optional :: step
    logical,          intent( in), optional :: allow_missing !> if data is missing, set value to missing_value
    real(SP),    intent( in), optional :: missing_value !> default is zero
    integer,          intent( in), optional :: ntypes      !> number of dtypes
    integer,          intent( in), optional :: dtype       !> MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    !> request starts to global variable
    integer,          intent( in), optional :: count(:)    !> request sizes to global variable

    integer :: step_
    real(SP) :: missing_value_

    type(datainfo) :: dinfo
    integer :: dim_size(2)
    integer :: error
    integer :: n

    intrinsic size, shape
    !---------------------------------------------------------------------------

    if ( fid < 0 ) then
       write(*,*) 'xxx [File_read_var_readSP_4D] fid is invalid'
       call PRC_abort
    end if

    if ( present(step) ) then
       step_ = step
    else
       step_ = 1
    end if

    if ( present(missing_value) ) then
       missing_value_ = missing_value
    else
       missing_value_ = 0.0_SP
    end if

    !--- get data information
    call file_get_datainfo_c( dinfo,                   & ! (out)
         FILE_files(fid)%fid, varname, step_, .false., & ! (in)
         error                                         ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             if (IO_L) write(IO_FID_LOG,*) 'xxx [INPUT]/[FILE] data not found! : ', &
                  'varname= ',trim(varname),', step=',step_
             if (IO_L) write(IO_FID_LOG,*) 'xxx [INPUT]/[FILE] Value is set to ', missing_value_
             var(:,:) = missing_value_
             return
          else
             write(*,*) 'xxx failed to get data information :'//trim(varname)
             call PRC_abort
          end if
       else
          write(*,*) 'xxx failed to get data information :'//trim(varname)
          call PRC_abort
       end if
    end if

    if ( dinfo%rank /= 2 ) then
       if ( (.not. present(start)) .and. (.not. present(count)) ) then
          write(*,*) 'xxx [FILE_read_var_realSP_2D] rank of '//trim(varname)//' is not 2', dinfo%rank
          call PRC_abort
       end if
    end if

    if (present(ntypes) ) then
       call file_read_data_c( var(:,:),             & ! (out)
            dinfo, SP, ntypes, dtype, start(:), count(:), & ! (in)
            error                                        ) ! (out)
    else
       if ( present(start) .and. present(count) ) then
          call file_read_data_c( var(:,:),          & ! (out)
               dinfo, SP, 0, 0, start(:), count(:), & ! (in)
               error                                     ) ! (out)
       else
          dim_size(:) = shape(var)
          do n = 1, 2
             if ( dinfo%dim_size(n) /= dim_size(n) ) then
                write(*,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
                call PRC_abort
             end if
          end do
          call file_read_data_c( var(:,:), & ! (out)
               dinfo, SP, 0, 0, -1, -1,    & ! (in)
               error                            ) ! (out)
       end if
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to get data value'
       call PRC_abort
    end if

    return
  end subroutine FILE_read_var_realSP_2D
  subroutine FILE_read_var_realDP_2D( &
      fid, varname,  &
      var,           &
      step,          &
      allow_missing, &
      missing_value, &
      ntypes, dtype, &
      start, count   )
    use MPI, only : MPI_COMM_NULL
    implicit none

    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    real(DP),    intent(out)           :: var(:,:)
    integer,          intent( in), optional :: step
    logical,          intent( in), optional :: allow_missing !> if data is missing, set value to missing_value
    real(DP),    intent( in), optional :: missing_value !> default is zero
    integer,          intent( in), optional :: ntypes      !> number of dtypes
    integer,          intent( in), optional :: dtype       !> MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    !> request starts to global variable
    integer,          intent( in), optional :: count(:)    !> request sizes to global variable

    integer :: step_
    real(DP) :: missing_value_

    type(datainfo) :: dinfo
    integer :: dim_size(2)
    integer :: error
    integer :: n

    intrinsic size, shape
    !---------------------------------------------------------------------------

    if ( fid < 0 ) then
       write(*,*) 'xxx [File_read_var_readDP_4D] fid is invalid'
       call PRC_abort
    end if

    if ( present(step) ) then
       step_ = step
    else
       step_ = 1
    end if

    if ( present(missing_value) ) then
       missing_value_ = missing_value
    else
       missing_value_ = 0.0_DP
    end if

    !--- get data information
    call file_get_datainfo_c( dinfo,                   & ! (out)
         FILE_files(fid)%fid, varname, step_, .false., & ! (in)
         error                                         ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             if (IO_L) write(IO_FID_LOG,*) 'xxx [INPUT]/[FILE] data not found! : ', &
                  'varname= ',trim(varname),', step=',step_
             if (IO_L) write(IO_FID_LOG,*) 'xxx [INPUT]/[FILE] Value is set to ', missing_value_
             var(:,:) = missing_value_
             return
          else
             write(*,*) 'xxx failed to get data information :'//trim(varname)
             call PRC_abort
          end if
       else
          write(*,*) 'xxx failed to get data information :'//trim(varname)
          call PRC_abort
       end if
    end if

    if ( dinfo%rank /= 2 ) then
       if ( (.not. present(start)) .and. (.not. present(count)) ) then
          write(*,*) 'xxx [FILE_read_var_realDP_2D] rank of '//trim(varname)//' is not 2', dinfo%rank
          call PRC_abort
       end if
    end if

    if (present(ntypes) ) then
       call file_read_data_c( var(:,:),             & ! (out)
            dinfo, DP, ntypes, dtype, start(:), count(:), & ! (in)
            error                                        ) ! (out)
    else
       if ( present(start) .and. present(count) ) then
          call file_read_data_c( var(:,:),          & ! (out)
               dinfo, DP, 0, 0, start(:), count(:), & ! (in)
               error                                     ) ! (out)
       else
          dim_size(:) = shape(var)
          do n = 1, 2
             if ( dinfo%dim_size(n) /= dim_size(n) ) then
                write(*,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
                call PRC_abort
             end if
          end do
          call file_read_data_c( var(:,:), & ! (out)
               dinfo, DP, 0, 0, -1, -1,    & ! (in)
               error                            ) ! (out)
       end if
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to get data value'
       call PRC_abort
    end if

    return
  end subroutine FILE_read_var_realDP_2D
  subroutine FILE_read_var_realSP_3D( &
      fid, varname,  &
      var,           &
      step,          &
      allow_missing, &
      missing_value, &
      ntypes, dtype, &
      start, count   )
    use MPI, only : MPI_COMM_NULL
    implicit none

    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    real(SP),    intent(out)           :: var(:,:,:)
    integer,          intent( in), optional :: step
    logical,          intent( in), optional :: allow_missing !> if data is missing, set value to missing_value
    real(SP),    intent( in), optional :: missing_value !> default is zero
    integer,          intent( in), optional :: ntypes      !> number of dtypes
    integer,          intent( in), optional :: dtype       !> MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    !> request starts to global variable
    integer,          intent( in), optional :: count(:)    !> request sizes to global variable

    integer :: step_
    real(SP) :: missing_value_

    type(datainfo) :: dinfo
    integer :: dim_size(3)
    integer :: error
    integer :: n

    intrinsic size, shape
    !---------------------------------------------------------------------------

    if ( fid < 0 ) then
       write(*,*) 'xxx [File_read_var_readSP_4D] fid is invalid'
       call PRC_abort
    end if

    if ( present(step) ) then
       step_ = step
    else
       step_ = 1
    end if

    if ( present(missing_value) ) then
       missing_value_ = missing_value
    else
       missing_value_ = 0.0_SP
    end if

    !--- get data information
    call file_get_datainfo_c( dinfo,                   & ! (out)
         FILE_files(fid)%fid, varname, step_, .false., & ! (in)
         error                                         ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             if (IO_L) write(IO_FID_LOG,*) 'xxx [INPUT]/[FILE] data not found! : ', &
                  'varname= ',trim(varname),', step=',step_
             if (IO_L) write(IO_FID_LOG,*) 'xxx [INPUT]/[FILE] Value is set to ', missing_value_
             var(:,:,:) = missing_value_
             return
          else
             write(*,*) 'xxx failed to get data information :'//trim(varname)
             call PRC_abort
          end if
       else
          write(*,*) 'xxx failed to get data information :'//trim(varname)
          call PRC_abort
       end if
    end if

    if ( dinfo%rank /= 3 ) then
       if ( (.not. present(start)) .and. (.not. present(count)) ) then
          write(*,*) 'xxx [FILE_read_var_realSP_3D] rank of '//trim(varname)//' is not 3', dinfo%rank
          call PRC_abort
       end if
    end if

    if (present(ntypes) ) then
       call file_read_data_c( var(:,:,:),             & ! (out)
            dinfo, SP, ntypes, dtype, start(:), count(:), & ! (in)
            error                                        ) ! (out)
    else
       if ( present(start) .and. present(count) ) then
          call file_read_data_c( var(:,:,:),          & ! (out)
               dinfo, SP, 0, 0, start(:), count(:), & ! (in)
               error                                     ) ! (out)
       else
          dim_size(:) = shape(var)
          do n = 1, 3
             if ( dinfo%dim_size(n) /= dim_size(n) ) then
                write(*,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
                call PRC_abort
             end if
          end do
          call file_read_data_c( var(:,:,:), & ! (out)
               dinfo, SP, 0, 0, -1, -1,    & ! (in)
               error                            ) ! (out)
       end if
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to get data value'
       call PRC_abort
    end if

    return
  end subroutine FILE_read_var_realSP_3D
  subroutine FILE_read_var_realDP_3D( &
      fid, varname,  &
      var,           &
      step,          &
      allow_missing, &
      missing_value, &
      ntypes, dtype, &
      start, count   )
    use MPI, only : MPI_COMM_NULL
    implicit none

    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    real(DP),    intent(out)           :: var(:,:,:)
    integer,          intent( in), optional :: step
    logical,          intent( in), optional :: allow_missing !> if data is missing, set value to missing_value
    real(DP),    intent( in), optional :: missing_value !> default is zero
    integer,          intent( in), optional :: ntypes      !> number of dtypes
    integer,          intent( in), optional :: dtype       !> MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    !> request starts to global variable
    integer,          intent( in), optional :: count(:)    !> request sizes to global variable

    integer :: step_
    real(DP) :: missing_value_

    type(datainfo) :: dinfo
    integer :: dim_size(3)
    integer :: error
    integer :: n

    intrinsic size, shape
    !---------------------------------------------------------------------------

    if ( fid < 0 ) then
       write(*,*) 'xxx [File_read_var_readDP_4D] fid is invalid'
       call PRC_abort
    end if

    if ( present(step) ) then
       step_ = step
    else
       step_ = 1
    end if

    if ( present(missing_value) ) then
       missing_value_ = missing_value
    else
       missing_value_ = 0.0_DP
    end if

    !--- get data information
    call file_get_datainfo_c( dinfo,                   & ! (out)
         FILE_files(fid)%fid, varname, step_, .false., & ! (in)
         error                                         ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             if (IO_L) write(IO_FID_LOG,*) 'xxx [INPUT]/[FILE] data not found! : ', &
                  'varname= ',trim(varname),', step=',step_
             if (IO_L) write(IO_FID_LOG,*) 'xxx [INPUT]/[FILE] Value is set to ', missing_value_
             var(:,:,:) = missing_value_
             return
          else
             write(*,*) 'xxx failed to get data information :'//trim(varname)
             call PRC_abort
          end if
       else
          write(*,*) 'xxx failed to get data information :'//trim(varname)
          call PRC_abort
       end if
    end if

    if ( dinfo%rank /= 3 ) then
       if ( (.not. present(start)) .and. (.not. present(count)) ) then
          write(*,*) 'xxx [FILE_read_var_realDP_3D] rank of '//trim(varname)//' is not 3', dinfo%rank
          call PRC_abort
       end if
    end if

    if (present(ntypes) ) then
       call file_read_data_c( var(:,:,:),             & ! (out)
            dinfo, DP, ntypes, dtype, start(:), count(:), & ! (in)
            error                                        ) ! (out)
    else
       if ( present(start) .and. present(count) ) then
          call file_read_data_c( var(:,:,:),          & ! (out)
               dinfo, DP, 0, 0, start(:), count(:), & ! (in)
               error                                     ) ! (out)
       else
          dim_size(:) = shape(var)
          do n = 1, 3
             if ( dinfo%dim_size(n) /= dim_size(n) ) then
                write(*,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
                call PRC_abort
             end if
          end do
          call file_read_data_c( var(:,:,:), & ! (out)
               dinfo, DP, 0, 0, -1, -1,    & ! (in)
               error                            ) ! (out)
       end if
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to get data value'
       call PRC_abort
    end if

    return
  end subroutine FILE_read_var_realDP_3D
  subroutine FILE_read_var_realSP_4D( &
      fid, varname,  &
      var,           &
      step,          &
      allow_missing, &
      missing_value, &
      ntypes, dtype, &
      start, count   )
    use MPI, only : MPI_COMM_NULL
    implicit none

    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    real(SP),    intent(out)           :: var(:,:,:,:)
    integer,          intent( in), optional :: step
    logical,          intent( in), optional :: allow_missing !> if data is missing, set value to missing_value
    real(SP),    intent( in), optional :: missing_value !> default is zero
    integer,          intent( in), optional :: ntypes      !> number of dtypes
    integer,          intent( in), optional :: dtype       !> MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    !> request starts to global variable
    integer,          intent( in), optional :: count(:)    !> request sizes to global variable

    integer :: step_
    real(SP) :: missing_value_

    type(datainfo) :: dinfo
    integer :: dim_size(4)
    integer :: error
    integer :: n

    intrinsic size, shape
    !---------------------------------------------------------------------------

    if ( fid < 0 ) then
       write(*,*) 'xxx [File_read_var_readSP_4D] fid is invalid'
       call PRC_abort
    end if

    if ( present(step) ) then
       step_ = step
    else
       step_ = 1
    end if

    if ( present(missing_value) ) then
       missing_value_ = missing_value
    else
       missing_value_ = 0.0_SP
    end if

    !--- get data information
    call file_get_datainfo_c( dinfo,                   & ! (out)
         FILE_files(fid)%fid, varname, step_, .false., & ! (in)
         error                                         ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             if (IO_L) write(IO_FID_LOG,*) 'xxx [INPUT]/[FILE] data not found! : ', &
                  'varname= ',trim(varname),', step=',step_
             if (IO_L) write(IO_FID_LOG,*) 'xxx [INPUT]/[FILE] Value is set to ', missing_value_
             var(:,:,:,:) = missing_value_
             return
          else
             write(*,*) 'xxx failed to get data information :'//trim(varname)
             call PRC_abort
          end if
       else
          write(*,*) 'xxx failed to get data information :'//trim(varname)
          call PRC_abort
       end if
    end if

    if ( dinfo%rank /= 4 ) then
       if ( (.not. present(start)) .and. (.not. present(count)) ) then
          write(*,*) 'xxx [FILE_read_var_realSP_4D] rank of '//trim(varname)//' is not 4', dinfo%rank
          call PRC_abort
       end if
    end if

    if (present(ntypes) ) then
       call file_read_data_c( var(:,:,:,:),             & ! (out)
            dinfo, SP, ntypes, dtype, start(:), count(:), & ! (in)
            error                                        ) ! (out)
    else
       if ( present(start) .and. present(count) ) then
          call file_read_data_c( var(:,:,:,:),          & ! (out)
               dinfo, SP, 0, 0, start(:), count(:), & ! (in)
               error                                     ) ! (out)
       else
          dim_size(:) = shape(var)
          do n = 1, 4
             if ( dinfo%dim_size(n) /= dim_size(n) ) then
                write(*,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
                call PRC_abort
             end if
          end do
          call file_read_data_c( var(:,:,:,:), & ! (out)
               dinfo, SP, 0, 0, -1, -1,    & ! (in)
               error                            ) ! (out)
       end if
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to get data value'
       call PRC_abort
    end if

    return
  end subroutine FILE_read_var_realSP_4D
  subroutine FILE_read_var_realDP_4D( &
      fid, varname,  &
      var,           &
      step,          &
      allow_missing, &
      missing_value, &
      ntypes, dtype, &
      start, count   )
    use MPI, only : MPI_COMM_NULL
    implicit none

    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    real(DP),    intent(out)           :: var(:,:,:,:)
    integer,          intent( in), optional :: step
    logical,          intent( in), optional :: allow_missing !> if data is missing, set value to missing_value
    real(DP),    intent( in), optional :: missing_value !> default is zero
    integer,          intent( in), optional :: ntypes      !> number of dtypes
    integer,          intent( in), optional :: dtype       !> MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    !> request starts to global variable
    integer,          intent( in), optional :: count(:)    !> request sizes to global variable

    integer :: step_
    real(DP) :: missing_value_

    type(datainfo) :: dinfo
    integer :: dim_size(4)
    integer :: error
    integer :: n

    intrinsic size, shape
    !---------------------------------------------------------------------------

    if ( fid < 0 ) then
       write(*,*) 'xxx [File_read_var_readDP_4D] fid is invalid'
       call PRC_abort
    end if

    if ( present(step) ) then
       step_ = step
    else
       step_ = 1
    end if

    if ( present(missing_value) ) then
       missing_value_ = missing_value
    else
       missing_value_ = 0.0_DP
    end if

    !--- get data information
    call file_get_datainfo_c( dinfo,                   & ! (out)
         FILE_files(fid)%fid, varname, step_, .false., & ! (in)
         error                                         ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             if (IO_L) write(IO_FID_LOG,*) 'xxx [INPUT]/[FILE] data not found! : ', &
                  'varname= ',trim(varname),', step=',step_
             if (IO_L) write(IO_FID_LOG,*) 'xxx [INPUT]/[FILE] Value is set to ', missing_value_
             var(:,:,:,:) = missing_value_
             return
          else
             write(*,*) 'xxx failed to get data information :'//trim(varname)
             call PRC_abort
          end if
       else
          write(*,*) 'xxx failed to get data information :'//trim(varname)
          call PRC_abort
       end if
    end if

    if ( dinfo%rank /= 4 ) then
       if ( (.not. present(start)) .and. (.not. present(count)) ) then
          write(*,*) 'xxx [FILE_read_var_realDP_4D] rank of '//trim(varname)//' is not 4', dinfo%rank
          call PRC_abort
       end if
    end if

    if (present(ntypes) ) then
       call file_read_data_c( var(:,:,:,:),             & ! (out)
            dinfo, DP, ntypes, dtype, start(:), count(:), & ! (in)
            error                                        ) ! (out)
    else
       if ( present(start) .and. present(count) ) then
          call file_read_data_c( var(:,:,:,:),          & ! (out)
               dinfo, DP, 0, 0, start(:), count(:), & ! (in)
               error                                     ) ! (out)
       else
          dim_size(:) = shape(var)
          do n = 1, 4
             if ( dinfo%dim_size(n) /= dim_size(n) ) then
                write(*,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
                call PRC_abort
             end if
          end do
          call file_read_data_c( var(:,:,:,:), & ! (out)
               dinfo, DP, 0, 0, -1, -1,    & ! (in)
               error                            ) ! (out)
       end if
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to get data value'
       call PRC_abort
    end if

    return
  end subroutine FILE_read_var_realDP_4D

  !-----------------------------------------------------------------------------
  ! interface FILE_write
  !-----------------------------------------------------------------------------
  subroutine FILE_write_realSP_1D( &
      vid, var,       &
      t_start, t_end, &
      ndims,          &
      count,          &
      start           )
    implicit none

    integer,  intent(in)           :: vid
    real(SP), intent(in) :: var(:)
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D
    integer,  intent(in), optional :: count(:)
    integer,  intent(in), optional :: start(:)
    real(DP) :: ts, te

    integer :: start_(1)

    integer :: fid
    integer :: error, n

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    fid = FILE_vars(vid)%fid
    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          write(*,*) 'start argument is neccessary when ndims is specified'
          call PRC_abort
       end if
       if ( .not. present(count) ) then
          write(*,*) 'count argument is neccessary when ndims is specified'
          call PRC_abort
       end if

       call file_write_data_c( FILE_files(fid)%fid, FILE_vars(vid)%vid, & ! (in)
            var(:), ts, te, SP,                             & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data_c( FILE_files(fid)%fid, FILE_vars(vid)%vid, & ! (in)
            var(:), ts, te, SP,                             & ! (in)
            1, start_, shape(var),                                 & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       do n = 1, FILE_nvars
          if ( FILE_vars(n)%vid == vid ) then
             write(*,*) 'xxx failed to write data: ', trim(FILE_vars(n)%name)
             exit
          end if
       enddo
       call PRC_abort
    end if

    return
  end subroutine FILE_write_realSP_1D
  subroutine FILE_write_realDP_1D( &
      vid, var,       &
      t_start, t_end, &
      ndims,          &
      count,          &
      start           )
    implicit none

    integer,  intent(in)           :: vid
    real(DP), intent(in) :: var(:)
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D
    integer,  intent(in), optional :: count(:)
    integer,  intent(in), optional :: start(:)
    real(DP) :: ts, te

    integer :: start_(1)

    integer :: fid
    integer :: error, n

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    fid = FILE_vars(vid)%fid
    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          write(*,*) 'start argument is neccessary when ndims is specified'
          call PRC_abort
       end if
       if ( .not. present(count) ) then
          write(*,*) 'count argument is neccessary when ndims is specified'
          call PRC_abort
       end if

       call file_write_data_c( FILE_files(fid)%fid, FILE_vars(vid)%vid, & ! (in)
            var(:), ts, te, DP,                             & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data_c( FILE_files(fid)%fid, FILE_vars(vid)%vid, & ! (in)
            var(:), ts, te, DP,                             & ! (in)
            1, start_, shape(var),                                 & ! (in)
            error                                                       ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       do n = 1, FILE_nvars
          if ( FILE_vars(n)%vid == vid ) then
             write(*,*) 'xxx failed to write data: ', trim(FILE_vars(n)%name)
             exit
          end if
       enddo
       call PRC_abort
    end if

    return
  end subroutine FILE_write_realDP_1D
  subroutine FILE_write_realSP_2D( &
      vid, var,       &
      t_start, t_end, &
      start           )
    implicit none

    integer,  intent(in)           :: vid
    real(SP), intent(in) :: var(:,:)
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    real(DP) :: ts, te

    integer :: start_(2)

    integer :: fid
    integer :: error, n

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    fid = FILE_vars(vid)%fid
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data_c( FILE_files(fid)%fid, FILE_vars(vid)%vid, & ! (in)
            var(:,:), ts, te, SP,                             & ! (in)
            2, start_, shape(var),                                 & ! (in)
            error                                                       ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       do n = 1, FILE_nvars
          if ( FILE_vars(n)%vid == vid ) then
             write(*,*) 'xxx failed to write data: ', trim(FILE_vars(n)%name)
             exit
          end if
       enddo
       call PRC_abort
    end if

    return
  end subroutine FILE_write_realSP_2D
  subroutine FILE_write_realDP_2D( &
      vid, var,       &
      t_start, t_end, &
      start           )
    implicit none

    integer,  intent(in)           :: vid
    real(DP), intent(in) :: var(:,:)
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    real(DP) :: ts, te

    integer :: start_(2)

    integer :: fid
    integer :: error, n

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    fid = FILE_vars(vid)%fid
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data_c( FILE_files(fid)%fid, FILE_vars(vid)%vid, & ! (in)
            var(:,:), ts, te, DP,                             & ! (in)
            2, start_, shape(var),                                 & ! (in)
            error                                                       ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       do n = 1, FILE_nvars
          if ( FILE_vars(n)%vid == vid ) then
             write(*,*) 'xxx failed to write data: ', trim(FILE_vars(n)%name)
             exit
          end if
       enddo
       call PRC_abort
    end if

    return
  end subroutine FILE_write_realDP_2D
  subroutine FILE_write_realSP_3D( &
      vid, var,       &
      t_start, t_end, &
      start           )
    implicit none

    integer,  intent(in)           :: vid
    real(SP), intent(in) :: var(:,:,:)
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    real(DP) :: ts, te

    integer :: start_(3)

    integer :: fid
    integer :: error, n

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    fid = FILE_vars(vid)%fid
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data_c( FILE_files(fid)%fid, FILE_vars(vid)%vid, & ! (in)
            var(:,:,:), ts, te, SP,                             & ! (in)
            3, start_, shape(var),                                 & ! (in)
            error                                                       ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       do n = 1, FILE_nvars
          if ( FILE_vars(n)%vid == vid ) then
             write(*,*) 'xxx failed to write data: ', trim(FILE_vars(n)%name)
             exit
          end if
       enddo
       call PRC_abort
    end if

    return
  end subroutine FILE_write_realSP_3D
  subroutine FILE_write_realDP_3D( &
      vid, var,       &
      t_start, t_end, &
      start           )
    implicit none

    integer,  intent(in)           :: vid
    real(DP), intent(in) :: var(:,:,:)
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    real(DP) :: ts, te

    integer :: start_(3)

    integer :: fid
    integer :: error, n

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    fid = FILE_vars(vid)%fid
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data_c( FILE_files(fid)%fid, FILE_vars(vid)%vid, & ! (in)
            var(:,:,:), ts, te, DP,                             & ! (in)
            3, start_, shape(var),                                 & ! (in)
            error                                                       ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       do n = 1, FILE_nvars
          if ( FILE_vars(n)%vid == vid ) then
             write(*,*) 'xxx failed to write data: ', trim(FILE_vars(n)%name)
             exit
          end if
       enddo
       call PRC_abort
    end if

    return
  end subroutine FILE_write_realDP_3D
  subroutine FILE_write_realSP_4D( &
      vid, var,       &
      t_start, t_end, &
      start           )
    implicit none

    integer,  intent(in)           :: vid
    real(SP), intent(in) :: var(:,:,:,:)
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    real(DP) :: ts, te

    integer :: start_(4)

    integer :: fid
    integer :: error, n

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    fid = FILE_vars(vid)%fid
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data_c( FILE_files(fid)%fid, FILE_vars(vid)%vid, & ! (in)
            var(:,:,:,:), ts, te, SP,                             & ! (in)
            4, start_, shape(var),                                 & ! (in)
            error                                                       ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       do n = 1, FILE_nvars
          if ( FILE_vars(n)%vid == vid ) then
             write(*,*) 'xxx failed to write data: ', trim(FILE_vars(n)%name)
             exit
          end if
       enddo
       call PRC_abort
    end if

    return
  end subroutine FILE_write_realSP_4D
  subroutine FILE_write_realDP_4D( &
      vid, var,       &
      t_start, t_end, &
      start           )
    implicit none

    integer,  intent(in)           :: vid
    real(DP), intent(in) :: var(:,:,:,:)
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
    integer,  intent(in), optional :: start(:)
    real(DP) :: ts, te

    integer :: start_(4)

    integer :: fid
    integer :: error, n

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    fid = FILE_vars(vid)%fid
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data_c( FILE_files(fid)%fid, FILE_vars(vid)%vid, & ! (in)
            var(:,:,:,:), ts, te, DP,                             & ! (in)
            4, start_, shape(var),                                 & ! (in)
            error                                                       ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       do n = 1, FILE_nvars
          if ( FILE_vars(n)%vid == vid ) then
             write(*,*) 'xxx failed to write data: ', trim(FILE_vars(n)%name)
             exit
          end if
       enddo
       call PRC_abort
    end if

    return
  end subroutine FILE_write_realDP_4D

  !-----------------------------------------------------------------------------
  ! exit netCDF define mode and enter data mode
  subroutine FILE_enddef( fid )
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    call file_enddef_c( FILE_files(fid)%fid, error )

    if ( error == FILE_SUCCESS_CODE ) then

       if (IO_L) write(IO_FID_LOG,*)
       if (IO_L) write(IO_FID_LOG,'(A,I3.3,2A)') &
            '###### FILE end define mode       : No.', fid, ', name = ', trim(FILE_files(fid)%name)

    else
       write(*,*) 'xxx failed to exit define mode'
       call PRC_abort
    end if

    return
  end subroutine FILE_enddef

  !-----------------------------------------------------------------------------
  ! This subroutine is used when PnetCDF I/O method is enabled
  subroutine FILE_attach_buffer( &
       fid,       &
       buf_amount )
    implicit none

    integer, intent(in) :: fid
    integer, intent(in) :: buf_amount

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    call file_attach_buffer_c( FILE_files(fid)%fid, buf_amount, error )

    if ( error == FILE_SUCCESS_CODE ) then

       if (IO_L) write(IO_FID_LOG,*)
       if (IO_L) write(IO_FID_LOG,'(A,I3.3,3A,I10)') &
            '###### FILE attach buffer         : No.', fid, ', name = ', trim(FILE_files(fid)%name), &
            ', size = ', buf_amount
    else
       write(*,*) 'xxx failed to attach buffer in PnetCDF'
       call PRC_abort
    end if

    return
  end subroutine FILE_attach_buffer

  !-----------------------------------------------------------------------------
  ! This subroutine is used when PnetCDF I/O method is enabled
  subroutine FILE_detach_buffer( fid )
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    if ( FILE_files(fid)%fid < 0 ) return  ! already closed

    call file_detach_buffer_c( FILE_files(fid)%fid, error )

    if ( error == FILE_SUCCESS_CODE ) then

       if (IO_L) write(IO_FID_LOG,*)
       if (IO_L) write(IO_FID_LOG,'(A,I3.3,2A)') &
            '###### FILE detach buffer         : No.', fid, ', name = ', trim(FILE_files(fid)%name)

    else
       write(*,*) 'xxx failed to detach buffer in PnetCDF'
       call PRC_abort
    end if

    return
  end subroutine FILE_detach_buffer

  !-----------------------------------------------------------------------------
  ! This subroutine is used when PnetCDF I/O method is enabled
  subroutine FILE_flush( fid )
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    if ( FILE_files(fid)%fid < 0 ) return  ! already closed

    call file_flush_c( FILE_files(fid)%fid, error )

    if ( error == FILE_SUCCESS_CODE ) then

       if (IO_L) write(IO_FID_LOG,*)
       if (IO_L) write(IO_FID_LOG,'(A,I3.3,2A)') &
            '###### FILE flush                 : No.', fid, ', name = ', trim(FILE_files(fid)%name)

    else
       write(*,*) 'xxx failed to flush PnetCDF pending requests'
       call PRC_abort
    end if

    return
  end subroutine FILE_flush

  !-----------------------------------------------------------------------------
  subroutine FILE_close( fid )
    implicit none

    integer, intent(in) :: fid

    character(len=FILE_HLONG) :: fname
    integer                   :: error
    integer                   :: n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    if ( FILE_files(fid)%fid < 0 ) return  ! already closed

    call file_close_c( FILE_files(fid)%fid, error )

    if ( error == FILE_SUCCESS_CODE ) then

       if (IO_L) write(IO_FID_LOG,*)
       if (IO_L) write(IO_FID_LOG,'(A,I3.3,2A)') &
            '###### FILE close                 : No.', fid, ', name = ', trim(FILE_files(fid)%name)

    elseif( error /= FILE_ALREADY_CLOSED_CODE ) then
       write(*,*) 'xxx failed to close file'
       call PRC_abort

    end if

    FILE_files(fid)%fid = -1
    FILE_files(fid)%name = ''
    FILE_files(fid)%aggregate = .false.

    do n = 1, FILE_nvars
       if ( FILE_vars(n)%fid == fid ) then
          FILE_vars(n)%vid = -1
          FILE_vars(n)%name = ''
       end if
    end do

    return
  end subroutine FILE_close
  !-----------------------------------------------------------------------------
  subroutine FILE_close_all
    implicit none

    integer n
    !---------------------------------------------------------------------------

    do n = 1, FILE_nfiles
       call FILE_close( n )
    enddo

    return
  end subroutine FILE_close_all

  subroutine FILE_make_fname( &
       basename, &
       prefix,   &
       rankid,   &
       len,      &
       fname     )
    character(len=*), intent( in) :: basename
    character(len=*), intent( in) :: prefix
    integer,          intent( in) :: rankid
    integer,          intent( in) :: len
    character(len=*), intent(out) :: fname

    !                           12345678901234567
    character(len=17) :: fmt = "(A, '.', A, I*.*)"
    !---------------------------------------------------------------------------

    if ( len < 1 .or. len > 9 ) then
       write(*,*) 'xxx [FILE_make_fname] len is invalid'
       call PRC_abort
    end if

    write(fmt(14:14),'(I1)') len
    write(fmt(16:16),'(I1)') len
    write(fname, fmt) trim(basename), trim(prefix), rankid

    return
  end subroutine FILE_make_fname

  !-----------------------------------------------------------------------------
  !> get unit of time
  !-----------------------------------------------------------------------------
  subroutine FILE_get_CFtunits(date, tunits)
    implicit none

    integer,          intent(in)  :: date(6)
    character(len=*), intent(out) :: tunits
    !---------------------------------------------------------------------------

    write(tunits,'(a,i4.4,"-",i2.2,"-",i2.2," ",i2.2,":",i2.2,":",i2.2)') 'seconds since ', date

    return
  end subroutine FILE_get_CFtunits

  function FILE_get_aggregate( fid )
    integer, intent(in) :: fid
    logical :: FILE_get_aggregate

    if ( fid < 0 ) then
       FILE_get_aggregate = .false.
    else
       FILE_get_aggregate = FILE_files(fid)%aggregate
    end if

    return
  end function FILE_get_aggregate

  !-----------------------------------------------------------------------------
  ! private
  !-----------------------------------------------------------------------------

  !-----------------------------------------------------------------------------
  subroutine FILE_get_fid( &
      basename,   &
      mode,       &
      rankid,     &
      single,     &
      fid,        &
      existed,    &
      mpi_comm,   &
      postfix     )
    use MPI, only: &
      MPI_COMM_NULL
    implicit none

    character(len=*), intent( in) :: basename
    integer,          intent( in) :: mode
    integer,          intent( in) :: rankid
    logical,          intent( in) :: single

    integer,          intent(out) :: fid
    logical,          intent(out) :: existed

    integer,          intent( in), optional :: mpi_comm
    character(len=*), intent( in), optional :: postfix

    character(len=FILE_HSHORT) :: rwname(0:2)
    data rwname / 'READ','WRITE','APPEND' /

    character(len=FILE_HLONG) :: fname
    integer                   :: n

    logical :: aggregate
    integer :: cfid
    integer :: error
    integer :: mpi_comm_
    !---------------------------------------------------------------------------

    !--- check aggregate (parallel I/O on a single shared netCDF file)
    mpi_comm_ = MPI_COMM_NULL
    if ( present(mpi_comm) ) mpi_comm_ = mpi_comm

    aggregate = ( mpi_comm_ .ne. MPI_COMM_NULL )

    if ( present(postfix) ) then
       fname = trim(basename)//trim(postfix)
    elseif ( aggregate ) then
       fname = basename
    elseif ( single ) then
       fname = trim(basename)//'.peall'
    else
       call FILE_make_fname( basename, 'pe', rankid, 6, fname )
    endif

    !--- search existing file
    fid = -1
    do n = 1, FILE_nfiles
       if ( fname == FILE_files(n)%name ) then
          fid = n
          exit
       end if
    enddo

    if ( fid >= 0 ) then
       existed = .true.
       return
    end if

    call file_open_c( cfid,                   & ! (out)
                      fname, mode, mpi_comm_, & ! (in)
                      error                   ) ! (out)

    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to open file :'//trim(fname)//'.nc'
       call PRC_abort
    end if

    if (IO_L) write(IO_FID_LOG,*)
    if (IO_L) write(IO_FID_LOG,'(A,A6,A,I3.3,2A)') &
         '###### FILE registration (', trim(rwname(mode)), ') : No.', fid, ', name = ', trim(fname)

    FILE_nfiles = FILE_nfiles + 1
    fid = FILE_nfiles
    FILE_files(fid)%name      = fname
    FILE_files(fid)%fid       = cfid
    FILE_files(fid)%aggregate = aggregate

    existed = .false.

    return
  end subroutine FILE_get_fid


end module scale_file
!-------------------------------------------------------------------------------


!--
! vi:set readonly sw=4 ts=8
!
!Local Variables:
!mode: f90
!buffer-read-only: t
!End:
!
!++
