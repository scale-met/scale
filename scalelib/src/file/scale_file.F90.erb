% # -*- f90 -*-
% # vi: set sw=4 ts=8:
!-------------------------------------------------------------------------------
!> module file
!!
!! @par Description
!!          file I/O hundring
!!
!! @author Team SCALE
!!
!<
!-------------------------------------------------------------------------------
! Warning: This file was generated from <%=__FILE__%>.
!          Do not edit this file.
!-------------------------------------------------------------------------------
module scale_file
  !-----------------------------------------------------------------------------
  !
  !++ Used modules
  !
  use scale_stdio
  use scale_precision
  use scale_file_h
  use scale_process, only: &
     PRC_abort
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedures
  !
  public :: FILE_setup
  public :: FILE_open
  public :: FILE_create
  public :: FILE_set_option
  public :: FILE_def_axis
  public :: FILE_put_axis
  public :: FILE_write_axis
  public :: FILE_def_associatedCoordinate
  public :: FILE_put_associatedCoordinate
  public :: FILE_write_associatedCoordinate
  public :: FILE_add_variable
  public :: FILE_def_variable
  public :: FILE_get_shape
  public :: FILE_get_commonInfo
  public :: FILE_get_dataInfo
  public :: FILE_get_all_dataInfo
  public :: FILE_read
  public :: FILE_write
  public :: FILE_get_attribute
  public :: FILE_set_attribute
  public :: FILE_add_associatedVariable
  public :: FILE_enddef
  public :: FILE_flush
  public :: FILE_close
  public :: FILE_close_all
  public :: FILE_make_fname
  public :: FILE_attach_buffer
  public :: FILE_detach_buffer
  public :: FILE_get_CFtunits
  public :: FILE_get_aggregate

  interface FILE_get_commonInfo
     module procedure FILE_get_commonInfo_fid
     module procedure FILE_get_commonInfo_fname
  end interface FILE_get_commonInfo

  interface FILE_get_datainfo
     module procedure FILE_get_datainfo_fid
     module procedure FILE_get_datainfo_fname
  end interface FILE_get_datainfo

  interface FILE_get_all_datainfo
     module procedure FILE_get_all_datainfo_fid
     module procedure FILE_get_all_datainfo_fname
  end interface FILE_get_all_datainfo

  interface FILE_put_axis
     module procedure FILE_put_axis_realSP
     module procedure FILE_put_axis_realDP
  end interface FILE_put_axis
  interface FILE_write_axis
     module procedure FILE_write_axis_realSP
     module procedure FILE_write_axis_realDP
  end interface FILE_write_axis
  interface FILE_put_associatedCoordinate
% for n in 1..4
%   %w(SP DP).each do |rp|
    module procedure FILE_put_associatedCoordinate_real<%=rp%>_<%=n%>D
%   end
% end
  end interface FILE_put_associatedCoordinate
  interface FILE_write_associatedCoordinate
% for n in 1..4
%   %w(SP DP).each do |rp|
    module procedure FILE_write_associatedCoordinate_Real<%=rp%>_<%=n%>D
%   end
% end
  end interface FILE_write_associatedCoordinate
  interface FILE_add_variable
     module procedure FILE_add_variable_no_time
     module procedure FILE_add_variable_realSP
     module procedure FILE_add_variable_realDP
  end interface FILE_add_variable
  interface FILE_read
% for n in 1..4
%   %w(SP DP).each do |rp|
    module procedure FILE_read_real<%=rp%>_<%=n%>D
%   end
% end
% for n in 1..4
%   %w(SP DP).each do |rp|
    module procedure FILE_read_var_real<%=rp%>_<%=n%>D
%   end
% end
  end interface FILE_read
  interface FILE_write
% for n in 1..4
%   %w(SP DP).each do |rp|
    module procedure FILE_write_real<%=rp%>_<%=n%>D
%   end
% end
  end interface FILE_write
  interface FILE_get_attribute
     module procedure FILE_get_attribute_text_fname
     module procedure FILE_get_attribute_int_fname
     module procedure FILE_get_attribute_float_fname
     module procedure FILE_get_attribute_double_fname
     module procedure FILE_get_attribute_text_fid
     module procedure FILE_get_attribute_int_fid
     module procedure FILE_get_attribute_float_fid
     module procedure FILE_get_attribute_double_fid
  end interface FILE_get_attribute
  interface FILE_set_attribute
     module procedure FILE_set_attribute_text
     module procedure FILE_set_attribute_int
     module procedure FILE_set_attribute_float
     module procedure FILE_set_attribute_double
  end interface FILE_set_attribute

  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  logical, public :: FILE_AGGREGATE = .false. !> do parallel I/O through PnetCDF (default setting)

  !-----------------------------------------------------------------------------
  !
  !++ Private procedures
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private parameters & variables
  !
  type file
     character(len=FILE_HLONG) :: name
     integer                   :: fid
     logical                   :: aggregate
  end type file
  type(file) :: FILE_files(FILE_FILE_MAX)
  integer    :: FILE_nfiles = 0

  type var
  character(len=FILE_HLONG) :: name
  integer                   :: fid
  integer                   :: vid
  end type var
  type(var) :: FILE_vars(FILE_VAR_MAX)
  integer   :: FILE_nvars = 0

  integer                   :: mpi_myrank

  !-----------------------------------------------------------------------------
contains
  !-----------------------------------------------------------------------------
  !> setup
  !-----------------------------------------------------------------------------
  subroutine FILE_setup( &
       myrank )
    use scale_process, only: &
       PRC_set_file_closer
    implicit none

    integer, intent(in) :: myrank

    NAMELIST / PARAM_FILE / &
         FILE_AGGREGATE
    
    integer :: ierr

       !--- read namelist
    rewind(IO_FID_CONF)
    read(IO_FID_CONF,nml=PARAM_FILE,iostat=ierr)
    if( ierr < 0 ) then !--- missing
       if( IO_L ) write(IO_FID_LOG,*) '*** Not found namelist. Default used.'
    elseif( ierr > 0 ) then !--- fatal error
       write(*,*) 'xxx Not appropriate names in namelist PARAM_FILE. Check!'
       call PRC_abort
    endif
    if( IO_NML ) write(IO_FID_NML,nml=PARAM_FILE)

    mpi_myrank = myrank

    call PRC_set_file_closer( FILE_CLOSE_ALL )

    return
  end subroutine FILE_setup

  !-----------------------------------------------------------------------------
  subroutine FILE_create( &
       fid,         &
       existed,     &
       basename,    &
       title,       &
       source,      &
       institution, &
       grid_name,   &
       rankid,      &
       ismaster,    &
       single,      &
       time_units,  &
       append,      &
       mpi_comm     )
    use mpi, only: &
       MPI_COMM_NULL
    implicit none

    integer,          intent(out) :: fid
    logical,          intent(out) :: existed
    character(len=*), intent(in)  :: basename
    character(len=*), intent(in)  :: title
    character(len=*), intent(in)  :: source
    character(len=*), intent(in)  :: institution
    character(len=*), intent(in)  :: grid_name

    integer,          intent(in), optional :: rankid
    logical,          intent(in), optional :: ismaster
    logical,          intent(in), optional :: single
    character(len=*), intent(in), optional :: time_units
    logical,          intent(in), optional :: append
    integer,          intent(in), optional :: mpi_comm !> MPI communicator. If this is set, files are aggregated used by PnetCDF

    character(len=FILE_HMID) :: time_units_
    integer :: rankid_
    logical :: single_
    integer :: mode

    integer :: error
    !---------------------------------------------------------------------------


    if ( present(rankid) ) then
       rankid_ = rankid
    else
       rankid_ = mpi_myrank
    end if

    single_ = .false.
    if ( present(single) ) then
       if ( single ) then
          if ( present( ismaster ) ) then
             if ( .not. ismaster ) return
          else
             write(*,*) 'xxx [FILE_create] ismaster is required if single == .true.'
             call PRC_abort
          end if
       end if
       single_ = single
    endif

    if ( present(time_units) ) then
       time_units_ = time_units
    else
       time_units_ = 'seconds'
    endif

    mode = FILE_FWRITE
    if ( present(append) ) then
       if( append ) mode = FILE_FAPPEND
    endif

    call FILE_get_fid( fid,      & ! [OUT]
                       existed,  & ! [OUT]
                       basename, & ! [IN]
                       mode,     & ! [IN]
                       rankid_,  & ! [IN]
                       single_,  & ! [IN]
                       mpi_comm  ) ! [IN]

    if( existed ) return

    !--- append package header to the file
    call FILE_set_attribute( fid, "global", "title"      , title       ) ! [IN]
    call FILE_set_attribute( fid, "global", "source"     , source      ) ! [IN]
    call FILE_set_attribute( fid, "global", "institution", institution ) ! [IN]
    call FILE_set_attribute( fid, "global", "grid_name",   grid_name   ) ! [IN]

    if ( ( .not. present(mpi_comm) ) .or. mpi_comm == MPI_COMM_NULL ) then
       ! for shared-file parallel I/O, skip attributes related to MPI processes
       call FILE_set_attribute( fid, "global", "rankid"  , (/rankid/)  ) ! [IN]
    endif

    call file_set_tunits_c( FILE_files(fid)%fid, & ! [IN]
                            time_units_,         & ! [IN]
                            error                ) ! [OUT]

    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx [FILE_create] failed to set time units'
       call PRC_abort
    endif

    return
  end subroutine FILE_create

  !-----------------------------------------------------------------------------
  subroutine FILE_get_var_num( &
       fid,         &
       nvars_limit, &
       nvars        )
    implicit none

    integer, intent(in)  :: fid
    integer, intent(in)  :: nvars_limit
    integer, intent(out) :: nvars

    integer :: error
    !---------------------------------------------------------------------------

    call file_get_nvars_c( FILE_files(fid)%fid, & ! (in)
                           nvars, error         ) ! (out)

    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx [FILE_get_var_num] failed to get varnum. fid = ', fid
       call PRC_abort
    end if

    if ( nvars > nvars_limit ) then
       write(*,*) 'xxx [FILE_get_var_num] number of variables exceeds the requested size.', nvars, nvars_limit
       call PRC_abort
    endif

    return
  end subroutine FILE_get_var_num

  !-----------------------------------------------------------------------------
  subroutine FILE_get_var_name( &
       fid,    &
       cvid,   &
       varname )
    implicit none

    integer,          intent(in)  :: fid
    integer,          intent(in)  :: cvid
    character(len=*), intent(out) :: varname

    integer :: error
    !---------------------------------------------------------------------------

    call file_get_varname_c( FILE_files(fid)%fid, cvid, & ! (in)
                             varname, error             ) ! (out)

    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx [FILE_get_var_name] failed to get varname. cvid = ', cvid
       call PRC_abort
    end if

    return
  end subroutine FILE_get_var_name

  !-----------------------------------------------------------------------------
  subroutine FILE_add_associatedvariable( fid, vname, existed )
    integer,           intent(in)  :: fid
    character(len=*),  intent(in)  :: vname
    logical, optional, intent(out) :: existed

    integer :: error

    call file_add_associatedvariable_c( FILE_files(fid)%fid, vname , & ! (in)
                                        error                        ) ! (out)

    if ( present(existed) ) then
       if ( error == FILE_ALREADY_EXISTED_CODE ) then
          existed = .true.
          return
       end if
       existed = .false.
    end if

    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to add associated variable: '//trim(vname)
       call PRC_abort
    end if

    return
  end subroutine FILE_add_associatedvariable

  !-----------------------------------------------------------------------------
  subroutine FILE_set_option( &
       fid,      & ! (in)
       filetype, & ! (in)
       key,      & ! (in)
       val       & ! (in)
       )
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: filetype
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer :: error

    call file_set_option_c( FILE_files(fid)%fid, filetype, key, val, & ! (in)
                            error                                    ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to set option'
       call PRC_abort
    end if

    return
  end subroutine FILE_set_option

  !-----------------------------------------------------------------------------
  subroutine FILE_open( &
      fid,       &
      basename,  &
      mode,      &
      single,    &
      mpi_comm,  &
      rankid     )
    implicit none

    integer,          intent(out) :: fid
    character(len=*), intent( in) :: basename
    integer,          intent( in) :: mode
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: mpi_comm
    integer,          intent( in), optional :: rankid

    integer :: rankid_
    logical :: existed
    logical :: single_

    single_ = .false.

    if ( present(single) ) single_ = single
    if ( present(rankid) ) then
       rankid_ = rankid
    else
       rankid_ = mpi_myrank
    end if

    call FILE_get_fid( fid, existed,                              & ! (out)
                       basename, mode, rankid_, single_, mpi_comm ) ! (in)

    return
  end subroutine FILE_open

  !-----------------------------------------------------------------------------
  ! interface FILE_PutAxis
  !-----------------------------------------------------------------------------
% ["SP", "DP"].each do |rp|
  subroutine FILE_put_axis_real<%=rp%>( &
       fid,      & ! (in)
       name,     & ! (in)
       desc,     & ! (in)
       units,    & ! (in)
       dim_name, & ! (in)
       dtype,    & ! (in)
       val       ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_name
    integer,          intent(in) :: dtype
    real(<%=rp%>),    intent(in) :: val(:)

    integer :: error
    intrinsic size

    call file_put_axis_c( FILE_files(fid)%fid,                        & ! (in)
         name, desc, units, dim_name, dtype, val, size(val), <%=rp%>, & ! (in)
         error                                                        ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put axis'
       call PRC_abort
    end if

    return
  end subroutine FILE_put_axis_real<%=rp%>
%end

  subroutine FILE_def_axis( &
       fid,      & ! (in)
       name,     & ! (in)
       desc,     & ! (in)
       units,    & ! (in)
       dim_name, & ! (in)
       dtype,    & ! (in)
       dim_size  ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_name
    integer,          intent(in) :: dtype
    integer,          intent(in) :: dim_size

    integer :: error

    call file_def_axis_c( FILE_files(fid)%fid, &
         name, desc, units, dim_name, dtype, dim_size, & ! (in)
         error                                         ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to define axis'
       call PRC_abort
    end if

    return
  end subroutine FILE_def_axis

  !-----------------------------------------------------------------------------
  ! interface FILE_WriteAxis
  !-----------------------------------------------------------------------------
% ["SP", "DP"].each do |rp|
  subroutine FILE_write_axis_real<%=rp%>( &
       fid,      & ! (in)
       name,     & ! (in)
       val,      & ! (in)
       start     ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(<%=rp%>),    intent(in)           :: val(:)
    integer,          intent(in), optional :: start(:)

    integer :: error
    intrinsic shape

    if ( present(start) ) then
       call file_write_axis_c( FILE_files(fid)%fid, & ! (in)
            name, val, <%=rp%>, start, shape(val),  & ! (in)
            error                                   ) ! (out)
    else
       call file_write_axis_c( FILE_files(fid)%fid, & ! (in)
            name, val, <%=rp%>, (/1/), shape(val),  & ! (in)
            error                                   ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to write axis: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_write_axis_real<%=rp%>
%end

  !-----------------------------------------------------------------------------
  ! interface FILE_put_associatedCoordinate
  !-----------------------------------------------------------------------------
% for n in 1..4
%   ["SP", "DP"].each do |rp|
  subroutine FILE_put_associatedCoordinate_real<%=rp%>_<%=n%>D( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype,     & ! (in)
       val        ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype
    real(<%=rp%>),    intent(in) :: val(<%=Array.new(n){":"}.join(",")%>)

    integer :: error
    intrinsic size

    call file_put_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         val, <%=rp%>,                                         & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_put_associatedCoordinate_real<%=rp%>_<%=n%>D
%  end
% end

  subroutine FILE_def_associatedCoordinate( &
       fid,       & ! (in)
       name,      & ! (in)
       desc,      & ! (in)
       units,     & ! (in)
       dim_names, & ! (in)
       dtype      ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim_names(:)
    integer,          intent(in) :: dtype

    integer :: error
    intrinsic size

    call file_def_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
         name, desc, units, dim_names, size(dim_names), dtype, & ! (in)
         error                                                 ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_def_associatedCoordinate

  !-----------------------------------------------------------------------------
  ! interface FILE_write_associatedCoordinate
  !-----------------------------------------------------------------------------
% for n in 1..4
%   ["SP", "DP"].each do |rp|
  subroutine FILE_write_associatedCoordinate_real<%=rp%>_<%=n%>D( &
       fid,       & ! (in)
       name,      & ! (in)
       val,       & ! (in)
       start,     & ! (in)
       count,     & ! (in)
       ndims      ) ! (in)
    integer,          intent(in)           :: fid
    character(len=*), intent(in)           :: name
    real(<%=rp%>),    intent(in)           :: val(<%=Array.new(n){":"}.join(",")%>)
    integer,          intent(in), optional :: start(:)
    integer,          intent(in), optional :: count(:)  ! in case val has been reshaped
    integer,          intent(in), optional :: ndims     ! in case val has been reshaped

    integer :: error
    intrinsic shape

    if ( present(ndims) ) then
       ! Note this is called for history coordinates which have been reshaped
       ! from 2D/3D into 1D array. In this case, start and count must be also present
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, <%=rp%>,                                     & ! (in)
            ndims, start, count,                                    & ! (in)
            error                                                   ) ! (out)
    else if ( present(start) ) then
       ! Note this is called for restart coordinates
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, <%=rp%>,                                     & ! (in)
            <%=n%>, start, shape(val),                              & ! (in)
            error                                                   ) ! (out)
    else
       ! Note this is for the one-file-per-process I/O method
       call file_write_associatedcoordinate_c( FILE_files(fid)%fid, & ! (in)
            name, val, <%=rp%>,                                     & ! (in)
            <%=n%>, (/<%=([1]*n).join(",")%>/), shape(val),         & ! (in)
            error                                                   ) ! (out)
    end if
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to put associated coordinate: '//trim(name)
       call PRC_abort
    end if

    return
  end subroutine FILE_write_associatedCoordinate_real<%=rp%>_<%=n%>D
%  end
% end

  !-----------------------------------------------------------------------------
  ! interface FILE_add_variable
  !-----------------------------------------------------------------------------
  subroutine FILE_add_variable_no_time( &
       vid,     & ! (out)
       fid,     & ! (in)
       varname, & ! (in)
       desc,    & ! (in)
       units,   & ! (in)
       dims,    & ! (in)
       dtype,   & ! (in)
       tavg     & ! (in) optional
       )
    integer,          intent(out) :: vid
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    logical,          intent( in), optional :: tavg

    call FILE_add_variable_realDP(vid, fid, varname, desc, units, dims, dtype, -1.0_DP, tavg )

    return
  end subroutine FILE_add_variable_no_time

% ["SP", "DP"].each do |rp|
  !-----------------------------------------------------------------------------
  subroutine FILE_add_variable_real<%=rp%>( &
       vid,     &
       fid,     &
       varname, &
       desc,    &
       units,   &
       dims,    &
       dtype,   &
       tint,    &
       tavg     )
    implicit none

    integer,          intent(out) :: vid
    integer,          intent(in)  :: fid
    character(len=*), intent(in)  :: varname
    character(len=*), intent(in)  :: desc
    character(len=*), intent(in)  :: units
    character(len=*), intent(in)  :: dims(:)
    integer,          intent(in)  :: dtype
    real(<%=rp%>),    intent(in)  :: tint

    logical,          intent(in), optional :: tavg

    real(DP) :: tint8
    integer  :: cvid
    integer  :: ndims
    integer  :: itavg
    integer  :: error
    integer  :: n

    intrinsic size
    !---------------------------------------------------------------------------

    vid = -1
    do n = 1, FILE_nvars
       if ( FILE_vars(n)%fid == fid .and. FILE_vars(n)%name == varname ) then
          vid = FILE_vars(n)%vid
          exit
       endif
    enddo

    if ( vid < 0 ) then ! variable registration

       tint8 = real(tint,DP)
       ndims = size(dims)
       itavg = 0

       if ( present(tavg) ) then
          if( tavg ) itavg = 1
       endif

       call file_add_variable_c( cvid,                              & ! [OUT]
                                 FILE_files(fid)%fid,              & ! [IN]
                                 varname, desc, units,             & ! [IN]
                                 dims, ndims, dtype, tint8, itavg, & ! [IN]
                                 error                             ) ! [OUT]

       if ( error /= FILE_SUCCESS_CODE ) then
          write(*,*) 'xxx failed to add variable: '//trim(varname)
          call PRC_abort
       endif

       FILE_nvars = FILE_nvars + 1
       vid = FILE_nvars
       FILE_vars(vid)%name = varname
       FILE_vars(vid)%vid  = cvid
       FILE_vars(vid)%fid  = fid

       if (IO_L) write(IO_FID_LOG,'(A,I3.3,A,I4.4,2A)') &
       '###### FILE variable registration : NO.', fid, ', vid = ', vid, ', name = ', trim(varname)
    endif

    return
  end subroutine FILE_add_variable_real<%=rp%>

%end
  subroutine FILE_def_variable( &
       fid,      & ! (in)
       varname,  & ! (in)
       desc,     & ! (in)
       units,    & ! (in)
       ndims,    & ! (in)
       dims,     & ! (in)
       dtype,    & ! (in)
       vid,      & ! (out)
       timeintv, & ! (in) optional
       timeavg   ) ! (in) optional
    integer,          intent( in) :: fid
    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    integer,          intent( in) :: ndims
    character(len=*), intent( in) :: dims(:)
    integer,          intent( in) :: dtype
    integer,          intent(out) :: vid
    real(DP),         intent( in), optional :: timeintv
    logical,          intent( in), optional :: timeavg

    real(DP) :: tint_
    integer  :: itavg
    integer  :: cvid
    integer  :: error
    integer  :: n

    !---------------------------------------------------------------------------

    vid = -1
    do n = 1, FILE_nvars
       if ( FILE_vars(n)%fid == fid .and. FILE_vars(n)%name == varname ) then
          vid = n
       end if
    enddo

    if ( vid < 0 ) then ! variable registration

       if ( present(timeintv) ) then
          tint_ = timeintv
       else
          tint_ = -1.0_DP
       endif

       if ( present(timeavg) ) then
          if ( timeavg ) then
             itavg = 1
          else
             itavg = 0
          end if
       else
          itavg = 0
       end if

       call file_add_variable_c( cvid,                & ! (out)
            FILE_files(fid)%fid,                      & ! (in)
            varname, desc, units, dims, ndims, dtype, & ! (in)
            tint_, itavg,                             & ! (in)
            error                                     ) ! (out)
       if ( error /= FILE_SUCCESS_CODE ) then
          write(*,*) 'xxx failed to add variable: '//trim(varname)
          call PRC_abort
       end if

       FILE_nvars = FILE_nvars + 1
       vid = FILE_nvars
       FILE_vars(vid)%name = varname
       FILE_vars(vid)%vid  = cvid
       FILE_vars(vid)%fid  = fid

       if (IO_L) write(IO_FID_LOG,'(A,I3.3,A,I4.4,2A)') &
       '###### FILE_ variable registration : NO.', fid, ', vid = ', vid, ', name = ', trim(varname)
    endif

    return
  end subroutine FILE_def_variable

  !-----------------------------------------------------------------------------
  ! FILE_Get_Attribute
  !-----------------------------------------------------------------------------
  subroutine FILE_get_attribute_text_fid( &
       fid,   & ! (in)
       vname, & ! (in)
       key,   & ! (in)
       val    ) ! (out)
    integer,          intent(in ) :: fid
    character(len=*), intent(in ) :: vname
    character(len=*), intent(in ) :: key
    character(len=*), intent(out) :: val

    integer :: error

    call file_get_attribute_text_c( &
         FILE_files(fid)%fid, vname, & ! (in)
         key,                        & ! (in)
         val, error                  ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to get text attribute for '//trim(vname)//': '//trim(key)
       call PRC_abort
    end if

    return
  end subroutine FILE_get_attribute_text_fid
  subroutine FILE_get_attribute_text_fname( &
      basename,  & ! (in)
      vname,     & ! (in)
      key,       & ! (in)
      val,       & ! (out)
      single,    & ! (in) optional
      mpi_comm,  & ! (in) optional
      rankid     ) ! (in) optional
    implicit none

    character(len=*), intent(in) :: basename
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key

    character(len=*), intent(out) :: val

    logical, intent(in), optional :: single
    integer, intent(in), optional :: mpi_comm
    integer, intent(in), optional :: rankid

    integer :: fid

    call FILE_open( fid,          & ! (out)
         basename, FILE_FREAD,    & ! (in)
         single, mpi_comm, rankid ) ! (in) optional

    call FILE_get_attribute_text_fid( &
         fid, vname, key, & ! (in)
         val              ) ! (out)

    return
  end subroutine FILE_get_attribute_text_fname

  !-----------------------------------------------------------------------------
  subroutine FILE_get_attribute_int_fid( &
       fid,   & ! (in)
       vname, & ! (in)
       key,   & ! (in)
       val    ) ! (out)
    integer,          intent(in ) :: fid
    character(len=*), intent(in ) :: vname
    character(len=*), intent(in ) :: key
    integer,          intent(out) :: val(:)

    integer :: error

    intrinsic size

    call file_get_attribute_int_c( &
         FILE_files(fid)%fid, vname, & ! (in)
         key, size(val),             & ! (in)
         val, error                  ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to get integer attribute for '//trim(vname)//': '//trim(key)
       call PRC_abort
    end if

    return
  end subroutine FILE_get_attribute_int_fid
  subroutine FILE_get_attribute_int_fname( &
      basename,  & ! (in)
      vname,     & ! (in)
      key,       & ! (in)
      val,       & ! (out)
      single,    & ! (in) optional
      mpi_comm,  & ! (in) optional
      rankid     ) ! (in) optional
    implicit none

    character(len=*), intent(in) :: basename
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key

    integer, intent(out) :: val(:)

    logical, intent(in), optional :: single
    integer, intent(in), optional :: mpi_comm
    integer, intent(in), optional :: rankid

    integer :: fid

    call FILE_open( fid,          & ! (out)
         basename, FILE_FREAD,    & ! (in)
         single, mpi_comm, rankid ) ! (in) optional

    call FILE_get_attribute_int_fid( &
         fid, vname, key, & ! (in)
         val              ) ! (out)

    return
  end subroutine FILE_get_attribute_int_fname
  !-----------------------------------------------------------------------------

% [["SP","float"], ["DP","double"]].each do |rp,name|
  subroutine FILE_get_attribute_<%=name%>_fid( &
       fid,   & ! (in)
       vname, & ! (in)
       key,   & ! (in)
       val    ) ! (out)
    integer,          intent(in ) :: fid
    character(len=*), intent(in ) :: vname
    character(len=*), intent(in ) :: key
    real(<%=rp%>),    intent(out) :: val(:)

    integer :: error

    intrinsic size

    call file_get_attribute_<%=name%>_c( &
         FILE_files(fid)%fid, vname, & ! (in)
         key, size(val),             & ! (in)
         val, error                  ) ! (out)
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to get <%=name%> attribute for '//trim(vname)//': '//trim(key)
       call PRC_abort
    end if

    return
  end subroutine FILE_get_attribute_<%=name%>_fid
  subroutine FILE_get_attribute_<%=name%>_fname( &
      basename,  & ! (in)
      vname,     & ! (in)
      key,       & ! (in)
      val,       & ! (out)
      single,    & ! (in) optional
      mpi_comm,  & ! (in) optional
      rankid     ) ! (in) optional
    implicit none

    character(len=*), intent(in) :: basename
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key

    real(<%=rp%>), intent(out) :: val(:)

    logical, intent(in), optional :: single
    integer, intent(in), optional :: mpi_comm
    integer, intent(in), optional :: rankid

    integer :: fid

    call FILE_open( fid,          & ! (out)
         basename, FILE_FREAD ,   & ! (in)
         single, mpi_comm, rankid ) ! (in) optional

    call FILE_get_attribute_<%=name%>_fid( &
         fid, vname, key, & ! (in)
         val              ) ! (out)

    return
  end subroutine FILE_get_attribute_<%=name%>_fname
%end

  !-----------------------------------------------------------------------------
  ! FILE_set_attribute
  !-----------------------------------------------------------------------------
  subroutine FILE_set_attribute_text( &
     fid,   & ! (in)
     vname, & ! (in)
     key,   & ! (in)
     val    ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key
    character(len=*), intent(in) :: val

    integer :: error

    call file_set_attribute_text_c( &
         FILE_files(fid)%fid, vname, & ! (in)
         key, val,                   & ! (in)
         error                       ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to set text attribute for '//trim(vname)//': '//trim(key)
       call PRC_abort
    end if

    return
  end subroutine FILE_set_attribute_text

  !-----------------------------------------------------------------------------
  subroutine FILE_set_attribute_int( &
     fid,   & ! (in)
     vname, & ! (in)
     key,   & ! (in)
     val    ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key
    integer,          intent(in) :: val(:)

    integer :: error

    intrinsic size

    call file_set_attribute_int_c( &
         FILE_files(fid)%fid, vname, & ! (in)
         key, val(:), size(val(:)),  & ! (in)
         error                       ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to set integer attribute for '//trim(vname)//': '//trim(key)
       call PRC_abort
    end if

    return
  end subroutine FILE_set_attribute_int

% [["SP","float"], ["DP","double"]].each do |rp,name|
  !-----------------------------------------------------------------------------
  subroutine FILE_set_attribute_<%=name%>( &
     fid,   & ! (in)
     vname, & ! (in)
     key,   & ! (in)
     val    ) ! (in)
    integer,          intent(in) :: fid
    character(len=*), intent(in) :: vname
    character(len=*), intent(in) :: key
    real(<%=rp%>),    intent(in) :: val(:)

    integer :: error

    intrinsic size

    call file_set_attribute_<%=name%>_c( &
         FILE_files(fid)%fid, vname, & ! (in)
         key, val(:), size(val(:)),  & ! (in)
         error                       ) ! (out)
    if ( error /= FILE_SUCCESS_CODE .and. error /= FILE_ALREADY_EXISTED_CODE ) then
       write(*,*) 'xxx failed to set <%=name%> attribute for '//trim(vname)//': '//trim(key)
       call PRC_abort
    end if

    return
  end subroutine FILE_set_attribute_<%=name%>
%end
  !-----------------------------------------------------------------------------
  ! FILE_get_shape
  !-----------------------------------------------------------------------------
  subroutine FILE_get_shape( &
      dims,          & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      rankid,        & ! (in)
      single,        & ! (in) optional
      error          ) ! (out) optional
    implicit none

    integer,          intent(out)           :: dims(:)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: rankid
    logical,          intent( in), optional :: single
    logical,          intent(out), optional :: error

    integer :: fid
    type(datainfo) :: dinfo
    integer :: ierror
    integer :: n

    logical :: single_
    logical :: suppress

    intrinsic size
    !---------------------------------------------------------------------------

    if ( present(single) ) then
       single_ = single
    else
       single_ = .false.
    end if

    if ( present(error) ) then
       suppress = .true.
    else
       suppress = .false.
    end if

    !--- search/register file
    call FILE_open( fid,                          & ! (out)
                    basename, FILE_FREAD,         & ! (in)
                    rankid=rankid, single=single_ ) ! (in)

    !--- get data information
    call file_get_datainfo_c( dinfo,   & ! (out)
         FILE_files(fid)%fid, varname, & ! (in)
         1, suppress,                  & ! (in)
         ierror                        ) ! (out)

    !--- verify
    if ( ierror /= FILE_SUCCESS_CODE ) then
       if ( present(error) ) then
          error = .true.
          return
       else
          write(*,*) 'xxx failed to get data information :'//trim(varname)
          call PRC_abort
       end if
    end if

    if ( dinfo%rank /= size(dims) ) then
       write(*,*) 'xxx rank is different, ', size(dims), dinfo%rank
       call PRC_abort
    end if
    do n = 1, size(dims)
       dims(n) = dinfo%dim_size(n)
    end do

    if ( present(error) ) error = .false.

    return
  end subroutine FILE_get_shape

  !-----------------------------------------------------------------------------
  ! FILE_get_commonInfo
  !-----------------------------------------------------------------------------
  subroutine FILE_get_commonInfo_fname( &
       basename,    &
       rankid,      &
       nvars_limit, &
       title,       &
       source,      &
       institution, &
       grid_name,   &
       nvars,       &
       varname      )
    implicit none

    character(len=*),           intent(in)  :: basename
    integer,                    intent(in)  :: rankid
    integer,                    intent(in)  :: nvars_limit
    character(len=FILE_HMID),   intent(out) :: title                ! title of the file
    character(len=FILE_HMID),   intent(out) :: source               ! for file header
    character(len=FILE_HMID),   intent(out) :: institution          ! for file header
    character(len=FILE_HSHORT), intent(out) :: grid_name            ! for file header
    integer,                    intent(out) :: nvars                ! number of variables
    character(len=FILE_HSHORT), intent(out) :: varname(nvars_limit) ! name of variables

    integer :: fid
    !---------------------------------------------------------------------------

    call FILE_open( fid,                  & ! [OUT]
                    basename, FILE_FREAD, & ! [IN]
                    rankid=rankid         ) ! [IN]

    call FILE_get_commonInfo_fid( fid,         & ! [IN]
                                  nvars_limit, & ! [IN]
                                  title,       & ! [OUT]
                                  source,      & ! [OUT]
                                  institution, & ! [OUT]
                                  grid_name,   & ! [OUT]
                                  nvars,       & ! [OUT]
                                  varname(:)   ) ! [OUT]

    return
  end subroutine FILE_get_commonInfo_fname

  subroutine FILE_get_commonInfo_fid( &
       fid,         &
       nvars_limit, &
       title,       &
       source,      &
       institution, &
       grid_name,   &
       nvars,       &
       varname      )
    implicit none

    integer,                    intent(in)  :: fid
    integer,                    intent(in)  :: nvars_limit
    character(len=FILE_HMID),   intent(out) :: title                ! title of the file
    character(len=FILE_HMID),   intent(out) :: source               ! for file header
    character(len=FILE_HMID),   intent(out) :: institution          ! for file header
    character(len=FILE_HSHORT), intent(out) :: grid_name            ! for file header
    integer,                    intent(out) :: nvars                ! number of variables
    character(len=FILE_HSHORT), intent(out) :: varname(nvars_limit) ! name of variables

    integer :: v
    !---------------------------------------------------------------------------

    call FILE_get_attribute( fid, 'global', 'title',       title       )
    call FILE_get_attribute( fid, 'global', 'source',      source      )
    call FILE_get_attribute( fid, 'global', 'institution', institution )
    call FILE_get_attribute( fid, 'global', 'grid_name',   grid_name   )

    call FILE_get_var_num( fid, nvars_limit, nvars )

    do v = 1, nvars
       call FILE_get_var_name( fid, v, varname(v) )
    enddo

    return
  end subroutine FILE_get_commonInfo_fid

  !-----------------------------------------------------------------------------
  ! FILE_get_dataInfo
  !-----------------------------------------------------------------------------
  subroutine FILE_get_dataInfo_fname( &
       basename,    &
       varname,     &
       rankid,      &
       istep,       &
       single,      &
       description, &
       units,       &
       datatype,    &
       dim_rank,    &
       dim_name,    &
       dim_size,    &
       time_start,  &
       time_end,    &
       time_units   )
    implicit none

    character(len=*),           intent(in)  :: basename
    character(len=*),           intent(in)  :: varname
    integer,                    intent(in)  :: rankid
    integer,                    intent(in)  :: istep

    logical,                    intent(in),  optional :: single
    character(len=FILE_HMID),   intent(out), optional :: description
    character(len=FILE_HSHORT), intent(out), optional :: units
    integer,                    intent(out), optional :: datatype
    integer,                    intent(out), optional :: dim_rank
    character(len=FILE_HSHORT), intent(out), optional :: dim_name(:)
    integer,                    intent(out), optional :: dim_size(:)
    real(DP),                   intent(out), optional :: time_start
    real(DP),                   intent(out), optional :: time_end
    character(len=FILE_HMID),   intent(out), optional :: time_units

    logical :: single_
    integer :: fid
    !---------------------------------------------------------------------------

    if ( present(single) ) then
       single_ = single
    else
       single_ = .false.
    endif

    !--- search/register file
    call FILE_open( fid,                          & ! [OUT]
                    basename, FILE_FREAD,         & ! [IN]
                    rankid=rankid, single=single_ ) ! [IN]

    call FILE_get_dataInfo_fid( fid,         & ! [IN]
                                varname,     & ! [IN]
                                istep,       & ! [IN]
                                description, & ! [OUT], optional
                                units,       & ! [OUT], optional
                                datatype,    & ! [OUT], optional
                                dim_rank,    & ! [OUT], optional
                                dim_name,    & ! [OUT], optional
                                dim_size,    & ! [OUT], optional
                                time_start,  & ! [OUT], optional
                                time_end,    & ! [OUT], optional
                                time_units   ) ! [OUT], optional

    return
  end subroutine FILE_get_dataInfo_fname

  subroutine FILE_get_dataInfo_fid( &
       fid,         &
       varname,     &
       istep,       &
       description, &
       units,       &
       datatype,    &
       dim_rank,    &
       dim_name,    &
       dim_size,    &
       time_start,  &
       time_end,    &
       time_units   )
    implicit none

    integer,                    intent(in)  :: fid
    character(len=*),           intent(in)  :: varname
    integer,                    intent(in)  :: istep

    character(len=FILE_HMID),   intent(out), optional :: description
    character(len=FILE_HSHORT), intent(out), optional :: units
    integer,                    intent(out), optional :: datatype
    integer,                    intent(out), optional :: dim_rank
    character(len=FILE_HSHORT), intent(out), optional :: dim_name(:)
    integer,                    intent(out), optional :: dim_size(:)
    real(DP),                   intent(out), optional :: time_start
    real(DP),                   intent(out), optional :: time_end
    character(len=FILE_HMID),   intent(out), optional :: time_units

    type(datainfo) :: dinfo

    real(DP) :: time(1)
    integer  :: ndim, idim
    integer  :: error

    intrinsic size
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo_c( dinfo,               & ! [OUT]
                              FILE_files(fid)%fid, & ! [IN]
                              varname,             & ! [IN]
                              istep,               & ! [IN]
                              .false.,             & ! [IN]
                              error                ) ! [OUT]

    !--- verify and exit
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx data info not found'
       call PRC_abort
    endif

    if( present(description) ) description = dinfo%description
    if( present(units)       ) units       = dinfo%units
    if( present(datatype)    ) datatype    = dinfo%datatype
    if( present(dim_rank)    ) dim_rank    = dinfo%rank

    if ( present(dim_name) ) then
       ndim = min( dinfo%rank, size(dim_name) ) ! limit dimension rank
       do idim = 1, ndim
          dim_name(idim) = dinfo%dim_name(idim)
       enddo
    endif

    if ( present(dim_size) ) then
       ndim = min( dinfo%rank, size(dim_size) ) ! limit dimension rank
       do idim = 1, ndim
          dim_size(idim) = dinfo%dim_size(idim)
       enddo
    endif

    if ( present(time_units)  ) then
       if ( dinfo%time_units == "" ) then
          call FILE_get_attribute( fid, "global", "time_units", time_units )
       else
          time_units = dinfo%time_units
       endif
    endif

    if ( present(time_start)  ) then
       if ( dinfo%time_units == "" ) then
          call FILE_get_Attribute( fid, "global", "time_start", time )
          time_start = time(1)
       else
          time_start = dinfo%time_start
       endif
    endif

    if ( present(time_end)  ) then
       if ( dinfo%time_units == "" ) then
          call FILE_get_Attribute( fid, "global", "time_start", time )
          time_end = time(1)
       else
          time_end = dinfo%time_end
       end if
    endif

    return
  end subroutine FILE_get_dataInfo_fid

  !-----------------------------------------------------------------------------
  ! FILE_get_data_all_dataInfo
  !-----------------------------------------------------------------------------
  subroutine FILE_get_all_dataInfo_fname( &
       step_limit,  &
       dim_limit,   &
       basename,    &
       varname,     &
       rankid,      &
       step_nmax,   &
       description, &
       units,       &
       datatype,    &
       dim_rank,    &
       dim_name,    &
       dim_size,    &
       time_start,  &
       time_end,    &
       time_units,  &
       single       )
    implicit none

    integer,                    intent(in)  :: step_limit
    integer,                    intent(in)  :: dim_limit
    character(len=*),           intent(in)  :: basename
    character(len=*),           intent(in)  :: varname
    integer,                    intent(in)  :: rankid
    integer,                    intent(out) :: step_nmax
    character(len=FILE_HMID),   intent(out) :: description
    character(len=FILE_HSHORT), intent(out) :: units
    integer,                    intent(out) :: datatype
    integer,                    intent(out) :: dim_rank
    character(len=FILE_HSHORT), intent(out) :: dim_name  (dim_limit)
    integer,                    intent(out) :: dim_size  (dim_limit)
    real(DP),                   intent(out) :: time_start(step_limit)
    real(DP),                   intent(out) :: time_end  (step_limit)
    character(len=FILE_HMID),   intent(out) :: time_units

    logical,                    intent(in), optional :: single

    integer :: fid
    logical :: single_
    !---------------------------------------------------------------------------

    if ( present(single) ) then
       single_ = single
    else
       single_ = .false.
    endif

    !--- search/register file
    call FILE_open( fid,                          & ! [OUT]
                    basename, FILE_FREAD,         & ! [IN]
                    rankid=rankid, single=single_ ) ! [IN]

    call FILE_get_all_datainfo_fid( step_limit,  & ! [IN]
                                    dim_limit,   & ! [IN]
                                    fid,         & ! [IN]
                                    varname,     & ! [IN]
                                    step_nmax,   & ! [OUT]
                                    description, & ! [OUT]
                                    units,       & ! [OUT]
                                    datatype,    & ! [OUT]
                                    dim_rank,    & ! [OUT]
                                    dim_name,    & ! [OUT]
                                    dim_size,    & ! [OUT]
                                    time_start,  & ! [OUT]
                                    time_end,    & ! [OUT]
                                    time_units   ) ! [OUT]

    return
  end subroutine FILE_get_all_dataInfo_fname

  subroutine FILE_get_all_dataInfo_fid( &
       step_limit,  &
       dim_limit,   &
       fid,         &
       varname,     &
       step_nmax,   &
       description, &
       units,       &
       datatype,    &
       dim_rank,    &
       dim_name,    &
       dim_size,    &
       time_start,  &
       time_end,    &
       time_units   )
    implicit none

    integer,                    intent(in)  :: step_limit
    integer,                    intent(in)  :: dim_limit
    integer,                    intent(in)  :: fid
    character(len=*),           intent(in)  :: varname
    integer,                    intent(out) :: step_nmax
    character(len=FILE_HMID),   intent(out) :: description
    character(len=FILE_HSHORT), intent(out) :: units
    integer,                    intent(out) :: datatype
    integer,                    intent(out) :: dim_rank
    character(len=FILE_HSHORT), intent(out) :: dim_name  (dim_limit)
    integer,                    intent(out) :: dim_size  (dim_limit)
    real(DP),                   intent(out) :: time_start(step_limit)
    real(DP),                   intent(out) :: time_end  (step_limit)
    character(len=FILE_HMID),   intent(out) :: time_units

    type(datainfo) :: dinfo

    real(DP) :: time(1)
    integer  :: ndim, idim
    integer  :: error

    integer  :: istep
    !---------------------------------------------------------------------------

    ! initialize
    description   = ""
    units         = ""
    datatype      = -1
    dim_rank      = -1
    dim_name  (:) = ""
    dim_size  (:) = -1
    time_start(:) = FILE_RMISS
    time_end  (:) = FILE_RMISS

    do istep = 1, step_limit
       !--- get data information
       call file_get_datainfo_c( dinfo,               & ! [OUT]
                                 FILE_files(fid)%fid, & ! [IN]
                                 varname,             & ! [IN]
                                 istep,               & ! [IN]
                                 .true.,              & ! [IN]
                                 error                ) ! [OUT]

       !--- verify and exit
       if ( error /= FILE_SUCCESS_CODE ) then
          step_nmax = istep - 1
          exit
       endif

       if ( istep == 1 ) then
          description = dinfo%description
          units       = dinfo%units
          datatype    = dinfo%datatype
          dim_rank    = dinfo%rank

          ndim = min( dinfo%rank, dim_limit ) ! limit dimension rank
          do idim = 1, ndim
             dim_name(idim) = dinfo%dim_name(idim)
             dim_size(idim) = dinfo%dim_size(idim)
          enddo

          if ( dinfo%time_units == "" ) then
             call FILE_get_attribute( fid, "global", "time_units", time_units )
             call FILE_get_attribute( fid, "global", "time_start", time )
             time_start(1) = time(1)
             time_end  (1) = time(1)
             step_nmax = 1
             exit
          else
             time_units    = dinfo%time_units
             time_start(1) = dinfo%time_start
             time_end  (1) = dinfo%time_end
          endif
       else
          time_start(istep) = dinfo%time_start
          time_end  (istep) = dinfo%time_end
       endif
    enddo

    return
  end subroutine FILE_get_all_dataInfo_fid

  !-----------------------------------------------------------------------------
  ! interface FILE_read
  !-----------------------------------------------------------------------------
% for d in 1..4
%   idx = ( [":"]*d ).join(",")
%   ["SP", "DP"].each do |rp|
  subroutine FILE_read_real<%=rp%>_<%=d%>D( &
      var,           & ! (out)
      basename,      & ! (in)
      varname,       & ! (in)
      step,          & ! (in)
      rankid,        & ! (in)
      allow_missing, & ! (in) optional
      single         & ! (in) optional
      )
    implicit none

    real(<%=rp%>),    intent(out)           :: var(<%=idx%>)
    character(len=*), intent( in)           :: basename
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    integer,          intent( in)           :: rankid
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single

    integer :: fid
    type(datainfo) :: dinfo
    integer :: dim_size(<%=d%>)
    integer :: error
    integer :: n

    logical :: single_

    intrinsic shape
    !---------------------------------------------------------------------------

    single_ = .false.

    if ( present(single) ) single_ = single

    !--- search/register file
    call FILE_open( fid,                          & ! (out)
                    basename, FILE_FREAD,         & ! (in)
                    rankid=rankid, single=single_ ) ! (in)

    call FILE_read_var_real<%=rp%>_<%=d%>D(          &
         var,                                        & ! (out)
         fid, varname, step,                         & ! (in)
         allow_missing=allow_missing, single=single_ ) ! (in)

    return
  end subroutine FILE_read_real<%=rp%>_<%=d%>D
%   end
% end

% for d in 1..4
%   idx = ( [":"]*d ).join(",")
%   ["SP", "DP"].each do |rp|
  subroutine FILE_read_var_real<%=rp%>_<%=d%>D( &
      var,           &
      fid,           &
      varname,       &
      step,          &
      allow_missing, &
      single,        &
      ntypes,        &
      dtype,         &
      start,         &
      count          )
    use MPI, only : MPI_COMM_NULL
    implicit none

    real(<%=rp%>),    intent(out)           :: var(<%=idx%>)
    integer,          intent( in)           :: fid
    character(len=*), intent( in)           :: varname
    integer,          intent( in)           :: step
    logical,          intent( in), optional :: allow_missing !--- if data is missing, set value to zero
    logical,          intent( in), optional :: single
    integer,          intent( in), optional :: ntypes      ! number of dtypes
    integer,          intent( in), optional :: dtype       ! MPI derived datatype for read buffer
    integer,          intent( in), optional :: start(:)    ! request starts to global variable
    integer,          intent( in), optional :: count(:)    ! request sizes to global variable

    type(datainfo) :: dinfo
    integer :: dim_size(<%=d%>)
    integer :: error
    integer :: n

    intrinsic size, shape
    !---------------------------------------------------------------------------

    !--- get data information
    call file_get_datainfo_c( dinfo,                  & ! (out)
         FILE_files(fid)%fid, varname, step, .false., & ! (in)
         error                                        ) ! (out)

    !--- verify
    if ( error /= FILE_SUCCESS_CODE ) then
       if ( present(allow_missing) ) then
          if ( allow_missing ) then
             if (IO_L) write(IO_FID_LOG,*) 'xxx [INPUT]/[FILE_] data not found! : ', &
                  'varname= ',trim(varname),', step=',step
             if (IO_L) write(IO_FID_LOG,*) 'xxx [INPUT]/[FILE_] Value is set to 0.'
             var(<%=idx%>) = 0.0_<%=rp%>
          else
             write(*,*) 'xxx failed to get data information :'//trim(varname)
             call PRC_abort
          end if
       else
          write(*,*) 'xxx failed to get data information :'//trim(varname)
          call PRC_abort
       end if
    end if

    if ( dinfo%rank /= <%=d%> ) then
       write(*,*) 'xxx rank is not <%=d%>', dinfo%rank
       call PRC_abort
    end if

    if (present(ntypes) ) then
       call file_read_data_c( var(<%=idx%>),             & ! (out)
            dinfo, <%=rp%>, ntypes, dtype, start(:), count(:), & ! (in)
            error                                        ) ! (out)
    else
       dim_size(:) = shape(var)
       do n = 1, <%=d%>
          if ( dinfo%dim_size(n) /= dim_size(n) ) then
             write(*,*) 'xxx shape is different: ', varname, n, dinfo%dim_size(n), dim_size(n)
             call PRC_abort
          end if
       end do
       if ( present(start) ) then
          call file_read_data_c( var(<%=idx%>),          & ! (out)
               dinfo, <%=rp%>, 0, 0, start(:), count(:), & ! (in)
               error                                     ) ! (out)
       else
          call file_read_data_c( var(<%=idx%>), & ! (out)
               dinfo, <%=rp%>, 0, 0, -1, -1,    & ! (in)
               error                            ) ! (out)
       end if
    end if
    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to get data value'
       call PRC_abort
    end if

    return
  end subroutine FILE_read_var_real<%=rp%>_<%=d%>D
%   end
% end

  !-----------------------------------------------------------------------------
  ! interface FILE_write
  !-----------------------------------------------------------------------------
% for d in 1..4
%   idx = ( [":"]*d ).join(",")
%   ["SP", "DP"].each do |rp|
  subroutine FILE_write_real<%=rp%>_<%=d%>D( &
      vid,     & ! (in)
      var,     & ! (in)
      t_start, & ! (in)
      t_end,   & ! (in)
% if d==1
      ndims,   & ! (in)
      count,   & ! (in)
% end
      start    ) ! (in)
    implicit none

    integer,  intent(in)           :: vid
    real(<%=rp%>), intent(in) :: var(<%=idx%>)
    real(DP), intent(in)           :: t_start
    real(DP), intent(in)           :: t_end
% if d==1
    integer,  intent(in), optional :: ndims    ! when var has been reshaped to 1D
    integer,  intent(in), optional :: count(:)
% end
    integer,  intent(in), optional :: start(:)
    real(DP) :: ts, te

    integer :: start_(<%=d%>)

    integer :: fid
    integer :: error, n

    intrinsic shape
    !---------------------------------------------------------------------------

    ts = t_start
    te = t_end

    fid = FILE_vars(vid)%fid
% if d==1
    if ( present(ndims) ) then
       ! history variable has been reshaped to 1D
       ! In this case, start and count must be present

       if ( .not. present(start) ) then
          write(*,*) 'start argument is neccessary when ndims is specified'
          call PRC_abort
       end if
       if ( .not. present(count) ) then
          write(*,*) 'count argument is neccessary when ndims is specified'
          call PRC_abort
       end if

       call file_write_data_c( FILE_files(fid)%fid, FILE_vars(vid)%vid, & ! (in)
            var(<%=idx%>), ts, te, <%=rp%>,                             & ! (in)
            ndims, start, count,                                        & ! (in)
            error                                                       ) ! (out)
    else
% end
       ! this is for restart variable which keeps its original shape
       if ( present(start) ) then
          start_(:) = start(:)
       else
          start_(:) = 1
       end if
       call file_write_data_c( FILE_files(fid)%fid, FILE_vars(vid)%vid, & ! (in)
            var(<%=idx%>), ts, te, <%=rp%>,                             & ! (in)
            <%=d%>, start_, shape(var),                                 & ! (in)
            error                                                       ) ! (out)
% if d==1
    end if
% end
    if ( error /= FILE_SUCCESS_CODE ) then
       do n = 1, FILE_nvars
          if ( FILE_vars(n)%vid == vid ) then
             write(*,*) 'xxx failed to write data: ', trim(FILE_vars(n)%name)
             exit
          end if
       enddo
       call PRC_abort
    end if

    return
  end subroutine FILE_write_real<%=rp%>_<%=d%>D
%   end
% end

  !-----------------------------------------------------------------------------
  ! exit netCDF define mode and enter data mode
  subroutine FILE_enddef( fid )
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    call file_enddef_c( FILE_files(fid)%fid, error )

    if ( error == FILE_SUCCESS_CODE ) then

       if (IO_L) write(IO_FID_LOG,*)
       if (IO_L) write(IO_FID_LOG,'(A,I3.3,2A)') &
            '###### FILE_ end define mode       : No.', fid, ', name = ', trim(FILE_files(fid)%name)

    else
       write(*,*) 'xxx failed to exit define mode'
       call PRC_abort
    end if

    return
  end subroutine FILE_enddef

  !-----------------------------------------------------------------------------
  ! This subroutine is used when PnetCDF I/O method is enabled
  subroutine FILE_attach_buffer( &
       fid,       & ! (in)
       buf_amount ) ! (in)
    implicit none

    integer, intent(in) :: fid
    integer, intent(in) :: buf_amount

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    call file_attach_buffer_c( FILE_files(fid)%fid, buf_amount, error )

    if ( error == FILE_SUCCESS_CODE ) then

       if (IO_L) write(IO_FID_LOG,*)
       if (IO_L) write(IO_FID_LOG,'(A,I3.3,3A,I10)') &
            '###### FILE_ attach buffer         : No.', fid, ', name = ', trim(FILE_files(fid)%name), &
            ', size = ', buf_amount
    else
       write(*,*) 'xxx failed to attach buffer in PnetCDF'
       call PRC_abort
    end if

    return
  end subroutine FILE_attach_buffer

  !-----------------------------------------------------------------------------
  ! This subroutine is used when PnetCDF I/O method is enabled
  subroutine FILE_detach_buffer( &
       fid        ) ! (in)
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    if ( FILE_files(fid)%fid < 0 ) return  ! already closed

    call file_detach_buffer_c( FILE_files(fid)%fid, error )

    if ( error == FILE_SUCCESS_CODE ) then

       if (IO_L) write(IO_FID_LOG,*)
       if (IO_L) write(IO_FID_LOG,'(A,I3.3,2A)') &
            '###### FILE_ detach buffer         : No.', fid, ', name = ', trim(FILE_files(fid)%name)

    else
       write(*,*) 'xxx failed to detach buffer in PnetCDF'
       call PRC_abort
    end if

    return
  end subroutine FILE_detach_buffer

  !-----------------------------------------------------------------------------
  ! This subroutine is used when PnetCDF I/O method is enabled
  subroutine FILE_flush( fid )
    implicit none

    integer, intent(in) :: fid

    integer :: error, n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    if ( FILE_files(fid)%fid < 0 ) return  ! already closed

    call file_flush_c( FILE_files(fid)%fid, error )

    if ( error == FILE_SUCCESS_CODE ) then

       if (IO_L) write(IO_FID_LOG,*)
       if (IO_L) write(IO_FID_LOG,'(A,I3.3,2A)') &
            '###### FILE_ flush                 : No.', fid, ', name = ', trim(FILE_files(fid)%name)

    else
       write(*,*) 'xxx failed to flush PnetCDF pending requests'
       call PRC_abort
    end if

    return
  end subroutine FILE_flush

  !-----------------------------------------------------------------------------
  subroutine FILE_close( fid )
    implicit none

    integer, intent(in) :: fid

    character(len=FILE_HLONG) :: fname
    integer                   :: error
    integer                   :: n
    !---------------------------------------------------------------------------

    if ( fid < 0 ) return

    if ( FILE_files(fid)%fid < 0 ) return  ! already closed

    call file_close_c( FILE_files(fid)%fid, error )

    if ( error == FILE_SUCCESS_CODE ) then

       if (IO_L) write(IO_FID_LOG,*)
       if (IO_L) write(IO_FID_LOG,'(A,I3.3,2A)') &
            '###### FILE_ close                 : No.', fid, ', name = ', trim(FILE_files(fid)%name)

    elseif( error /= FILE_ALREADY_CLOSED_CODE ) then
       write(*,*) 'xxx failed to close file'
       call PRC_abort

    end if

    FILE_files(fid)%fid = -1
    FILE_files(fid)%name = ''
    FILE_files(fid)%aggregate = .false.

    do n = 1, FILE_nvars
       if ( FILE_vars(n)%fid == fid ) then
          FILE_vars(n)%vid = -1
          FILE_vars(n)%name = ''
       end if
    end do

    return
  end subroutine FILE_close
  !-----------------------------------------------------------------------------
  subroutine FILE_close_all
    implicit none

    integer n
    !---------------------------------------------------------------------------

    do n = 1, FILE_nfiles
       call FILE_close( n )
    enddo

    return
  end subroutine FILE_close_all

  !-----------------------------------------------------------------------------
  ! private
  !-----------------------------------------------------------------------------
  subroutine FILE_make_fname( &
       fname,    & ! (out)
       basename, & ! (in)
       prefix,   & ! (in)
       rankid,   & ! (in)
       len       ) ! (in)
    character(len=*), intent(out) :: fname
    character(len=*), intent( in) :: basename
    character(len=*), intent( in) :: prefix
    integer,          intent( in) :: rankid
    integer,          intent( in) :: len

    !                           12345678901234567
    character(len=17) :: fmt = "(A, '.', A, I*.*)"
    !---------------------------------------------------------------------------

    if ( len < 1 .or. len > 9 ) then
       write(*,*) 'xxx [FILE_make_fname] len is invalid'
       call PRC_abort
    end if

    write(fmt(14:14),'(I1)') len
    write(fmt(16:16),'(I1)') len
    write(fname, fmt) trim(basename), trim(prefix), rankid

    return
  end subroutine FILE_make_fname
  !-----------------------------------------------------------------------------
  subroutine FILE_get_fid( &
      fid,        &
      existed,    &
      basename,   &
      mode,       &
      rankid,     &
      single,     &
      mpi_comm    )
    use MPI, only: &
      MPI_COMM_NULL
    implicit none

    integer,          intent(out) :: fid
    logical,          intent(out) :: existed
    character(len=*), intent( in) :: basename
    integer,          intent( in) :: mode
    integer,          intent( in) :: rankid
    logical,          intent( in) :: single
    integer,          intent( in), optional :: mpi_comm

    character(len=FILE_HSHORT) :: rwname(0:2)
    data rwname / 'READ','WRITE','APPEND' /

    character(len=FILE_HLONG) :: fname
    integer                   :: n

    logical :: aggregate
    integer :: cfid
    integer :: error
    integer :: mpi_comm_
    !---------------------------------------------------------------------------

    !--- check aggregate (parallel I/O on a single shared netCDF file)
    mpi_comm_ = MPI_COMM_NULL
    if ( present(mpi_comm) ) mpi_comm_ = mpi_comm

    aggregate = ( mpi_comm_ .ne. MPI_COMM_NULL )

    if ( aggregate ) then
       fname = basename
    elseif ( single ) then
       fname = trim(basename)//'.peall'
    else
       call FILE_make_fname(fname,trim(basename),'pe',rankid,6)
    endif

    !--- search existing file
    fid = -1
    do n = 1, FILE_nfiles
       if ( fname == FILE_files(n)%name ) then
          fid = n
          exit
       end if
    enddo

    if ( fid >= 0 ) then
       existed = .true.
       return
    end if

    call file_open_c( cfid,                   & ! (out)
                      fname, mode, mpi_comm_, & ! (in)
                      error                   ) ! (out)

    if ( error /= FILE_SUCCESS_CODE ) then
       write(*,*) 'xxx failed to open file :'//trim(fname)//'.nc'
       call PRC_abort
    end if

    if (IO_L) write(IO_FID_LOG,*)
    if (IO_L) write(IO_FID_LOG,'(A,A6,A,I3.3,2A)') &
         '###### FILE_ registration (', trim(rwname(mode)), ') : No.', fid, ', name = ', trim(fname)

    FILE_nfiles = FILE_nfiles + 1
    fid = FILE_nfiles
    FILE_files(fid)%name      = fname
    FILE_files(fid)%fid       = cfid
    FILE_files(fid)%aggregate = aggregate

    existed = .false.

    return
  end subroutine FILE_get_fid

  !-----------------------------------------------------------------------------
  !> get unit of time
  !-----------------------------------------------------------------------------
  subroutine FILE_get_CFtunits(tunits, date)
    implicit none

    character(len=*), intent(out) :: tunits
    integer,          intent(in)  :: date(6)
    !---------------------------------------------------------------------------

    write(tunits,'(a,i4.4,"-",i2.2,"-",i2.2," ",i2.2,":",i2.2,":",i2.2)') 'seconds since ', date

    return
  end subroutine FILE_get_CFtunits

  function FILE_get_aggregate( fid )
    integer, intent(in) :: fid
    logical :: FILE_get_aggregate

    if ( fid < 0 ) then
       FILE_get_aggregate = .false.
    else
       FILE_get_aggregate = FILE_files(fid)%aggregate
    end if

    return
  end function FILE_get_aggregate

end module scale_file
!-------------------------------------------------------------------------------


!--
! vi<%=":"%>set readonly sw=4 ts=8
!
!Local Variables<%=":"%>
!mode: f90
!buffer-read-only: t
!End:
!
!++
