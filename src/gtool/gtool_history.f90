!-------------------------------------------------------------------------------
!> module Gtool_History
!!
!! @par Description
!!          module library for history output 
!!
!! @author H.Tomita and SCALE developpers
!!
!! @par History
!! @li      2012-06-11 (S.Nishizawa)  [new] imported from SCALE-LES
!!
!<
!-------------------------------------------------------------------------------
! Warning: This file was generated from gtool_history.f90.erb.
!          Do not edit this file.
!-------------------------------------------------------------------------------
module gtool_history
  !-----------------------------------------------------------------------------
  !
  !++ Used modules
  !
  use dc_log, only: &
     Log, &
     LOG_LMSG
  use gtool_file_h, only: &
     File_HLONG, &
     File_HSHORT, &
     File_HMID
  !-----------------------------------------------------------------------------
  implicit none
  private
  !-----------------------------------------------------------------------------
  !
  !++ Public procedures
  !
  public :: HistoryInit
  public :: HistoryAddVariable
  public :: HistoryPutAxis
  public :: HistoryPutAdditionalAxis
  public :: HistoryPut
  public :: HistoryWrite
  public :: HistoryWriteAll
  public :: HistoryGet
  public :: HistoryOutputList
  public :: HistoryFinalize

  interface HistoryPutAxis
     module procedure HistoryPutAxisSP
     module procedure HistoryPutAxisDP
  end interface HistoryPutAxis

  interface HistoryPutAdditionalAxis
     module procedure HistoryPutAdditionalAxisSP
     module procedure HistoryPutAdditionalAxisDP
  end interface HistoryPutAdditionalAxis

  interface HistoryPut
     module procedure HistoryPut1DNameSP
     module procedure HistoryPut1DIdSP
     module procedure HistoryPut1DNameDP
     module procedure HistoryPut1DIdDP
     module procedure HistoryPut2DNameSP
     module procedure HistoryPut2DIdSP
     module procedure HistoryPut2DNameDP
     module procedure HistoryPut2DIdDP
     module procedure HistoryPut3DNameSP
     module procedure HistoryPut3DIdSP
     module procedure HistoryPut3DNameDP
     module procedure HistoryPut3DIdDP
  end interface HistoryPut

  interface HistoryWrite
     module procedure HistoryWriteSP
     module procedure HistoryWriteDP
  end interface HistoryWrite

  interface HistoryWriteAll
     module procedure HistoryWriteAllSP
     module procedure HistoryWriteAllDP
  end interface HistoryWriteAll

  interface HistoryGet
     module procedure HistoryGet1DSP
     module procedure HistoryGet1DDP
     module procedure HistoryGet2DSP
     module procedure HistoryGet2DDP
     module procedure HistoryGet3DSP
     module procedure HistoryGet3DDP
  end interface HistoryGet
  !-----------------------------------------------------------------------------
  !
  !++ included parameters
  !
  !-----------------------------------------------------------------------------
  !
  !++ Public parameters & variables
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private procedures
  !
  !-----------------------------------------------------------------------------
  !
  !++ Private parameters & variables
  !
  integer,                    private, parameter :: SP = 4 ! single precision
  integer,                    private, parameter :: DP = 8 ! double precision

  character(len=File_HMID),   private,      save :: HISTORY_TITLE
  character(len=File_HMID),   private,      save :: HISTORY_SOURCE
  character(len=File_HMID),   private,      save :: HISTORY_INSTITUTION
  character(len=File_HMID),   private,      save :: HISTORY_TIME_UNITS

  integer,                    private, parameter :: History_req_limit = 1000 !> number limit for history item request
  character(len=File_HLONG),  private,      save :: History_req_basename(History_req_limit)
  character(len=File_HSHORT), private,      save :: History_req_item    (History_req_limit)
  real(DP),                   private,      save :: History_req_tintsec (History_req_limit)
  logical,                    private,      save :: History_req_tavg    (History_req_limit)
  integer,                    private,      save :: History_req_dtype   (History_req_limit)

  integer,                    private,              save :: History_req_nmax = 0 !> number of requested item
  character(len=File_HSHORT), private, allocatable, save :: History_item   (:)
  integer,                    private, allocatable, save :: History_fid    (:)
  integer,                    private, allocatable, save :: History_vid    (:)
  real(DP),                   private, allocatable, save :: History_tintsec(:)
  logical,                    private, allocatable, save :: History_tavg   (:)

  real(DP),                   private, allocatable, save :: History_varsum (:,:)
  integer,                    private, allocatable, save :: History_size   (:)
  real(DP),                   private, allocatable, save :: History_tstrsec(:)
  real(DP),                   private, allocatable, save :: History_tsumsec(:)

  integer,                    private,              save :: History_id_count = 0 !> number of registered item

  character(len=File_HSHORT), private, allocatable, save :: History_dim_name(:)
  integer,                    private, allocatable, save :: History_dim_size(:)
  character(len=File_HMID),   private, allocatable, save :: History_dim_desc(:)
  character(len=File_HSHORT), private, allocatable, save :: History_dim_units(:)
  integer,                    private, allocatable, save :: History_dim_type(:)

  real(DP),                   private, parameter :: eps = 1.D-10 !> epsilon for timesec

  character(LEN=LOG_LMSG),    private :: message

contains
  !-----------------------------------------------------------------------------
  subroutine HistoryInit( &
       title, source, institution,                         & ! (in)
       dim_name, dim_size, dim_desc, dim_units,            & ! (in)
       dim_type,                                           & ! (in) optional
       default_basename,                                   & ! (in) optional
       default_tinterval, default_tunit, default_taverage, & ! (in) optional
       default_datatype,                                   & ! (in) optional
       namelist_filename, namelist_fid                     & ! (in) optional
       )
    use dc_calendar, only: &
       CalendarYmdhms2sec
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8, &
       File_preclist
    implicit none

    character(len=*), intent(in)           :: title
    character(len=*), intent(in)           :: source
    character(len=*), intent(in)           :: institution
    character(len=*), intent(in)           :: dim_name(:)
    integer,          intent(in)           :: dim_size(:)
    character(len=*), intent(in)           :: dim_desc(:)
    character(len=*), intent(in)           :: dim_units(:)
    character(len=*), intent(in), optional :: dim_type(:)
    character(len=*), intent(in), optional :: default_basename
    real(DP)        , intent(in), optional :: default_tinterval
    character(len=*), intent(in), optional :: default_tunit
    logical,          intent(in), optional :: default_taverage
    character(len=*), intent(in), optional :: default_datatype
    character(len=*), intent(in), optional :: namelist_filename
    integer         , intent(in), optional :: namelist_fid

    integer :: ndims
    character(len=File_HLONG)  :: HISTORY_DEFAULT_BASENAME  = 'history'
    real(DP)                   :: HISTORY_DEFAULT_TINTERVAL = 1.0_DP
    character(len=File_HSHORT) :: HISTORY_DEFAULT_TUNIT     = 'sec'
    logical                    :: HISTORY_DEFAULT_TAVERAGE  = .false.
    character(len=File_HSHORT) :: HISTORY_DEFAULT_DATATYPE  = 'REAL4'

    NAMELIST / PARAM_HISTORY / &
         HISTORY_TITLE,             &
         HISTORY_SOURCE,            &
         HISTORY_INSTITUTION,       &
         HISTORY_TIME_UNITS,        &
         HISTORY_DEFAULT_BASENAME,  &
         HISTORY_DEFAULT_TINTERVAL, &
         HISTORY_DEFAULT_TUNIT,     &
         HISTORY_DEFAULT_TAVERAGE,  &
         HISTORY_DEFAULT_DATATYPE

    character(len=File_HLONG)  :: BASENAME  !> file base name
    character(len=File_HSHORT) :: ITEM      !> name of history item
    real(DP)                    :: TINTERVAL !> time interval to output
    character(len=File_HSHORT) :: TUNIT     !> time unit
    logical                    :: TAVERAGE  !> time average to output
    character(len=File_HSHORT) :: DATATYPE  !> data type

    NAMELIST / HISTITEM / &
       BASENAME,  &
       ITEM,      &
       TINTERVAL, &
       TUNIT,     &
       TAVERAGE,  &
       DATATYPE

    integer :: fid_conf

    integer :: ierr
    integer :: n
    integer :: arysize, memsize
    intrinsic size
    !---------------------------------------------------------------------------

    call Log('I', '')
    call Log('I', '+++ Module[HISTORY]/Categ[IO]')

    ndims = size(dim_name)
    if ( size(dim_size)  /= ndims .or. &
         size(dim_desc)  /= ndims .or. &
         size(dim_units) /= ndims      &
         ) then
       call Log('E', 'xxx size of dimensions are mismatch')
    end if

    !--- read namelist
    HISTORY_TITLE       = title
    HISTORY_SOURCE      = source
    HISTORY_INSTITUTION = institution
    HISTORY_TIME_UNITS  = 'sec'
    if ( present(default_basename) ) then
       HISTORY_DEFAULT_BASENAME = default_basename
    end if
    if ( present(default_tinterval) ) then
       HISTORY_DEFAULT_TINTERVAL = default_tinterval
       if ( present(default_tunit) ) then
          HISTORY_DEFAULT_TUNIT = default_tunit
       end if
    end if
    if ( present(default_taverage) ) then
       HISTORY_DEFAULT_TAVERAGE = default_taverage
    end if
    if ( present(default_datatype) ) then
       HISTORY_DEFAULT_DATATYPE = default_datatype
    end if

    if ( present(namelist_fid) ) then
       fid_conf = namelist_fid
       rewind(fid_conf)
    else if ( present(namelist_filename) .and. trim(namelist_filename) /= '' ) then
       open( fid_conf, file = trim(namelist_filename), &
            form = 'formatted', status = 'old', iostat = ierr)
    else
       call Log('I', '*** No namelist was specified. Default used. ***')
       fid_conf = -1
    end if

    if ( fid_conf > 0 ) then
       read(fid_conf, nml=PARAM_HISTORY, iostat=ierr)

       if( ierr < 0 ) then !--- missing
          call Log('I', '*** Not found namelist. Default used.')
       elseif( ierr > 0 ) then !--- fatal error
          call Log('E', 'xxx Not appropriate names in namelist PARAM_HISTORY. Check!')
       endif
       write(message,nml=PARAM_HISTORY)
       call Log('I', message)
    end if

    allocate(History_dim_name (ndims))
    allocate(History_dim_size (ndims))
    allocate(History_dim_desc (ndims))
    allocate(History_dim_units(ndims))
    allocate(History_dim_type (ndims))
    do n = 1, ndims
      History_dim_name(n)  = dim_name(n)
      History_dim_size(n)  = dim_size(n)
      History_dim_desc(n)  = dim_desc(n)
      History_dim_units(n) = dim_units(n)
      History_dim_type(n)  = File_REAL4
      if ( present(dim_type) ) then
         if ( size(dim_type) >= n ) then
            if    ( trim(dim_type(n)) == 'REAL4' ) then
               History_dim_type(n) = File_REAL4
            elseif( trim(dim_type(n)) == 'REAL8' ) then
               History_dim_type(n) = File_REAL8
            else
               write(message,*) 'xxx Not appropriate dim_type. Check!', dim_type(n), n
               call Log('E', message)
            endif
         end if
      end if
    end do

    ! listup history request
    if ( fid_conf > 0 ) then
       rewind( fid_conf )
       do n = 1, History_req_limit
          read(fid_conf, nml=HISTITEM, iostat=ierr)
          if( ierr /= 0 ) exit
       enddo
       History_req_nmax = n - 1
    else
       History_req_nmax = History_req_limit
    end if

    if    ( History_req_nmax > History_req_limit ) then
       write(message,*) '*** request of history file is exceed! n >', History_req_limit
       call Log('I', message)
    elseif( History_req_nmax == 0 ) then
       call Log('I', '*** No history file specified.')
       return
    endif

    arysize = 1
    do n = 1, ndims
       arysize = arysize * dim_size(n)
    end do

    allocate( History_item   (History_req_nmax) ); History_item(:) = ''
    allocate( History_fid    (History_req_nmax) )
    allocate( History_vid    (History_req_nmax) )
    allocate( History_tintsec(History_req_nmax) )
    allocate( History_tavg   (History_req_nmax) )

    allocate( History_varsum (arysize,History_req_nmax) )
    allocate( History_size   (History_req_nmax) )
    allocate( History_tstrsec(History_req_nmax) )
    allocate( History_tsumsec(History_req_nmax) )

    if ( fid_conf > 0 ) rewind(fid_conf)
    memsize = 0
    do n = 1, History_req_nmax
       ! set default
       BASENAME  = HISTORY_DEFAULT_BASENAME
       ITEM      = 'unknown'
       TINTERVAL = HISTORY_DEFAULT_TINTERVAL
       TUNIT     = HISTORY_DEFAULT_TUNIT
       TAVERAGE  = HISTORY_DEFAULT_TAVERAGE
       DATATYPE  = HISTORY_DEFAULT_DATATYPE

       if ( fid_conf > 0 ) then
          read(fid_conf, nml=HISTITEM,iostat=ierr)
          if( ierr /= 0 ) exit
       end if

       History_req_item(n) = ITEM
       History_req_basename(n) = BASENAME
       call CalendarYmdhms2sec( History_req_tintsec(n), TINTERVAL, TUNIT )
       History_req_tavg(n) = TAVERAGE

       if ( History_req_tintsec(n) <= 0.D0 ) then
          write(message,*) 'xxx Not appropriate time interval. Check!', ITEM, TINTERVAL
          call Log('E', message)
       endif

       if    ( trim(DATATYPE) == 'REAL4' ) then
          History_req_dtype(n) = File_REAL4
       elseif( trim(DATATYPE) == 'REAL8' ) then
          History_req_dtype(n) = File_REAL8
       else
          write(message,*) 'xxx Not appropriate DATATYPE. Check!', DATATYPE
          call Log('E', message)
       endif

       memsize = memsize + arysize*File_preclist(History_req_dtype(n))
    enddo

    write(message,*) '*** Number of requested history item             : ', History_req_nmax
    call Log('I', message)
    write(message,*) '*** Output default data type                             : ', HISTORY_DEFAULT_DATATYPE
    call Log('I', message)
    write(message,*) '*** Memory usage for history data buffer [Mbyte] : ', memsize/1024/1024
    call Log('I', message)

    if ( (.not. present(namelist_fid)) .and. fid_conf > 0 ) close(fid_conf)

    return
  end subroutine HistoryInit

  !-----------------------------------------------------------------------------
  subroutine HistoryAddVariable( &
      varname, &
      dims,    &
      desc,    &
      units,   &
      master,  &
      myrank,  &
      options, &
      itemid   )
    use gtool_file, only : &
         FileCreate, &
         FileSetOption, &
         FileAddVariable
    implicit none

    character(len=*), intent( in) :: varname
    character(len=*), intent( in) :: dims(:)
    character(len=*), intent( in) :: desc
    character(len=*), intent( in) :: units
    integer,          intent( in) :: master
    integer,          intent( in) :: myrank
    character(len=*), intent( in), optional :: options ! 'filetype1:key1=val1&filetype2:key2=val2&...'
    integer,          intent(out), optional :: itemid

    integer :: id
    integer :: ary_size
    integer :: nmax, reqid
    integer :: n, m, l
    integer :: ic, ie, is, lo
    intrinsic size
    !---------------------------------------------------------------------------

    !--- search existing item
    id = -1
    nmax = min( History_id_count, History_req_nmax )
    do n = 1, nmax
       if ( trim(varname) == trim(History_item(n)) ) then ! match existing item
          if ( present(itemid) ) itemid = n
          return
       endif
    enddo


    if ( id < 0 ) then ! request-register matching check
       do n = 1, History_req_nmax
          if ( trim(varname) == History_req_item(n) ) then
             reqid  = n
             History_id_count = History_id_count + 1
             id = History_id_count

             ! new file registration
             call FileCreate(History_fid(id),                           & ! (out)
                  trim(History_req_basename(reqid)),                    & ! (in)
                  HISTORY_TITLE, HISTORY_SOURCE, HISTORY_INSTITUTION,   & ! (in)
                  History_dim_name, History_dim_size, History_dim_desc, & ! (in)
                  History_dim_units, History_dim_type,                  & ! (in)
                  master, myrank,                                       & ! (in)
                  time_units = HISTORY_TIME_UNITS                       & ! (in)
                  )

             if ( present(options) ) then
                ic = -1 ! index of ':'
                ie = -1 ! index of '='
                is = 1  ! start index
                lo = len_trim(options)
                do m = 1, lo+1
                   if ( m == lo+1 .or. options(m:m) == '&' ) then
                      if ( ic == -1 .or. ie == -1 ) then
                         call Log('E', 'xxx option is invalid: ' // trim(options))
                      end if
                      call FileSetOption(History_fid(id),        & ! (in)
                           options(is:ic-1),                     & ! (in)
                           options(ic+1:ie-1), options(ie+1:m-1) ) ! (in)
                      ic = -1
                      ie = -1
                      is = m + 1
                   else if ( options(m:m) == ':' ) then
                      ic = m
                   else if ( options(m:m) == '=' ) then
                      ie = m
                   end if
                end do
             end if

             call FileAddVariable(History_vid(id), & ! (out)
                  History_fid(id),                 & ! (in)
                  varname, desc, units, dims,      & ! (in)
                  History_req_dtype  (reqid),      & ! (in)
                  History_req_tintsec(reqid),      & ! (in)
                  History_req_tavg   (reqid)       & ! (in)
                  )

             ary_size = 1
             do m = 1, size(dims)
                do l = 1, size(History_dim_name)
                   if ( trim(dims(m)) == trim(History_dim_name(l)) ) then
                      if ( History_dim_size(l) > 0 ) then
                         ary_size = ary_size * History_dim_size(l)
                         exit
                      end if
                   end if
                end do
             end do

             History_item   (id) = varname

             History_tintsec(id) = History_req_tintsec(reqid)
             History_tavg   (id) = History_req_tavg   (reqid)

             History_varsum(:,id) =  0.D0
             History_size    (id) = ary_size
             History_tstrsec (id) = -1.D0
             History_tsumsec (id) =  0.D0

             write(message,*) '*** [HIST] Item registration No.= ', id
             call Log('I', message)
             write(message,*) '] Name           : ', trim(History_item(id))
             call Log('I', message)
             write(message,*) '] Description    : ', trim(desc)
             call Log('I', message)
             write(message,*) '] Unit           : ', trim(units)
             call Log('I', message)
             write(message,*) '] size           : ', ary_size
             call Log('I', message)
             write(message,*) '] Interval [sec] : ', History_tintsec(id)
             call Log('I', message)
             write(message,*) '] Average?       : ', History_tavg   (id)
             call Log('I', message)
          endif
       enddo
    endif

    if ( present(itemid) ) itemid = id

    return
  end subroutine HistoryAddVariable

  !-----------------------------------------------------------------------------
  ! interface HistoryPutAxis
  !-----------------------------------------------------------------------------
  subroutine HistoryPutAxisSP( &
       dim, & ! (in)
       val  & ! (in)
       )
    use gtool_file, only : &
         FilePutAxis
    implicit none

    character(len=*), intent(in) :: dim
    real(SP),         intent(in) :: val(:)

    integer :: m, n
    logical :: flag = .false.
    intrinsic size
    !---------------------------------------------------------------------------

    do m = 1, size(History_dim_name)
       if ( trim(History_dim_name(m)) == trim(dim) ) then ! dimension is found
          flag = .true.
          exit
       end if
    end do

    if ( .not. flag ) then ! dimension was not found
       write(message,*) "xxx dimension name is invalid: ", dim
       call Log('E', message)
    end if

    do m = 1, History_id_count
       flag = .true.
       do n = 1, m-1
          if ( History_fid(m) == History_fid(n) ) then
             flag = .false.
             exit
          end if
       end do
       if ( flag ) call FilePutAxis( History_fid(m), dim, val )
    end do

    return
  end subroutine HistoryPutAxisSP
  subroutine HistoryPutAxisDP( &
       dim, & ! (in)
       val  & ! (in)
       )
    use gtool_file, only : &
         FilePutAxis
    implicit none

    character(len=*), intent(in) :: dim
    real(DP),         intent(in) :: val(:)

    integer :: m, n
    logical :: flag = .false.
    intrinsic size
    !---------------------------------------------------------------------------

    do m = 1, size(History_dim_name)
       if ( trim(History_dim_name(m)) == trim(dim) ) then ! dimension is found
          flag = .true.
          exit
       end if
    end do

    if ( .not. flag ) then ! dimension was not found
       write(message,*) "xxx dimension name is invalid: ", dim
       call Log('E', message)
    end if

    do m = 1, History_id_count
       flag = .true.
       do n = 1, m-1
          if ( History_fid(m) == History_fid(n) ) then
             flag = .false.
             exit
          end if
       end do
       if ( flag ) call FilePutAxis( History_fid(m), dim, val )
    end do

    return
  end subroutine HistoryPutAxisDP

  !-----------------------------------------------------------------------------
  subroutine HistoryPutAdditionalAxisSP( &
       name,  & ! (in)
       desc,  & ! (in)
       units, & ! (in)
       dim,   & ! (in)
       var,   & ! (in)
       dtype  & ! (in) optional
       )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    use gtool_file, only : &
       FilePutAdditionalAxis
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim
    real(SP),         intent(in) :: var(:)
    character(len=*), intent(in), optional :: dtype

    integer :: type
    integer :: m, n
    logical flag
    intrinsic size
    !---------------------------------------------------------------------------

    if ( present(dtype) ) then
       if ( trim(dtype) == 'REAL4' ) then
          type = File_REAL4
       else if ( trim(dtype) == 'REAL8' ) then
          type = File_REAL8
       else
          write(message,*) 'xxx Not appropriate dtype. Check!', dtype
          call Log('E', message)
       end if
    else
       type = File_REAL4
    end if

    do m = 1, size(History_dim_name)
       if ( trim(History_dim_name(m)) == trim(dim) ) then
          if ( History_dim_size(m) /= size(var) ) then
             write(message,*) 'xxx size of var is not match to dim. Check!', size(var), History_dim_size(m), '(', dim, ')'
             call Log('E', message)
          end if
          exit
       end if
    end do

    do m = 1, History_id_count
       flag = .true.
       do n = 1, m-1
          if ( History_fid(m) == History_fid(n) ) then
             flag = .false.
             exit
          end if
       end do
       if ( flag ) then
          call FilePutAdditionalAxis( History_fid(m),       & ! (in)
               name, desc, units, dim, type, var, size(var) ) ! (in)
       end if
    end do

    return
  end subroutine HistoryPutAdditionalAxisSP
  subroutine HistoryPutAdditionalAxisDP( &
       name,  & ! (in)
       desc,  & ! (in)
       units, & ! (in)
       dim,   & ! (in)
       var,   & ! (in)
       dtype  & ! (in) optional
       )
    use gtool_file_h, only: &
       File_REAL4, &
       File_REAL8
    use gtool_file, only : &
       FilePutAdditionalAxis
    implicit none

    character(len=*), intent(in) :: name
    character(len=*), intent(in) :: desc
    character(len=*), intent(in) :: units
    character(len=*), intent(in) :: dim
    real(DP),         intent(in) :: var(:)
    character(len=*), intent(in), optional :: dtype

    integer :: type
    integer :: m, n
    logical flag
    intrinsic size
    !---------------------------------------------------------------------------

    if ( present(dtype) ) then
       if ( trim(dtype) == 'REAL4' ) then
          type = File_REAL4
       else if ( trim(dtype) == 'REAL8' ) then
          type = File_REAL8
       else
          write(message,*) 'xxx Not appropriate dtype. Check!', dtype
          call Log('E', message)
       end if
    else
       type = File_REAL8
    end if

    do m = 1, size(History_dim_name)
       if ( trim(History_dim_name(m)) == trim(dim) ) then
          if ( History_dim_size(m) /= size(var) ) then
             write(message,*) 'xxx size of var is not match to dim. Check!', size(var), History_dim_size(m), '(', dim, ')'
             call Log('E', message)
          end if
          exit
       end if
    end do

    do m = 1, History_id_count
       flag = .true.
       do n = 1, m-1
          if ( History_fid(m) == History_fid(n) ) then
             flag = .false.
             exit
          end if
       end do
       if ( flag ) then
          call FilePutAdditionalAxis( History_fid(m),       & ! (in)
               name, desc, units, dim, type, var, size(var) ) ! (in)
       end if
    end do

    return
  end subroutine HistoryPutAdditionalAxisDP

  !-----------------------------------------------------------------------------
  ! interface HistoryPut
  !-----------------------------------------------------------------------------
  subroutine HistoryPut1DNameSP( &
       varname, &
       var,     &
       dt,      &
       force    )
    implicit none

    character(len=*), intent(in)           :: varname
    real(SP),         intent(in)           :: var(:)
    real(SP),         intent(in)           :: dt
    logical,          intent(in), optional :: force

    integer :: itemid, n
    !---------------------------------------------------------------------------

    ! search item id
    itemid = -1
    do n = 1, History_id_count
       if ( trim(varname) == trim(History_item(n)) ) then
          itemid = n
          exit
       end if
    end do

    call HistoryPut1DIdSP(itemid, var, dt, force)

    return
  end subroutine HistoryPut1DNameSP
  subroutine HistoryPut1DIdSP( &
       itemid,  &
       var,     &
       dt,      &
       force    )
    implicit none

    integer,          intent(in)           :: itemid
    real(SP),         intent(in)           :: var(:)
    real(SP),         intent(in)           :: dt
    logical,          intent(in), optional :: force

    integer :: ijk(1), idx
    integer :: i
    intrinsic shape
    !---------------------------------------------------------------------------

    if ( itemid < 0 ) return

    ijk = shape(var)

    if ( History_tavg(itemid) ) then
       do i = 1, ijk(1)
          idx = i
          History_varsum(idx,itemid) = &
                  History_varsum(idx,itemid) &
                  + var(i) * dt
       end do
    else
       do i = 1, ijk(1)
          idx = i
          History_varsum(idx,itemid) = var(i)
       end do
    endif
    History_tsumsec(itemid) = History_tsumsec(itemid) + dt

    return
  end subroutine HistoryPut1DIdSP
  subroutine HistoryPut1DNameDP( &
       varname, &
       var,     &
       dt,      &
       force    )
    implicit none

    character(len=*), intent(in)           :: varname
    real(DP),         intent(in)           :: var(:)
    real(DP),         intent(in)           :: dt
    logical,          intent(in), optional :: force

    integer :: itemid, n
    !---------------------------------------------------------------------------

    ! search item id
    itemid = -1
    do n = 1, History_id_count
       if ( trim(varname) == trim(History_item(n)) ) then
          itemid = n
          exit
       end if
    end do

    call HistoryPut1DIdDP(itemid, var, dt, force)

    return
  end subroutine HistoryPut1DNameDP
  subroutine HistoryPut1DIdDP( &
       itemid,  &
       var,     &
       dt,      &
       force    )
    implicit none

    integer,          intent(in)           :: itemid
    real(DP),         intent(in)           :: var(:)
    real(DP),         intent(in)           :: dt
    logical,          intent(in), optional :: force

    integer :: ijk(1), idx
    integer :: i
    intrinsic shape
    !---------------------------------------------------------------------------

    if ( itemid < 0 ) return

    ijk = shape(var)

    if ( History_tavg(itemid) ) then
       do i = 1, ijk(1)
          idx = i
          History_varsum(idx,itemid) = &
                  History_varsum(idx,itemid) &
                  + var(i) * dt
       end do
    else
       do i = 1, ijk(1)
          idx = i
          History_varsum(idx,itemid) = var(i)
       end do
    endif
    History_tsumsec(itemid) = History_tsumsec(itemid) + dt

    return
  end subroutine HistoryPut1DIdDP
  subroutine HistoryPut2DNameSP( &
       varname, &
       var,     &
       dt,      &
       force    )
    implicit none

    character(len=*), intent(in)           :: varname
    real(SP),         intent(in)           :: var(:,:)
    real(SP),         intent(in)           :: dt
    logical,          intent(in), optional :: force

    integer :: itemid, n
    !---------------------------------------------------------------------------

    ! search item id
    itemid = -1
    do n = 1, History_id_count
       if ( trim(varname) == trim(History_item(n)) ) then
          itemid = n
          exit
       end if
    end do

    call HistoryPut2DIdSP(itemid, var, dt, force)

    return
  end subroutine HistoryPut2DNameSP
  subroutine HistoryPut2DIdSP( &
       itemid,  &
       var,     &
       dt,      &
       force    )
    implicit none

    integer,          intent(in)           :: itemid
    real(SP),         intent(in)           :: var(:,:)
    real(SP),         intent(in)           :: dt
    logical,          intent(in), optional :: force

    integer :: ijk(2), idx
    integer :: i, j
    intrinsic shape
    !---------------------------------------------------------------------------

    if ( itemid < 0 ) return

    ijk = shape(var)

    if ( History_tavg(itemid) ) then
       do j = 1, ijk(2)
       do i = 1, ijk(1)
          idx = j*ijk(i)+i
          History_varsum(idx,itemid) = &
                  History_varsum(idx,itemid) &
                  + var(i,j) * dt
       end do
       end do
    else
       do j = 1, ijk(2)
       do i = 1, ijk(1)
          idx = j*ijk(i)+i
          History_varsum(idx,itemid) = var(i,j)
       end do
       end do
    endif
    History_tsumsec(itemid) = History_tsumsec(itemid) + dt

    return
  end subroutine HistoryPut2DIdSP
  subroutine HistoryPut2DNameDP( &
       varname, &
       var,     &
       dt,      &
       force    )
    implicit none

    character(len=*), intent(in)           :: varname
    real(DP),         intent(in)           :: var(:,:)
    real(DP),         intent(in)           :: dt
    logical,          intent(in), optional :: force

    integer :: itemid, n
    !---------------------------------------------------------------------------

    ! search item id
    itemid = -1
    do n = 1, History_id_count
       if ( trim(varname) == trim(History_item(n)) ) then
          itemid = n
          exit
       end if
    end do

    call HistoryPut2DIdDP(itemid, var, dt, force)

    return
  end subroutine HistoryPut2DNameDP
  subroutine HistoryPut2DIdDP( &
       itemid,  &
       var,     &
       dt,      &
       force    )
    implicit none

    integer,          intent(in)           :: itemid
    real(DP),         intent(in)           :: var(:,:)
    real(DP),         intent(in)           :: dt
    logical,          intent(in), optional :: force

    integer :: ijk(2), idx
    integer :: i, j
    intrinsic shape
    !---------------------------------------------------------------------------

    if ( itemid < 0 ) return

    ijk = shape(var)

    if ( History_tavg(itemid) ) then
       do j = 1, ijk(2)
       do i = 1, ijk(1)
          idx = j*ijk(i)+i
          History_varsum(idx,itemid) = &
                  History_varsum(idx,itemid) &
                  + var(i,j) * dt
       end do
       end do
    else
       do j = 1, ijk(2)
       do i = 1, ijk(1)
          idx = j*ijk(i)+i
          History_varsum(idx,itemid) = var(i,j)
       end do
       end do
    endif
    History_tsumsec(itemid) = History_tsumsec(itemid) + dt

    return
  end subroutine HistoryPut2DIdDP
  subroutine HistoryPut3DNameSP( &
       varname, &
       var,     &
       dt,      &
       force    )
    implicit none

    character(len=*), intent(in)           :: varname
    real(SP),         intent(in)           :: var(:,:,:)
    real(SP),         intent(in)           :: dt
    logical,          intent(in), optional :: force

    integer :: itemid, n
    !---------------------------------------------------------------------------

    ! search item id
    itemid = -1
    do n = 1, History_id_count
       if ( trim(varname) == trim(History_item(n)) ) then
          itemid = n
          exit
       end if
    end do

    call HistoryPut3DIdSP(itemid, var, dt, force)

    return
  end subroutine HistoryPut3DNameSP
  subroutine HistoryPut3DIdSP( &
       itemid,  &
       var,     &
       dt,      &
       force    )
    implicit none

    integer,          intent(in)           :: itemid
    real(SP),         intent(in)           :: var(:,:,:)
    real(SP),         intent(in)           :: dt
    logical,          intent(in), optional :: force

    integer :: ijk(3), idx
    integer :: i, j, k
    intrinsic shape
    !---------------------------------------------------------------------------

    if ( itemid < 0 ) return

    ijk = shape(var)

    if ( History_tavg(itemid) ) then
       do k = 1, ijk(3)
       do j = 1, ijk(2)
       do i = 1, ijk(1)
          idx = (k*ijk(2)+j)*ijk(1)+i
          History_varsum(idx,itemid) = &
                  History_varsum(idx,itemid) &
                  + var(i,j,k) * dt
       end do
       end do
       end do
    else
       do k = 1, ijk(3)
       do j = 1, ijk(2)
       do i = 1, ijk(1)
          idx = (k*ijk(2)+j)*ijk(1)+i
          History_varsum(idx,itemid) = var(i,j,k)
       end do
       end do
       end do
    endif
    History_tsumsec(itemid) = History_tsumsec(itemid) + dt

    return
  end subroutine HistoryPut3DIdSP
  subroutine HistoryPut3DNameDP( &
       varname, &
       var,     &
       dt,      &
       force    )
    implicit none

    character(len=*), intent(in)           :: varname
    real(DP),         intent(in)           :: var(:,:,:)
    real(DP),         intent(in)           :: dt
    logical,          intent(in), optional :: force

    integer :: itemid, n
    !---------------------------------------------------------------------------

    ! search item id
    itemid = -1
    do n = 1, History_id_count
       if ( trim(varname) == trim(History_item(n)) ) then
          itemid = n
          exit
       end if
    end do

    call HistoryPut3DIdDP(itemid, var, dt, force)

    return
  end subroutine HistoryPut3DNameDP
  subroutine HistoryPut3DIdDP( &
       itemid,  &
       var,     &
       dt,      &
       force    )
    implicit none

    integer,          intent(in)           :: itemid
    real(DP),         intent(in)           :: var(:,:,:)
    real(DP),         intent(in)           :: dt
    logical,          intent(in), optional :: force

    integer :: ijk(3), idx
    integer :: i, j, k
    intrinsic shape
    !---------------------------------------------------------------------------

    if ( itemid < 0 ) return

    ijk = shape(var)

    if ( History_tavg(itemid) ) then
       do k = 1, ijk(3)
       do j = 1, ijk(2)
       do i = 1, ijk(1)
          idx = (k*ijk(2)+j)*ijk(1)+i
          History_varsum(idx,itemid) = &
                  History_varsum(idx,itemid) &
                  + var(i,j,k) * dt
       end do
       end do
       end do
    else
       do k = 1, ijk(3)
       do j = 1, ijk(2)
       do i = 1, ijk(1)
          idx = (k*ijk(2)+j)*ijk(1)+i
          History_varsum(idx,itemid) = var(i,j,k)
       end do
       end do
       end do
    endif
    History_tsumsec(itemid) = History_tsumsec(itemid) + dt

    return
  end subroutine HistoryPut3DIdDP

  !-----------------------------------------------------------------------------
  ! interface HistoryWrite
  !-----------------------------------------------------------------------------
  subroutine HistoryWriteSP( &
       itemid, &
       time, &
       force )
    use dc_calendar, only: &
       CalendarSec2ymdhms
    use gtool_file, only: &
       FileWrite
    implicit none

    integer, intent(in) :: itemid
    real(SP), intent(in) :: time
    logical, intent(in), optional :: force

    real(DP) :: stime, etime
    logical, save :: firsttime = .true.
    !---------------------------------------------------------------------------

    if( History_id_count == 0 ) return

    if (firsttime) then
       firsttime = .false.
       call HistoryOutputList
    endif

    if ( .not. ( present(force) .and. force ) .and. &
         History_tsumsec(itemid) - History_tintsec(itemid) <= -eps ) then
       return
    end if

    if ( History_tsumsec(itemid) > eps ) then
       if ( History_tavg(itemid) ) then
          History_varsum(1:History_size(itemid),itemid) = &
               History_varsum(1:History_size(itemid),itemid) / History_tsumsec(itemid)
       end if

       if ( History_tstrsec(itemid) < 0.D0 ) then ! first time
          stime = time - History_tsumsec(itemid)
          etime = time
       else
          stime = History_tstrsec(itemid)
          etime = History_tstrsec(itemid) + History_tsumsec(itemid) ! neary equal to time
       end if

       ! convert time units
       call CalendarSec2ymdhms( stime, stime, HISTORY_TIME_UNITS )
       call CalendarSec2ymdhms( etime, etime, HISTORY_TIME_UNITS )

       call FileWrite( History_vid(itemid),                & ! vid
            History_varsum(1:History_size(itemid),itemid), & ! data
            stime, etime                                   ) ! start & end time

    endif

    History_varsum(:,itemid) = 0.0_DP
    History_tstrsec (itemid) = time
    History_tsumsec (itemid) = 0.0_DP

    return
  end subroutine HistoryWriteSP
  subroutine HistoryWriteDP( &
       itemid, &
       time, &
       force )
    use dc_calendar, only: &
       CalendarSec2ymdhms
    use gtool_file, only: &
       FileWrite
    implicit none

    integer, intent(in) :: itemid
    real(DP), intent(in) :: time
    logical, intent(in), optional :: force

    real(DP) :: stime, etime
    logical, save :: firsttime = .true.
    !---------------------------------------------------------------------------

    if( History_id_count == 0 ) return

    if (firsttime) then
       firsttime = .false.
       call HistoryOutputList
    endif

    if ( .not. ( present(force) .and. force ) .and. &
         History_tsumsec(itemid) - History_tintsec(itemid) <= -eps ) then
       return
    end if

    if ( History_tsumsec(itemid) > eps ) then
       if ( History_tavg(itemid) ) then
          History_varsum(1:History_size(itemid),itemid) = &
               History_varsum(1:History_size(itemid),itemid) / History_tsumsec(itemid)
       end if

       if ( History_tstrsec(itemid) < 0.D0 ) then ! first time
          stime = time - History_tsumsec(itemid)
          etime = time
       else
          stime = History_tstrsec(itemid)
          etime = History_tstrsec(itemid) + History_tsumsec(itemid) ! neary equal to time
       end if

       ! convert time units
       call CalendarSec2ymdhms( stime, stime, HISTORY_TIME_UNITS )
       call CalendarSec2ymdhms( etime, etime, HISTORY_TIME_UNITS )

       call FileWrite( History_vid(itemid),                & ! vid
            History_varsum(1:History_size(itemid),itemid), & ! data
            stime, etime                                   ) ! start & end time

    endif

    History_varsum(:,itemid) = 0.0_DP
    History_tstrsec (itemid) = time
    History_tsumsec (itemid) = 0.0_DP

    return
  end subroutine HistoryWriteDP

  !-----------------------------------------------------------------------------
  ! interface HistoryWritaAll
  !-----------------------------------------------------------------------------
  subroutine HistoryWriteAllSP( &
       time, & ! (in)
       force & ! (in) optional
       )
    implicit none

    real(SP), intent(in) :: time
    logical,  intent(in), optional :: force

    integer :: n

    do n = 1, History_id_count
       call HistoryWrite( n, time, force )
    end do

    return
  end subroutine HistoryWriteAllSP
  subroutine HistoryWriteAllDP( &
       time, & ! (in)
       force & ! (in) optional
       )
    implicit none

    real(DP), intent(in) :: time
    logical,  intent(in), optional :: force

    integer :: n

    do n = 1, History_id_count
       call HistoryWrite( n, time, force )
    end do

    return
  end subroutine HistoryWriteAllDP

  !-----------------------------------------------------------------------------
  ! interface HistoryGet
  !-----------------------------------------------------------------------------
  subroutine HistoryGet1DDP( &
       var, &
       basename, &
       varname, &
       step, &
       myrank, &
       allow_missing, &
       single &
       )
    use gtool_file, only : &
         FileRead
    implicit none

    real(DP),         intent(out) :: var(:)
    character(len=*), intent( in) :: basename
    character(len=*), intent( in) :: varname
    integer,          intent( in) :: step
    integer,          intent( in) :: myrank
    logical,          intent( in), optional :: allow_missing
    logical,          intent( in), optional :: single
    !---------------------------------------------------------------------------

    call FileRead(var,                    & ! (out)
         basename, varname, step, myrank, & ! (in)
         allow_missing, single            & ! (in)
         )

    return
  end subroutine HistoryGet1DDP
  subroutine HistoryGet1DSP( &
       var, &
       basename, &
       varname, &
       step, &
       myrank, &
       allow_missing, &
       single &
       )
    use gtool_file, only : &
         FileRead
    implicit none

    real(SP),         intent(out) :: var(:)
    character(len=*), intent( in) :: basename
    character(len=*), intent( in) :: varname
    integer,          intent( in) :: step
    integer,          intent( in) :: myrank
    logical,          intent( in), optional :: allow_missing
    logical,          intent( in), optional :: single
    !---------------------------------------------------------------------------

    call FileRead(var,                    & ! (out)
         basename, varname, step, myrank, & ! (in)
         allow_missing, single            & ! (in)
         )

    return
  end subroutine HistoryGet1DSP
  subroutine HistoryGet2DDP( &
       var, &
       basename, &
       varname, &
       step, &
       myrank, &
       allow_missing, &
       single &
       )
    use gtool_file, only : &
         FileRead
    implicit none

    real(DP),         intent(out) :: var(:,:)
    character(len=*), intent( in) :: basename
    character(len=*), intent( in) :: varname
    integer,          intent( in) :: step
    integer,          intent( in) :: myrank
    logical,          intent( in), optional :: allow_missing
    logical,          intent( in), optional :: single
    !---------------------------------------------------------------------------

    call FileRead(var,                    & ! (out)
         basename, varname, step, myrank, & ! (in)
         allow_missing, single            & ! (in)
         )

    return
  end subroutine HistoryGet2DDP
  subroutine HistoryGet2DSP( &
       var, &
       basename, &
       varname, &
       step, &
       myrank, &
       allow_missing, &
       single &
       )
    use gtool_file, only : &
         FileRead
    implicit none

    real(SP),         intent(out) :: var(:,:)
    character(len=*), intent( in) :: basename
    character(len=*), intent( in) :: varname
    integer,          intent( in) :: step
    integer,          intent( in) :: myrank
    logical,          intent( in), optional :: allow_missing
    logical,          intent( in), optional :: single
    !---------------------------------------------------------------------------

    call FileRead(var,                    & ! (out)
         basename, varname, step, myrank, & ! (in)
         allow_missing, single            & ! (in)
         )

    return
  end subroutine HistoryGet2DSP
  subroutine HistoryGet3DDP( &
       var, &
       basename, &
       varname, &
       step, &
       myrank, &
       allow_missing, &
       single &
       )
    use gtool_file, only : &
         FileRead
    implicit none

    real(DP),         intent(out) :: var(:,:,:)
    character(len=*), intent( in) :: basename
    character(len=*), intent( in) :: varname
    integer,          intent( in) :: step
    integer,          intent( in) :: myrank
    logical,          intent( in), optional :: allow_missing
    logical,          intent( in), optional :: single
    !---------------------------------------------------------------------------

    call FileRead(var,                    & ! (out)
         basename, varname, step, myrank, & ! (in)
         allow_missing, single            & ! (in)
         )

    return
  end subroutine HistoryGet3DDP
  subroutine HistoryGet3DSP( &
       var, &
       basename, &
       varname, &
       step, &
       myrank, &
       allow_missing, &
       single &
       )
    use gtool_file, only : &
         FileRead
    implicit none

    real(SP),         intent(out) :: var(:,:,:)
    character(len=*), intent( in) :: basename
    character(len=*), intent( in) :: varname
    integer,          intent( in) :: step
    integer,          intent( in) :: myrank
    logical,          intent( in), optional :: allow_missing
    logical,          intent( in), optional :: single
    !---------------------------------------------------------------------------

    call FileRead(var,                    & ! (out)
         basename, varname, step, myrank, & ! (in)
         allow_missing, single            & ! (in)
         )

    return
  end subroutine HistoryGet3DSP

  !-----------------------------------------------------------------------------
  subroutine HistoryOutputList
    implicit none

    integer :: n
    !---------------------------------------------------------------------------

    call Log('I', '')
    call Log('I', '*** [HIST] Output item list ')
    write(message,*) '*** Number of history item :', History_req_nmax
    call Log('I', message)
    call Log('I', 'NAME           :size         :interval[sec]:avg')
    call Log('I', '============================================================================')
 
    do n = 1, History_id_count
       write(message,'(1x,A,I10,1x,f13.3,1x,L)') History_item(n), History_size(n), History_tintsec(n), History_tavg(n)
       call Log('I', message)
    enddo

    call Log('I', '============================================================================')

    return
  end subroutine HistoryOutputList

  !-----------------------------------------------------------------------------
  subroutine HistoryFinalize
    use gtool_file, only : &
       FileClose
    implicit none

    integer :: n
    !---------------------------------------------------------------------------

    do n = 1, History_id_count
       call FileClose( History_fid(n) )
    end do

    return
  end subroutine HistoryFinalize

end module gtool_history
!-------------------------------------------------------------------------------



!--
! vi:set readonly sw=4 ts=8
!
!Local Variables:
!mode: f90
!buffer-read-only:t
!End:
!
!++
